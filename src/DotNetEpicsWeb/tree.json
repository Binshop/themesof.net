{
  "Roots": [
    {
      "Issue": {
        "Id": "dotnet/core#5397",
        "CreatedAt": "2020-10-20T00:01:50+00:00",
        "CreatedBy": "samsp-msft",
        "IsClosed": false,
        "Title": ".NET is recognized as a compelling framework for building cloud native apps",
        "DescriptionMarkdown": "(placeholder)\r\nToday, .NET is seen as a stack for enterprises building LOB applications. \u201C.NET is for people who work at banks\u201D is not uncommon feedback in our customer interviews. We plan to change that by building great fundamentals and investing in OSS ecosystems that give us a platform to reach new customer bases. At the same time our existing enterprise customers want to become more Cloud Native, and we need to flatten the learning curve and barriers to adoption.\r\n\r\n\r\nScenario Areas\r\n\r\n- [ ] Improve development experience for multi-app solutions\r\n- [ ] .NET Apps can depend on containers in Dev\r\n- [ ] Ship an extensible/customizable reverse proxy performant enough for cloud scale workloads https://github.com/microsoft/reverse-proxy/issues/480\r\n- [ ] Provide an API experience that scales down well and is easier to learn https://github.com/dotnet/core/issues/5408\r\n- [ ] Optimizations for Constrained Environments \r\n- [ ] Libraries to interop with common cloud native components/services\r\n",
        "Milestone": null,
        "Assignees": [
          "glennc"
        ],
        "Labels": [
          {
            "Name": "Theme",
            "BackgroundColor": "800080"
          }
        ],
        "Kind": 0,
        "ProjectStatus": {
          "ProjectName": ".NET 6.0",
          "Column": "Proposed"
        }
      },
      "Children": [
        {
          "Issue": {
            "Id": "microsoft/reverse-proxy#480",
            "CreatedAt": "2020-10-20T00:06:06+00:00",
            "CreatedBy": "samsp-msft",
            "IsClosed": false,
            "Title": "Ship an extensible/customizable reverse proxy performant enough for cloud scale workloads",
            "DescriptionMarkdown": "As a cloud native infrastructure/service developer, I want a reverse proxy solution that is customizable to my needs and performant enough for cloud scale workloads.\r\n\r\nFrom a YARP perspective, this list represents the functionality we consider to be required for a YARP v1.\r\n\r\nThis includes the following user stories:\r\n\r\n**Configuration**\r\n- [x] Proxy supports static config files, with hot reload for handling changes #9 \r\n  - [ ] Proxy configuration is extensible for custom metadata on routes, destinations etc #485\r\n- [x] Proxy supports dynamic configuration pulling from other sources #8\r\n  - [ ] Proxy has Service Fabric integration for dynamic discovery of routes #257\r\n  - [ ] Proxy can act as a Kubernetes Ingress Controller #200\r\n- [ ] Routes can be fully dynamic and discovered on a per request basis for hyper scale hosting  #46\r\n\r\n**Routing \u0026 inbound connections**\r\n- [ ] Proxy can front multiple sites and route based on SNI/Host #14 \r\n- [x] Proxy should enable routing based on header values #405\r\n- [ ] Proxy should have active health checks to confirm the state of destinations #228\r\n- [x] Proxy supports Session Affinity to route subsequent requests to the same host#45 \r\n- [ ] Proxy can divert routes to support A/B testing, service rollout etc #126\r\n- [x] Proxy supports multiple algorithms for load balancing across destinations #58\r\n- [x] Proxy supports authentication / authorization for specific routes #122\r\n- [ ] Proxy can deliver static files directly #187\r\n- [ ] Support for Lets Encrypt for TLS termination #110 \r\n\r\n**Proxying \u0026 outbound connections**\r\n- [x] Incoming request Url can be transformed before passing to destination(s) #207\r\n- [x] Requests and responses headers can be transformed #21 \r\n- [x] Http Methods can be transformed (eg POST to PUT) #445\r\n- [ ] Outbound http connections to destinations are configurable #282 \r\n- [x] Proxy adds standard headers related to request forwarding #13\r\n- [ ] Proxy can be used in a hosted datacenter environment with limitations such as SNAT #62\r\n- [ ] Proxy can handle gRPC traffic including streaming #118\r\n- [x] Proxy component can be used stand-alone for advanced scenarios #408  \r\n\r\n**Diagnostics**\r\n- [ ] Proxy supplies metrics for monitoring performance #61\r\n- [ ] Proxy supplies logs for with pertinent  info for each stage of the request #115\r\n- [ ] Proxy has an API for determining its health #125\r\n\r\n**General**\r\n- [ ] Proxy is hardened so it can directly face the internet #16\r\n  - [ ] Proxy monitors its own load/health and throttles connections when required #470\r\n- [ ] Proxy has cloud scale performance, and is benchmarked in the lab #51  \r\n- [ ] Proxy has documentation #484\r\n- [ ] Customer can add middleware to customize the proxy functionality such as routing, header manipulation #114\r\n- [x] Support for .NET 3.1 \u0026 5 #159\r\n- [ ] Support for back pressure #290\r\n\r\n**Packaging**\r\n- [x] Proxy can be consumed as a library so it can be readily extended and customized #143\r\n- [ ] Proxy is supplied as a project template for dotnet new #77\r\n- [ ] Proxy is supplied as a pre-built exe with a configuration file #261 \r\n- [ ] Proxy is supplied as a pre-built docker image #247 \r\n\r\n\r\n\r\n\r\n\r\n\r\n\r\n",
            "Milestone": "YARP 1.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "In progress"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#9",
                "CreatedAt": "2020-03-12T16:25:29+00:00",
                "CreatedBy": "anurse",
                "IsClosed": true,
                "Title": "Proxy supports static config files, with hot reload for handling changes",
                "DescriptionMarkdown": "Config based proxies are common and we\u0027ll need to support at least basic proxy scenarios from config. Here are some initial considerations:\r\n- Define routes based on host and/or path\r\n- A restart should not be needed to pick up config changes\r\n- You should be able to augment a route with code/middleware. Kestrel does something similar using named endpoints.\r\n- List multiple back-ends per route for load balancing\r\n- Configure a load balancing strategy",
                "Milestone": "1.0.0-preview1",
                "Assignees": [
                  "Tratcher"
                ],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#485",
                "CreatedAt": "2020-10-22T13:00:07+00:00",
                "CreatedBy": "alnikola",
                "IsClosed": false,
                "Title": "Proxy configuration is extensible for custom metadata on routes, destinations etc",
                "DescriptionMarkdown": "There are several \u0060*Options\u0060 types specifying parameters of different providers and policies like \u0060CookieSessionAffinityProviderOptions\u0060, \u0060ConsecutiveFailuresHealthPolicyOptions\u0060, \u0060TransportFailureRateHealthPolicyOptions\u0060 etc. In the essence, they are part of the YARP configuration, but currently it\u0027s not possible to define them through the generic config provider mechanism. They can be set and changed through code only. There are some ad hoc workarounds to this issue created for some scenarios (e.g. health check policies), but there is a solid need for a well designed \u0060*Options\u0060 configuration mechanism.\r\n\r\nWe should design and implement a proper \u0060*Options\u0060 configuration subsystem.",
                "Milestone": null,
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#8",
                "CreatedAt": "2020-03-12T16:24:45+00:00",
                "CreatedBy": "anurse",
                "IsClosed": true,
                "Title": "Proxy supports dynamic configuration pulling from other sources",
                "DescriptionMarkdown": "There are 3 ways I can see routes being defined for a proxy:\r\n**a)** In config via a config file, changeable at runtime - this is what most proxies do today\r\n**b)** Statically defined in code - setting up static endpoints similar to the sample [startup.cs](https://github.com/dotnet/proxy/blob/60300714acb69cd6a7c3122c69dd7ccf517e5cea/src/sample/Startup.cs#L42-L44)\r\n**c)** Dynamically created by code. This seems to be what most of the Azure partners need. At startup, and periodically the code will need to query a backend to fetch both the Endpoints to listen to, and where each of those should be routed.\r\n_[added from discussion below]_\r\n**d)** When there are too many routes to load them all, we need to be able to query a database per request to load and cache routes. From our research, more Azure partners do this than C.\r\n\r\nThis last bucket is where we need to shine and differentiate ourselves from the competition.\r\nIt will need to account for:\r\n- Listening on new IP Addresses / ports\r\n- SNI and being able to dynamically lookup a cert based on the client hello\r\n- route based on the hierarchy of the URI path \u0026 query string\r\n\r\nFor some apps, they may need to do a DB lookup to discover the cert/route based on the URL being passed - so will need to have a cache and fallback mechanism.\r\n\r\nPerformance would dictate you probably need optimized structures like a trie, that I suspect are behind the existing routing tables. Either we need APIs to be able to dynamically edit the tables, and/or create and replace the tables, or be able to use the same concepts from custom app code for the proxy.\r\n",
                "Milestone": "1.0.0-preview4",
                "Assignees": [
                  "Tratcher",
                  "alnikola"
                ],
                "Labels": [
                  {
                    "Name": "Partner Blocking: Island Gateway",
                    "BackgroundColor": "094d6b"
                  },
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#257",
                "CreatedAt": "2020-06-19T22:43:15+00:00",
                "CreatedBy": "davidni",
                "IsClosed": false,
                "Title": "Proxy has Service Fabric integration for dynamic discovery of routes",
                "DescriptionMarkdown": "## Introduction\r\n\r\nAdds \u0060Microsoft.ReverseProxy.ServiceFabricIntegration\u0060 which implements dynamic discovery of Service Fabric services. The general architecture takes inspiration from [Traefik\u0027s Service Fabric integration](https://docs.traefik.io/v1.7/configuration/backends/servicefabric/), and is designed for easy and friction-free onboarding of multiple Service Fabric services operating behind YARP. Running multiple instances of YARP in the same cluster is possible, and an eventual consistency model helps avoid the need for any external storage except for the runtime Service Fabric queries used to dynamically discover services in the cluster.\r\n\r\nA Service Fabric service that wants to leverage YARP simply needs to add an \u0060\u003CExtension\u003E\u0060 element in their \u0060ServiceManifest\u0060, for example (see complete example further below):\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CExtensions\u003E\r\n  \u003CExtension Name=\u0022YARP\u0022\u003E\r\n    \u003CLabels xmlns=\u0022http://schemas.microsoft.com/2015/03/fabact-no-schema\u0022\u003E\r\n      \u003CLabel Key=\u0022YARP.Enable\u0022\u003Etrue\u003C/Label\u003E\r\n      \u003CLabel Key=\u0022YARP.Routes.route1.Hosts\u0022\u003Eexample.com\u003C/Label\u003E\r\n    \u003C/Labels\u003E\r\n  \u003C/Extension\u003E\r\n\u003C/Extensions\u003E\r\n\u0060\u0060\u0060\r\n\r\n\r\n## Functional overview\r\nThis works by periodically querying Service Fabric for all applications in a Service Fabric cluster. For each application, we enumerate all services. For each service, we extract its _labels_ and, if the service has opted in to use YARP (\u0060YARP.Enable=true\u0060). If the service that has opted in to use YARP, we then enumerate all partitions, and all instances/replicas within each partition.\r\n\r\n\r\n### Service Fabric concepts mappings to YARP\r\n\r\nService Fabric terminology|YARP terminology\r\n-|-\r\nCluster|--\r\nApplication|--\r\nService (e.g. \u0060fabric:/App1/Svc2\u0060)|Cluster (ClusterId=ServiceName)\r\nInstance / replica|Destination (Address=instance\u0027 or replica\u0027s endpoint)\r\n\u0060YARP.Routes.\u003CrouteName\u003E.*\u0060 in ServiceManifest|ProxyRoute (id=ServiceName\u002BrouteName, Match=Hosts,Path extracted from the labels)\r\n\r\n\r\n### Dynamic configurability\r\nLabels defined in the Service Manifest support the following scenarios:\r\n* Arbitrary key / value pair. Only keys understood by us are honored, and unknown keys are ignored\r\n* Application parameter reference. If the label value is of the form \u0060[appParamName]\u0060, its value will be replaced at runtime with the value of the application parameter with the same name defined for the application the service belongs to\r\n* Naming Service overrides. If label \u0060YARP.EnableDynamicOverrides\u0060 is specified as \u0060true\u0060, we will also query Service Fabric Naming Service to discover any [named properties](https://docs.microsoft.com/en-us/rest/api/servicefabric/sfclient-index-property-management). Any _properties_ found for the service being enumerated take precedence over values specified in ServiceManifest. This functionality is opt-in, and disabled by default.\r\n\r\n\r\n### Designed for high availability\r\n\r\nWe keep a cache of the last discovery results obtained from Service Fabric. If at any point, for whatever reason, we are not able to retrieve an updated view of the cluster, we will continue to operate with last-known-good data. The cache is kept in memory, but could be extended to support permanent storage on disk to also survive reboots.\r\n\r\n\r\n### Designed for use by large teams\r\nThis integration is designed to support tens of Service Fabric services hosted behind YARP, and it provides additional features to help owners of those teams self-service their devops requirements relating to YARP. When we successfully discovered a service, we emit a [Service Fabric health report](https://docs.microsoft.com/en-us/azure/service-fabric/service-fabric-health-introduction) against the discovered service. If any config errors are encountered, a Warning health report is issued, which makes it easy for the service owners to observe the errors on Service Fabric Explorer and / or telemetry. This closes the loop and makes it easy for a service in Service Fabric to confirm that its configurations are being honored and to detect any issues.\r\n\r\n\r\n### Complete ServiceManifest example:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CServiceManifest Name=\u0022Service1Pkg\u0022 Version=\u00221.0.0\u0022 xmlns=\u0022http://schemas.microsoft.com/2011/01/fabric\u0022\u003E\r\n  \u003CServiceTypes\u003E\r\n    \u003CStatelessServiceType ServiceTypeName=\u0022Service1Type\u0022 \u003E\r\n      \u003CExtensions\u003E\r\n        \u003CExtension Name=\u0022YARP\u0022\u003E\r\n          \u003CLabels xmlns=\u0022http://schemas.microsoft.com/2015/03/fabact-no-schema\u0022\u003E\r\n            \u003CLabel Key=\u0022YARP.Enable\u0022\u003Etrue\u003C/Label\u003E\r\n            \u003CLabel Key=\u0022YARP.Routes.route1.Hosts\u0022\u003Eexample.com\u003C/Label\u003E\r\n            \u003C!-- Optional: enable health probes --\u003E\r\n            \u003CLabel Key=\u0027YARP.Backend.Healthcheck.Enabled\u0027\u003Etrue\u003C/Label\u003E\r\n            \u003CLabel Key=\u0027YARP.Backend.Healthcheck.Path\u0027\u003Eapi/health\u003C/Label\u003E\r\n            \u003CLabel Key=\u0027YARP.Backend.Healthcheck.Timeout\u0027\u003E30\u003C/Label\u003E\r\n            \u003CLabel Key=\u0027YARP.Backend.Healthcheck.Interval\u0027\u003E10\u003C/Label\u003E\r\n          \u003C/Labels\u003E\r\n        \u003C/Extension\u003E\r\n      \u003C/Extensions\u003E\r\n    \u003C/StatelessServiceType\u003E\r\n  \u003C/ServiceTypes\u003E\r\n\r\n  \u003C!-- ... --\u003E\r\n\u003C/ServiceManifest\u003E\r\n\u0060\u0060\u0060\r\n\r\n\r\n## Remaining work:\r\n\r\n* [x] \u0060ServiceDiscoveryConfigApplier\u0060 needs to be cleaned up and wired up. Without this, the Service Fabric integration code will not be invoked by YARP. The implementation of \u0060ServiceDiscoveryConfigApplier\u0060 in this PR is _meant to_ (but does not achieve that in its current state) support multiple service discovery mechanisms and to allow them to be specified by config.\r\n* [x] Organize and rename labels\r\n* [x] Add sample Service Fabric projects to exercise everything E2E\r\n",
                "Milestone": null,
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Partner Blocking: Island Gateway",
                    "BackgroundColor": "094d6b"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#200",
                "CreatedAt": "2020-05-22T23:35:12+00:00",
                "CreatedBy": "galvesribeiro",
                "IsClosed": false,
                "Title": "Proxy can act as a Kubernetes Ingress Controller",
                "DescriptionMarkdown": "Hello folks!\r\n\r\nFirst of all, great work! Congratz for the first preview release! It is indeed something .Net Community was lagging behind and had for too long to deal with clumsy things like nginx.\r\n\r\nSo, I\u0027m coming to a point where I\u0027d like to make a POC with YARP for a controlled small set of microservices in Kubernetes and that comes to a need to make it an ingestion controller.\r\n\r\nWith that in mind, I would like to ask if the Kube integration is something you guys plan to have on this repo, on some other under MSFT umbrella, or if it is something that the community will have to implemente for their own needs.\r\n\r\nIf it is something MSFT will (or already is) develop, ok, all we have todo is wait. If that is something that community will have to build, is that something that would be acceptable on this repo as a PR? If we should go to this PR, I\u0027de like to use this issue to discuss the approach we should take to contribute it.\r\n\r\nThanks! Keep it going!",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#46",
                "CreatedAt": "2020-04-09T22:16:36+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": false,
                "Title": "Routes can be fully dynamic and discovered on a per request basis for hyper scale hosting",
                "DescriptionMarkdown": "The current proxy routing design assumes all route data is available up front and can be loaded atomically into the route table. The EndpointDataSource routing model assumes this as well.\r\n\r\nFor more dynamically-configured services, we probably don\u0027t want to fetch the entire route table from the db, but instead have a pull and cache for each hostname model.\r\n\r\nHow can we lazy-load route, backend, and endpoint data on a per request basis?\r\n\r\nAssume we\u0027re working with a discrete key like Host, not a complicated best-match scenario like Path, and little or no wildcard support (maybe wildcard subdomains but only for specific depths?).\r\n\r\n@davidni is this a scenario you\u0027d evaluated?\r\n\r\n@rynowak can such a system work within routing, co-exist side by side routing, or would it completely replace routing?",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#14",
                "CreatedAt": "2020-03-12T16:30:17+00:00",
                "CreatedBy": "anurse",
                "IsClosed": false,
                "Title": " Proxy can front multiple sites and route based on SNI/Host ",
                "DescriptionMarkdown": "A proxy will often want to route based on the host. It\u0027s possible today but it\u0027s clunky.\r\nhttps://github.com/dotnet/aspnetcore/issues/19354",
                "Milestone": "Backlog",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "tenet-performance",
                    "BackgroundColor": "c14376"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#405",
                "CreatedAt": "2020-09-08T17:22:46+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": true,
                "Title": "Proxy should enable routing based on header values",
                "DescriptionMarkdown": "Multiple partners have asked for header based routing. I\u0027ll ask them to give examples below. @davidni has an implementation in Island Gateway and had been working on this as an AspNetCore 5 feature but it wasn\u0027t done in time (https://github.com/dotnet/aspnetcore/pull/23594). The plan is to port Island Gateway\u0027s work to YARP so it works on 3.1 and 5.0 and then contribute it back to AspNetCore in 6.0.",
                "Milestone": "1.0.0-preview6",
                "Assignees": [
                  "Tratcher"
                ],
                "Labels": [
                  {
                    "Name": "Partner Blocking: Island Gateway",
                    "BackgroundColor": "094d6b"
                  },
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#228",
                "CreatedAt": "2020-06-04T20:17:10+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": false,
                "Title": "Proxy should have active health checks to confirm the state of destinations",
                "DescriptionMarkdown": "We have the IHealthProbeWorker and associated infrastructure, but it\u0027s all internal and nobody ever starts it.\r\n\r\nThis was forked from the original partner team code before health checks were completely implemented. Some missing pieces:\r\n- An IHostedService that resolves the IHealthProbeWorker and starts and stops it when needed. \r\n- DI extensions for registering the health services.\r\n\r\n@davidni \r\n\r\n\r\n",
                "Milestone": "YARP 1.0.0-preview7",
                "Assignees": [
                  "alnikola"
                ],
                "Labels": [
                  {
                    "Name": "Partner Blocking: Island Gateway",
                    "BackgroundColor": "094d6b"
                  },
                  {
                    "Name": "Type: Bug",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#45",
                "CreatedAt": "2020-04-08T18:43:40+00:00",
                "CreatedBy": "anurse",
                "IsClosed": true,
                "Title": "Proxy supports Session Affinity to route subsequent requests to the same host",
                "DescriptionMarkdown": "We should support session affinity as a native feature in the proxy. It\u0027s effectively a load balancer directive. Some attribute of the incoming request is used as a key to identify which backend to route to.\r\n\r\nAffinity logic needs to run:\r\n* Before load balancing, to check the affinity \u0022stamp\u0022 and select a single destination (i.e. one of the servers within a backend) (if possible)\r\n* After load balancing, to stamp the selected destination into a cookie, if enabled.\r\n\r\nIt also may need to be able to re-trigger load balancing (in the failure modes below).\r\n\r\nSupported \u0022modes\u0022 (please do suggest others!):\r\n* Cookie\r\n\t* A request with no incoming \u0022stamp\u0022 is assigned to a destination by normal load balancing policy\r\n\t* The return response is stamped with a Cookie containing the destination ID, cryptographically signed by a key trusted by all proxy instances (DataProtection!)\r\n\t* On future requests, we validate the stamp and select the specific destination for routing\r\n\t* If that destination is no longer in the active set of destinations, we \u0022fail\u0022 (see failure modes)\r\n* 5-tuple (\u0060Source IP\u0060, \u0060Source Port\u0060, \u0060Dest IP\u0060, \u0060Dest Port\u0060, \u0060Protocol\u0060)\r\n\t* Hash the 5-tuple values and use it to identify a destination.\r\n\t* If that destination is no longer in the active set of destinations, we \u0022fail\u0022 (see failure modes)\r\n* Header value\r\n\t* Hash some header value and use it to identify a destination\r\n\t* Useful for auth-token based affinity (used in Azure SignalR, for example)\r\n* ~~Crazy idea: magic SignalR mode?~~ We should track this separately, just wanted to see if anyone had C O O L thoughts here.\r\n\t* It could be cool to have native support for session affinity for SignalR connections.\r\n\t* There\u0027s a connection ID in the initial \u0060/negotiate\u0060 response, which is also present in the query string of all future requests, which we could use for affinity.\r\n\t* This could be very useful for applications which don\u0027t generally need affinity, but also use SignalR (which requires affinity).\r\n\t* Could possibly be generalized\r\n\r\nFailure modes\r\n* If the session affinity system identifies a target destination which is no longer routable, a configurable failure response should be used\r\n* Possible responses\r\n\t* Re-affinitize to one of the other destinations (i.e. re-route and stamp the new backend)\r\n\t* Return a 503 (since the target destination is no longer active)\r\n\r\nThese are mostly just my rando thoughts. I\u0027m interested in @davidni \u0027s thoughts, as well as the team\u0027s (@Tratcher @halter73)",
                "Milestone": "1.0.0-preview2",
                "Assignees": [
                  "alnikola"
                ],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#126",
                "CreatedAt": "2020-04-28T23:28:58+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": false,
                "Title": "Proxy can divert routes to support A/B testing, service rollout etc",
                "DescriptionMarkdown": "A/B testing is a common scenario for proxies, letting services incrementally upgrade/experiment using live traffic.\r\n\r\nHow does a service decide which requests to route to which test group?\r\n- Assuming all requests are stateless you could decide this randomly on a per-request basis.\r\n- For a stateful service you\u0027d want to do a random assignment and then use affinization (https://github.com/microsoft/reverse-proxy/issues/45).\r\n- A service may also decide to statically affinitize based on known groups like tenants (e.g. move small customers before big ones).\r\n\r\nInitial theory:\r\n- This is a separate feature from load balancing. Within a load balancing set we assume all servers are equally able to handle a request aside from considerations of health and load. You\u0027d select a test group and then load balance within that group.\r\n- This should take advantage of the routing layer. For something like tenant based affinity that information may already be part of the route definition.\r\n- Alternatively we could put it into the route config (ProxyRoute), allowing it to specify multiple backends and an assignment strategy.\r\n- This should be compatible with retry mechanisms to allow failing over to the other test group.",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Partner Blocking: E-Core3",
                    "BackgroundColor": "6a12e5"
                  },
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#58",
                "CreatedAt": "2020-04-15T18:04:24+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": true,
                "Title": "Proxy supports multiple algorithms for load balancing across destinations",
                "DescriptionMarkdown": "Complete the set of common load balancing schemes\r\n- [x] Round Robin #72\r\n- [x] Random #73 \r\n- [x] Least loaded of 2 random #75\r\n* ~~First healthy endpoint~~ (already implemented)",
                "Milestone": null,
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": [
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#72",
                    "CreatedAt": "2020-04-20T22:09:50+00:00",
                    "CreatedBy": "anurse",
                    "IsClosed": true,
                    "Title": "Implement Round-Robin Load Balancing",
                    "DescriptionMarkdown": "Load balance by taking the \u0022next\u0022 backend in the list for each incoming request. We wrap around to the start of the list when we run out of backends.\r\n\r\nSince requests will likely be highly-concurrent, there\u0027s some complexity here in how the state is maintained. Also, since backends can change, we\u0027ll need to consider how this algorithm behaves in that case. Naively, this would be a simple atomic counter that the load balancer does an atomic increment-and-return, then modulus by the number of backends to figure out which backend to use.",
                    "Milestone": "1.0.0-preview1",
                    "Assignees": [
                      "Tratcher",
                      "samsp-msft"
                    ],
                    "Labels": [
                      {
                        "Name": "Type: Enhancement",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#73",
                    "CreatedAt": "2020-04-20T22:15:28+00:00",
                    "CreatedBy": "anurse",
                    "IsClosed": true,
                    "Title": "Implement Random Load-Balancing",
                    "DescriptionMarkdown": "This is one of the simplest load-balancers. Select a random backend from the set of healthy backends and route to it. It can be surprisingly effective, so it\u0027s a useful algorithm to have. It\u0027s also trivial to implement so it gives us a way to exercise our abstractions.",
                    "Milestone": "1.0.0-preview1",
                    "Assignees": [
                      "Tratcher"
                    ],
                    "Labels": [
                      {
                        "Name": "Type: Enhancement",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#75",
                    "CreatedAt": "2020-04-20T22:29:31+00:00",
                    "CreatedBy": "anurse",
                    "IsClosed": true,
                    "Title": "\u0022The Power of Two Choices\u0022 Load-Balancing Algorithm",
                    "DescriptionMarkdown": "This falls somewhere between Random (#73) and Least-Requests (#74). It tends to be easier to implement across a cluster of proxies.\r\n\r\nGiven that load-balancers don\u0027t share state about the load to each backend (this would be very costly), a proxy instance is making it\u0027s decision based on the number of outstanding requests **it** has to the backends, and not the number of requests **all** instances have. This means that often multiple proxy instances can see the same nodes as under-utilized and send a storm of requests to it (if the incoming traffic is randomly balanced, as tends to be the case).\r\n\r\nThe \u0022Power of Two Choices\u0022 model (discussed in some sources below) adds a degree of randomness by first selecting two random backends and **then** making a \u0022least-outstanding-requests\u0022 decision between those two. This helps to prevent these storms of traffic. This doesn\u0027t generally perform better than Least Requests/Connections in a single-node proxy deployment, but it can be better than Random in situations where each node doesn\u0027t have perfect knowledge of the load\r\n\r\n#### Sources\r\n* [NGINX and the \u201CPower of Two Choices\u201D Load-Balancing Algorithm](https://www.nginx.com/blog/nginx-power-of-two-choices-load-balancing-algorithm/)\r\n* [Test Driving \u201CPower of Two Random Choices\u201D Load Balancing](https://www.haproxy.com/blog/power-of-two-load-balancing/)\r\n* [Michael Mitzenmacher. 2001. The Power of Two Choices in Randomized Load Balancing. IEEE Trans. Parallel Distrib. Syst. 12, 10 (October 2001), 1094\u20131104. DOI:https://doi.org/10.1109/71.963420](https://www.eecs.harvard.edu/~michaelm/postscripts/tpds2001.pdf)",
                    "Milestone": "1.0.0-preview1",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Type: Idea",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                }
              ]
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#122",
                "CreatedAt": "2020-04-28T21:37:07+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": true,
                "Title": " Proxy supports authentication / authorization for specific routes",
                "DescriptionMarkdown": "When defining proxy routes we should be able to specify Authorization criteria for that route and avoid proxying requests until that criteria is met.\r\n\r\nThis will need some support to be specified from config (probably by specifying the name of an authz policy that\u0027s configured in code), but it should also be configurable when using other data sources.",
                "Milestone": "1.0.0-preview3",
                "Assignees": [
                  "Tratcher"
                ],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#187",
                "CreatedAt": "2020-05-22T08:40:21+00:00",
                "CreatedBy": "expcat",
                "IsClosed": false,
                "Title": "Proxy can deliver static files directly",
                "DescriptionMarkdown": "### What should we add or change to make your life better?\r\nSupport to configure static file resources.\r\n### Why is this important to you?\r\nAvoid using Nginx on the front end.\r\n\r\nThis is doable today if you customize the pipeline to include static files, but needs a configuration option for a stand-alone exe",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Deployment cookbook",
                    "BackgroundColor": "e5da04"
                  },
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#110",
                "CreatedAt": "2020-04-27T08:25:55+00:00",
                "CreatedBy": "RehanSaeed",
                "IsClosed": false,
                "Title": "Support for Lets Encrypt for TLS termination",
                "DescriptionMarkdown": "### What should we add or change to make your life better?\r\n\r\nMost reverse proxies out there support Lets Encrypt. @natemcmaster runs https://github.com/natemcmaster/LetsEncrypt which is trying to add LetsEncrypt support to ASP.NET Core. Please help him finish, so it can also be used on this project.\r\n\r\n### Why is this important to you?\r\n\r\nA reverse proxy without TLS termination is not very useful. Lets Encrypt is a great choice for TLS, being free, secure and automated.",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#207",
                "CreatedAt": "2020-05-26T18:52:08+00:00",
                "CreatedBy": "jmezach",
                "IsClosed": true,
                "Title": "Incoming request Url can be transformed before passing to destination(s)",
                "DescriptionMarkdown": "I\u0027ve been looking into YARP to see if it can be used as an API gateway. We currently have one based on the [Ocelot](https://github.com/ThreeMammals/Ocelot) library but since it seems that might be deprecated in favor of YARP I figured I could take a look and see if I can achieve the same thing.\r\n\r\nOne of the things I\u0027m able to do with Ocelot and which I haven\u0027t been able to achieve with YARP yet is the ability to rewrite the downstream request path. For example, let\u0027s say that I want to proxy the upstream URL https://somewhere.example.com/someapi/\u003Cthe-rest\u003E to the downstream URL https://localhost:5003/\u003Cthe-rest\u003E.\r\n\r\nI would expect this to work, however currently I\u0027m seeing request to https://localhost:5003/someapi/\u003Cthe-rest\u003E instead. Here\u0027s the config I\u0027m using:\r\n\r\n\u0060\u0060\u0060json\r\n\u0022ReverseProxy\u0022: {\r\n  \u0022Routes\u0022: [\r\n    {\r\n      \u0022RouteId\u0022: \u0022someapi\u0022,\r\n      \u0022BackendId\u0022: \u0022EchoService\u0022,\r\n      \u0022Match\u0022: {\r\n        \u0022Methods\u0022: [ \u0022GET\u0022, \u0022POST\u0022 ],\r\n        \u0022Host\u0022: \u0022somewhere.example.com\u0022,\r\n        \u0022Path\u0022: \u0022/someapi/{**catchall}\u0022\r\n      }\r\n    }\r\n  ],\r\n  \u0022Backends\u0022: {\r\n    \u0022EchoService\u0022: {\r\n      \u0022LoadBalancing\u0022: {\r\n        \u0022Mode\u0022: \u0022Random\u0022\r\n      },\r\n      \u0022Destinations\u0022: {\r\n        \u0022backend_destination1\u0022: {\r\n          \u0022Address\u0022: \u0022https://localhost:5003/\u0022\r\n        }\r\n      }\r\n    }\r\n  }\r\n},\r\n\u0060\u0060\u0060\r\n\r\nIs this something that\u0027s supported, or planned to be supported?",
                "Milestone": null,
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Discussion",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#21",
                "CreatedAt": "2020-03-19T19:11:38+00:00",
                "CreatedBy": "davidni",
                "IsClosed": true,
                "Title": "Config-based request and response header transformation",
                "DescriptionMarkdown": "In Island Gateway we implemented the notion of \u0060Transformations\u0060, which takes inspiration from Traefik\u0027s middlewares (though we\u0027re not calling them middlewares for obvious reasons). See e.g. [Traefik\u0027s StripPrefix](https://docs.traefik.io/middlewares/stripprefix/).\r\n\r\nA user can specify e.g. \u0060Transformations=StripPrefix(\u0027/api\u0027), AddPrefix(\u0027/v2\u0027)\u0060, which results in the listed processing steps being applied sequentially at runtime.\r\n\r\nThe ability to specify simple transformations like these through config is a requirement for us.\r\n\r\nExample of a route using transformations:\r\n\u0060\u0060\u0060\r\nRule            = Host(\u0027example.com\u0027) \u0026\u0026 Path(\u0027/myservice/{**catchall}\u0027)\r\nTransformations = StripPrefix(\u0027/myservice\u0027)\r\n\u0060\u0060\u0060\r\n\r\n(this is a feature we already implemented in Island Gateway, filing here as requested to track)",
                "Milestone": "1.0.0-preview2",
                "Assignees": [
                  "Tratcher"
                ],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  }
                ],
                "Kind": 3,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#445",
                "CreatedAt": "2020-09-28T15:37:55+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": true,
                "Title": "Implement method transforms",
                "DescriptionMarkdown": "https://github.com/microsoft/reverse-proxy/discussions/444\r\nSome servers only accept basic HTTP methods like GET and POST, not PUT or DELETE. Implement request method transforms like PUT -\u003E POST.\r\n- It would look a lot like the [PathSet](https://microsoft.github.io/reverse-proxy/articles/transforms.html#pathset) transform.\r\n- Derive from [RequestParamtersTransform](https://github.com/microsoft/reverse-proxy/blob/b48d6950a69e3fccb3b17e09bd64dcb0cfdcb926/src/ReverseProxy/Service/RuntimeModel/Transforms/RequestParametersTransform.cs).\r\n- Modify [RequestParametersTransformContext.Method](https://github.com/microsoft/reverse-proxy/blob/b48d6950a69e3fccb3b17e09bd64dcb0cfdcb926/src/ReverseProxy/Service/RuntimeModel/Transforms/RequestParametersTransformContext.cs#L27)\r\n\r\nRelated: Consider support for the X-Http-Method-Override header to preserve the original method. This would have to be a separate transform since headers are processed seperately.",
                "Milestone": "1.0.0-preview6",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "help wanted",
                    "BackgroundColor": "9bf47a"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#282",
                "CreatedAt": "2020-07-01T23:55:21+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Outbound http connections to destinations are configurable ",
                "DescriptionMarkdown": "https://github.com/dotnet/runtime/issues/987",
                "Milestone": "YARP 1.0.0",
                "Assignees": [
                  "ManickaP"
                ],
                "Labels": [
                  {
                    "Name": ".NET runtime schedule",
                    "BackgroundColor": "db7fc7"
                  },
                  {
                    "Name": "Partner Blocking: Collab Services",
                    "BackgroundColor": "6a12e5"
                  },
                  {
                    "Name": "Type: Tracking",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#13",
                "CreatedAt": "2020-03-12T16:29:46+00:00",
                "CreatedBy": "anurse",
                "IsClosed": true,
                "Title": "Proxy adds standard headers related to request forwarding",
                "DescriptionMarkdown": "* X-Forwarded-Proto\r\n* X-Forwarded-Host\r\n* X-Forwarded-For\r\n* X-Client-Cert\r\n* Forwarded (yes, there\u0027s a chicken-and-egg problem but I see no reason we can\u0027t break that cycle by implementing it).",
                "Milestone": "1.0.0-preview2",
                "Assignees": [
                  "Tratcher"
                ],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#62",
                "CreatedAt": "2020-04-15T18:21:30+00:00",
                "CreatedBy": "scalablecory",
                "IsClosed": false,
                "Title": "Proxy can be used in a hosted datacenter environment with limitations such as SNAT",
                "DescriptionMarkdown": "Customers behind certain firewalls or load balancers, such as Azure\u0027s SNAT, have a limit on the number of connections they can make per ip/port endpoint.\r\n\r\n\u0060HttpClient\u0060 has a \u0060MaxConnectionsPerServer\u0060 setting, but the limit is not actually applied per-server, but rather per-pool, with each pool being partitioned by a number of connection properties:\r\n- Kind, describing the type of connection (HTTP, HTTPS, Proxied HTTPS, etc.)\r\n- Host, the hostname in the request URI.\r\n- Port, the port in the request URI.\r\n- SslHostName, the SNI value associated with the connection (might be hostname from URI, might be Host header)\r\n- ProxyUri, the proxy that is being used to transport the connection.\r\n- Identity, the user the connection was authenticated over.\r\n\r\nIt is unreasonable to apply a meaningful SNAT limit on top of \u0060HttpClient\u0060 because the client will pool connections and does not expose connection lifetime events to the user.",
                "Milestone": "YARP 1.0.0",
                "Assignees": [
                  "scalablecory"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#118",
                "CreatedAt": "2020-04-27T22:25:04+00:00",
                "CreatedBy": "davidni",
                "IsClosed": false,
                "Title": "Proxy can handle gRPC traffic including streaming",
                "DescriptionMarkdown": "Streaming requests (e.g. duplex gRPC request) require special handling by YARP (at a minimum, e.g. remove minimum request data rate enforcement).\r\n\r\nToday we check for gRPC content type, but this is both too broad (not all gRPC requests require streaming semantics) as well as too narrow (other protocols than gRPC on top of HTTP/2 could also require streaming semantics).\r\n\r\nSome proposals were discussed  in https://github.com/microsoft/reverse-proxy/pull/80#discussion_r416156407",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Discussion",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#408",
                "CreatedAt": "2020-09-09T17:30:11+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": true,
                "Title": "Proxy component can be used stand-alone for advanced scenarios",
                "DescriptionMarkdown": "Many users have very basic needs from a proxy. They don\u0027t need load balancing, affinity, or even routing, or they address those concerns in their own way. What these users really need is the code from [HttpProxy](https://github.com/microsoft/reverse-proxy/blob/c1d65e944d2205c2d442d45785e7875bd87c0fde/src/ReverseProxy/Service/Proxy/HttpProxy.cs) that manages the transition between HttpContext and HttpRequestMessage. They want to call this from their own controller or middleware to forward specific requests to specific destinations.\r\n\r\nConsider directly exposing HttpProxy (or a more targeted API) for these use cases.",
                "Milestone": "1.0.0-preview6",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Partner Blocking: Collab Services",
                    "BackgroundColor": "6a12e5"
                  },
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#61",
                "CreatedAt": "2020-04-15T18:12:41+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Proxy supplies metrics for monitoring performance",
                "DescriptionMarkdown": "Collect metrics for all stages of the proxy processing, including outbound http requests",
                "Milestone": "YARP 1.0.0-preview7",
                "Assignees": [
                  "MihaZupan"
                ],
                "Labels": [
                  {
                    "Name": ".NET runtime schedule",
                    "BackgroundColor": "db7fc7"
                  },
                  {
                    "Name": "ASP.NET Schedule",
                    "BackgroundColor": "db7fc7"
                  },
                  {
                    "Name": "Partner Blocking: Island Gateway",
                    "BackgroundColor": "094d6b"
                  },
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#115",
                "CreatedAt": "2020-04-27T17:24:56+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": false,
                "Title": "Proxy supplies logs for with pertinent  info for each stage of the request ",
                "DescriptionMarkdown": "https://github.com/microsoft/reverse-proxy/blob/00c4e7c77059b7c4a9912a4c89c9a05026d55628/src/ReverseProxy.Core/Middleware/LoadBalancingMiddleware.cs#L47-L49\r\n\r\nUsing the IOperationLogger allocates a closure per call per request. We need to re-think how to write these start/stop/failed logs.",
                "Milestone": "YARP 1.0.0-preview7",
                "Assignees": [
                  "MihaZupan"
                ],
                "Labels": [
                  {
                    "Name": "Type: Bug",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#125",
                "CreatedAt": "2020-04-28T21:40:57+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Proxy has an API for determining its health",
                "DescriptionMarkdown": "### What should we add or change to make your life better?\r\nAdd an API that can be used to collect statistics and state of the proxy. This would also have events for lifetime so that app code can know when the proxy is shutting down.\r\n### Why is this important to you?\r\nIt provides a foundational piece of infrastructure for solving:\r\n#23 part c - API for app code to shutdown the proxy\r\n#124 - REST or gRPC API for remote access to proxy status\r\n#123 - Dashboard for proxy config \u0026 status",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#16",
                "CreatedAt": "2020-03-12T16:31:03+00:00",
                "CreatedBy": "anurse",
                "IsClosed": false,
                "Title": " Proxy is hardened so it can directly face the internet ",
                "DescriptionMarkdown": "We expect several features to be add-ins that plug in as connection middleware. Add a connection middleware to the sample in this repo.\r\n\r\nHere\u0027s one example from Http2:\r\nhttps://github.com/dotnet/aspnetcore/blob/09bb7b4ca5a4fbde0283c294c35fac8b485c0074/src/Servers/Kestrel/samples/Http2SampleApp/Program.cs#L41-L54\r\n\r\nOther things we expect to need to plug into here:\r\n- Sniff SNI and rate limit\r\n- Rate limit SSL handshakes by IP\r\n\r\nWe don\u0027t have to write those components as part of this task, just demonstrate that a connection middleware has access to the necessary inputs and controls (e.g. IPs, sniffing the data stream, drop connections, etc.).\r\n\r\nSpecifically, this involves being able to filter connections based on information contained in the ClientHello TLS frame. Examples include:\r\n- Cipher Suite selection\r\n- Protocol Version\r\n- Server Name Indication (SNI)\r\n- Application-Level Protocol Negotiation (ALPN; used for HTTP/2 and HTTP/3)",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#470",
                "CreatedAt": "2020-10-15T16:43:51+00:00",
                "CreatedBy": "alnikola",
                "IsClosed": false,
                "Title": "Proxy monitors its own load/health and throttles connections when required",
                "DescriptionMarkdown": "Add self-diagnostics capability to YARP and implement throttling policies which can be applied if some thresholds have been exceeded.\r\n\r\nIndicators to watch for:\r\n- CPU load\r\n- Memory pressure\r\n- Available TCP ports\r\n- Average/mean/p95 client requests latency\r\n\r\nExamples of throttling policies:\r\n- Stop accepting new HTTP 1.1 requests by immediately returning 503\r\n- Stop accepting new active streams on HTTP/2 connections\r\n- Stop accepting new TCP connections",
                "Milestone": null,
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#51",
                "CreatedAt": "2020-04-15T17:41:30+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Proxy has cloud scale performance, and is benchmarked in the lab",
                "DescriptionMarkdown": "Ongoing effort to analyze perf of the proxy.\r\n\r\n- [ ] Add micro benchmarks #223 \r\n- [ ] Add more benchmark scenarios #222 \r\n- [ ] Poor performance and errors when proxying https #355 \r\n- [ ] Profile Memory #221\r\n- [ ] Do not flow the Connection header? #439",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Task",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": [
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#223",
                    "CreatedAt": "2020-06-02T19:17:26+00:00",
                    "CreatedBy": "halter73",
                    "IsClosed": false,
                    "Title": "Add microbenchmarks",
                    "DescriptionMarkdown": "We should add microbenchmarks for key methods like ProxyInvokerMiddleware.Invoke(), LoadBalancingMiddleware.Invoke(), LoadBalancer.PickDestination(), etc. using https://github.com/dotnet/BenchmarkDotNet.\r\n\r\nThis provides a benefit over end-to-end benchmarks since microbenchmarks can more reliably measure smaller performance gains or losses in the components they measure which can add up over time.",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [
                      "halter73"
                    ],
                    "Labels": [
                      {
                        "Name": "Type: Task",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#222",
                    "CreatedAt": "2020-06-02T19:08:52+00:00",
                    "CreatedBy": "halter73",
                    "IsClosed": false,
                    "Title": "Add more benchmark scenarios",
                    "DescriptionMarkdown": "This is a follow up to https://github.com/microsoft/reverse-proxy/issues/40.\r\n\r\nThere are countless proxy scenarios and variations that can be benchmarked, but currently our proxy benchmarks only capture the following scenario:\r\n\r\n- Using unencrypted connections and making HTTP/1.1 GET requests to both the proxy and backend\r\n\r\nThis scenario varies by response body size: 10B, 100B, 1KB, 10KB, 100KB plaintext responses are currently tested. Limiting response body sizes to just 32KB and 255KB should reduce the total number of scenarios allowing us to add more interesting scenarios without creating information overload.\r\n\r\nThe next proxy benchmark scenarios we plan to add are:\r\n\r\n- Using TLS connections and making HTTP/2 GET requests to both the proxy and backend\r\n- Using TLS connections and making HTTP/1.1 GET requests to both the proxy and backend\r\n- Using unencrypted connections and making HTTP/1.1 POST requests to both the proxy and backend\r\n\r\nAfter those scenarios are completed. Here are even more scenarios we can consider.\r\n\r\n- Logging completely disabled\r\n- Requests with bodies\r\n- Variations on headers\r\n  - Large request headers\r\n  - Large response headers\r\n  - Request/Response header transformation\r\n- gRPC through the rpoxy\r\n  - gRPC streaming\r\n\r\n",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [
                      "halter73"
                    ],
                    "Labels": [
                      {
                        "Name": "Type: Task",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#355",
                    "CreatedAt": "2020-07-31T14:37:17+00:00",
                    "CreatedBy": "jmezach",
                    "IsClosed": false,
                    "Title": "Poor performance and errors when proxying to https",
                    "DescriptionMarkdown": "### Describe the bug\r\nI\u0027ve been running some benchmarks on my local machine for my API gateway that is currently using Ocelot, but that I\u0027m in the process of migrating to YARP. To perform the benchmarks I\u0027ve been using [Crank](https://github.com/dotnet/crank) from the .NET team, which is awesome by the way.\r\n\r\nWhat I\u0027ve seen so far is that if the downstream service I\u0027m proxying to is using HTTP, YARP is much faster than Ocelot. For example, here are the results for my current gateway using Ocelot:\r\n\r\n\u0060\u0060\u0060\r\nFirst Request (ms):   850\r\nRequests:             18,068\r\nBad responses:        0\r\nMean latency (us):    214,006\r\nMax latency (us):     499,452\r\nRequests/sec:         1,181\r\nRequests/sec (max):   7,272\r\n\u0060\u0060\u0060\r\n\r\nWhile these are the results for a similar scenario, but using YARP:\r\n\r\n\u0060\u0060\u0060\r\nFirst Request (ms):   1,205\r\nRequests:             48,984\r\nBad responses:        0\r\nMean latency (us):    78,480\r\nMax latency (us):     2,128,675\r\nRequests/sec:         3,258\r\nRequests/sec (max):   13,420\r\n\u0060\u0060\u0060\r\n\r\nThose are not too shabby, although the max latency for YARP is interesting. Do note that my Ocelot based gateway is running on .NET Core 3.1, while my YARP gateway is running on .NET 5 Preview 7.\r\n\r\nHowever, when I ran the same benchmark with the gateway proxying to the downstream service using HTTPS, I\u0027m seeing very different results:\r\n\r\n**Ocelot:**\r\n\u0060\u0060\u0060\r\nFirst Request (ms):   1,088\r\nRequests:             12,819\r\nBad responses:        0\r\nMean latency (us):    301,467\r\nMax latency (us):     3,571,386\r\nRequests/sec:         839\r\nRequests/sec (max):   7,944\r\n\u0060\u0060\u0060\r\n\r\n**YARP:**\r\n\u0060\u0060\u0060\r\nFirst Request (ms):   1,631\r\nRequests:             527\r\nBad responses:        515\r\nMean latency (us):    9,021,413\r\nMax latency (us):     10,132,335\r\nRequests/sec:         18\r\nRequests/sec (max):   6,587\r\n\u0060\u0060\u0060\r\n\r\nObviously the number of bad responses triggered me, so I\u0027ve looked into the logs to see if I can figure out what\u0027s going wrong. I see a lot of these exceptions:\r\n\r\n\u0060\u0060\u0060\r\n[04:31:02.965] System.OperationCanceledException: The operation was canceled.\r\n[04:31:02.965]    at System.Threading.CancellationToken.ThrowOperationCanceledException()\r\n[04:31:02.965]    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.ThrowException(SocketError error, CancellationToken cancellationToken)\r\n[04:31:02.965]    at System.Net.Sockets.Socket.AwaitableSocketAsyncEventArgs.GetResult(Int16 token)\r\n[04:31:02.965]    at System.Net.Security.SslStream.\u003CFillHandshakeBufferAsync\u003Eg__InternalFillHandshakeBufferAsync|180_0[TIOAdapter](TIOAdapter adap, ValueTask\u00601 task, Int32 minSize)\r\n[04:31:02.965]    at System.Net.Security.SslStream.ReceiveBlobAsync[TIOAdapter](TIOAdapter adapter)\r\n[04:31:02.965]    at System.Net.Security.SslStream.ForceAuthenticationAsync[TIOAdapter](TIOAdapter adapter, Boolean receiveFirst, Byte[] reAuthenticationData, Boolean isApm)\r\n[04:31:02.965]    at System.Net.Http.ConnectHelper.EstablishSslConnectionAsyncCore(Stream stream, SslClientAuthenticationOptions sslOptions, CancellationToken cancellationToken)\r\n[04:31:02.965]    at System.Net.Http.HttpConnectionPool.ConnectAsync(HttpRequestMessage request, Boolean allowHttp2, CancellationToken cancellationToken)\r\n[04:31:02.965]    at System.Net.Http.HttpConnectionPool.CreateHttp11ConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n[04:31:02.965]    at System.Net.Http.HttpConnectionPool.GetHttpConnectionAsync(HttpRequestMessage request, CancellationToken cancellationToken)\r\n[04:31:02.965]    at System.Net.Http.HttpConnectionPool.SendWithRetryAsync(HttpRequestMessage request, Boolean doRequestAuth, CancellationToken cancellationToken)\r\n[04:31:02.965]    at Microsoft.ReverseProxy.Service.Proxy.HttpProxy.NormalProxyAsync(HttpContext context, HttpRequestMessage upstreamRequest, Transforms transforms, HttpMessageInvoker httpClient, ProxyTelemetryContext proxyTelemetryContext, CancellationToken shortCancellation, CancellationToken longCancellation)\r\n[04:31:02.965]    at Microsoft.ReverseProxy.Telemetry.TextOperationLogger\u00601.ExecuteAsync(String operationName, Func\u00601 action)\r\n[04:31:02.965]    at Microsoft.ReverseProxy.Middleware.ProxyInvokerMiddleware.Invoke(HttpContext context)\r\n[04:31:02.965]    at Microsoft.AspNetCore.Routing.EndpointMiddleware.\u003CInvoke\u003Eg__AwaitRequestTask|6_0(Endpoint endpoint, Task requestTask, ILogger logger)\r\n[04:31:02.965]    at Microsoft.AspNetCore.Authorization.AuthorizationMiddleware.Invoke(HttpContext context)\r\n[04:31:02.965]    at Microsoft.AspNetCore.Diagnostics.DeveloperExceptionPageMiddleware.Invoke(HttpContext context)\r\n\u0060\u0060\u0060\r\n\r\nThat looks like it is somehow not able to complete the SSL handshake with the downstream service, but my Ocelot based gateway doesn\u0027t have that same problem and both are going to the exact same service. That service is running on ASP.NET Core 3.1 by the way.\r\n\r\n### To Reproduce\r\n\u003C!--\r\nWhat steps can we follow to reproduce the issue?\r\n\r\n\r\nGot Exceptions? Include both the message and the stack trace\r\n--\u003E\r\n\r\nSo far I\u0027ve followed the basic guide for setting up a reverse proxy with YARP. I\u0027m using the following configuration:\r\n\r\n\u0060\u0060\u0060json\r\n\u0022ReverseProxy\u0022: {\r\n  \u0022Routes\u0022: [\r\n    {\r\n        \u0022RouteId\u0022: \u0022realization\u0022,\r\n        \u0022ClusterId\u0022: \u0022EchoService\u0022,\r\n        \u0022Match\u0022: {\r\n          \u0022Methods\u0022: [ \u0022GET\u0022, \u0022POST\u0022 ],\r\n          \u0022Hosts\u0022: [ \u0022localhost\u0022 ],\r\n          \u0022Path\u0022: \u0022/realization/{*remainder}\u0022\r\n        },\r\n        \u0022Transforms\u0022: [\r\n            { \u0022PathSet\u0022: \u0022/api/values\u0022 }\r\n        ]\r\n     }\r\n  ],\r\n  \u0022Clusters\u0022: {\r\n    {\r\n      \u0022EchoService\u0022: {\r\n        \u0022LoadBalancing\u0022: {\r\n          \u0022Mode\u0022: \u0022Random\u0022\r\n        },\r\n        \u0022Destinations\u0022: {\r\n          \u0022backend_destination1\u0022: {\r\n            \u0022Address\u0022: \u0022https://localhost:5003/\u0022\r\n          }\r\n        }\r\n   }\r\n}\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nChanging \u0060backend_destination1\u0060\u0027s \u0060Address\u0060 to \u0060http://localhost:5002/\u0060 fixes the issue.\r\n\r\n### Further technical details\r\n\r\n- Include the version of the packages you are using: **1.0.0-preview.3**\r\n- The platform (Linux/macOS/Windows): macOS",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Triage: Info Needed",
                        "BackgroundColor": "db64cb"
                      },
                      {
                        "Name": "Type: Bug",
                        "BackgroundColor": "0075ca"
                      },
                      {
                        "Name": "tenet-performance",
                        "BackgroundColor": "c14376"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#221",
                    "CreatedAt": "2020-06-02T18:47:17+00:00",
                    "CreatedBy": "halter73",
                    "IsClosed": false,
                    "Title": "Capture memory profile and eliminate unnecessary allocations",
                    "DescriptionMarkdown": "We should look at our primary scenarios, perhaps those defined for our TE-style benchmarks https://github.com/microsoft/reverse-proxy/issues/40, and capture a memory profile so we can eliminate unnecessary allocations and improve performance.",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [
                      "halter73"
                    ],
                    "Labels": [
                      {
                        "Name": "Type: Task",
                        "BackgroundColor": "0075ca"
                      },
                      {
                        "Name": "tenet-performance",
                        "BackgroundColor": "c14376"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#439",
                    "CreatedAt": "2020-09-24T22:27:46+00:00",
                    "CreatedBy": "Tratcher",
                    "IsClosed": false,
                    "Title": "Do not flow the Connection header?",
                    "DescriptionMarkdown": "https://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html#sec14.10\r\n\r\nThe Connection header is per hop and shouldn\u0027t be forwarded through a proxy. Note most of the spec concerns here apply to traditional forward proxies, but they might still be useful for a reverse proxy. E.g. Forwarding a \u0060Connection: close\u0060 header would allow the client to terminate the proxy\u0027s connection to the destination and negatively impact performance.\r\n\r\nNote for WebSockets we do need to forward the \u0060Connection: Upgrade\u0060 header, so we can\u0027t ban Connection outright.",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Type: Bug",
                        "BackgroundColor": "0075ca"
                      },
                      {
                        "Name": "tenet-performance",
                        "BackgroundColor": "c14376"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                }
              ]
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#484",
                "CreatedAt": "2020-10-21T20:58:26+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Proxy has Documentation",
                "DescriptionMarkdown": "This is a collective tracking of what is needed for documentation.\r\n\r\n- [ ]  How to customize YARP with pipleine modules #452, #114 \r\n- [ ] Authentication #416 \r\n- [ ] Configuring https #305 \r\n- [ ] configuration #183",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": [
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#452",
                    "CreatedAt": "2020-10-02T21:12:50+00:00",
                    "CreatedBy": "samsp-msft",
                    "IsClosed": false,
                    "Title": "Sample/Doc for pipeline module(s)",
                    "DescriptionMarkdown": "Most of the questions we get for \u0022how do I?\u0022 with the proxy can be solved with a custom middleware component. Although we have a samples folder - that is more of a scratch pad for the teams internal experiments - it is not documentation for what you can do and how you should do it as a middleware component. For example, can you create new destinations on the fly, can you lookup the destinations for a backend cluster and swap those in.\r\n\r\nThis should cover:\r\n\r\n* What properties existing pipeline stages operate on, and write out -\u003E so that you know where to insert your module\r\n* Reading from config\r\n* Modifying destinations for a request\r\n* Reading and modifying headers before the request is sent to destination\r\n* Reading and modifying headers before the response is sent to the client\r\n\r\n ",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Deployment cookbook",
                        "BackgroundColor": "e5da04"
                      },
                      {
                        "Name": "Type: Documentation",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#416",
                    "CreatedAt": "2020-09-14T19:04:15+00:00",
                    "CreatedBy": "crismsx",
                    "IsClosed": false,
                    "Title": "Documentation for swapping authentication types",
                    "DescriptionMarkdown": "A common scenario I\u0027m running into is to proxy a request for the sole reason of swapping the authentication token. \r\n\r\nIn particular, the use case involves the swapping of 2 OAuth2 tokens. The client has access to one IdentityServer and the resource server to a different IdentityServer. The proxy in between is the only component that has access to both IdentityServers and is able to swap the access tokens. The swap should work only for specific (configured) routes.\r\n\r\nConsider adding documentation that covers this authentication scenario.\r\n\r\n\r\n\r\n",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Deployment cookbook",
                        "BackgroundColor": "e5da04"
                      },
                      {
                        "Name": "Type: Documentation",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#305",
                    "CreatedAt": "2020-07-07T05:05:45+00:00",
                    "CreatedBy": "Tratcher",
                    "IsClosed": false,
                    "Title": "Docs for HTTPS scenarios",
                    "DescriptionMarkdown": "I\u0027m aggregating some notes here from a variety of issues, questions, discussions, etc. around the HTTPS/TLS capabilities of YARP. These should eventually be written up into a doc.\r\n\r\nGeneral:\r\n- Inbound and outbound TLS are independent.\r\n- TLS offloading = inbound HTTPS and outbound HTTP\r\n- No tunneling support\r\n\r\nInbound\r\n- server specific, link to docs for each, summarize capabilities, more details for kestrel as it has more extensibility\r\n- SNI\r\n- hot cert swapping (via SNI callback)\r\n- TLS versions\r\n- perfect score TLS config\r\n- let\u0027s encrypt\r\n- log/filter protocols after handshake\r\n- advanced protocol filters before handshake\r\n\r\nOutbound\r\n- HTTPS enabled by specifying it in the destination server address\r\n- uses the destination address host name by default. You\u0027ll get a TLS error if it\u0027s expecting the original host\r\n- There\u0027s a transform rule to use the original host, or header transform to use an arbitrary host.\r\n- needs valid certs\r\n- customize HttpClient settings (not yet, https://github.com/microsoft/reverse-proxy/issues/137)",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Deployment cookbook",
                        "BackgroundColor": "e5da04"
                      },
                      {
                        "Name": "Type: Documentation",
                        "BackgroundColor": "0075ca"
                      },
                      {
                        "Name": "Type: Idea",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "microsoft/reverse-proxy#183",
                    "CreatedAt": "2020-05-22T00:19:07+00:00",
                    "CreatedBy": "Tratcher",
                    "IsClosed": false,
                    "Title": "Doc server configurations",
                    "DescriptionMarkdown": "Doc that YARP is supported on all AspNetCore servers. Link to the setup docs for each server. All of these servers provide SSL termination.\n\nHighlight advanced scenario we plan to support though kestrel like early connection interception.\n\nhttps://twitter.com/demisbellot/status/1263606633239904257?s=19",
                    "Milestone": "YARP 1.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Deployment cookbook",
                        "BackgroundColor": "e5da04"
                      },
                      {
                        "Name": "Type: Documentation",
                        "BackgroundColor": "0075ca"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": []
                }
              ]
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#114",
                "CreatedAt": "2020-04-27T17:05:51+00:00",
                "CreatedBy": "ryudice",
                "IsClosed": false,
                "Title": "Proxy can be customized with middleware to enable advanced scenarios",
                "DescriptionMarkdown": "### What should we add or change to make your life better?\r\nFrom looking at the source code I can see that you can add custom middlewares to the reverse proxy pipeline but I dont see any documentation outlining how to do it.\r\n### Why is this important to you?\r\nI think many of the people looking at the project is because they need to do some customization at the pipeline level and they want to avoid having to do it in another language like Lua in the case of Kong. Having this documentation would be very useful.",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Documentation",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#159",
                "CreatedAt": "2020-05-12T23:28:55+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": true,
                "Title": "Cross target .NET 5.0 and 3.1",
                "DescriptionMarkdown": "Multiple partners have said that they will be able to adopt YARP sooner if we provide a netcoreapp3.1 target. We can cross target the package and light up new functionality. We\u0027ll want to have a doc tracking things that won\u0027t work on 3.1.",
                "Milestone": "1.0.0-preview1",
                "Assignees": [
                  "Tratcher"
                ],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#290",
                "CreatedAt": "2020-07-02T16:37:42+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Implement back pressure in kestrel for incoming connections",
                "DescriptionMarkdown": "https://github.com/dotnet/aspnetcore/issues/13295",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "ASP.NET Schedule",
                    "BackgroundColor": "db7fc7"
                  },
                  {
                    "Name": "Type: Tracking",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#143",
                "CreatedAt": "2020-05-07T20:38:35+00:00",
                "CreatedBy": "karelz",
                "IsClosed": true,
                "Title": "Ship Preview1 nuget package",
                "DescriptionMarkdown": "Ship the nuget package\r\nCreate steps how-to - learn from @anurse",
                "Milestone": "1.0.0-preview1",
                "Assignees": [
                  "anurse",
                  "karelz"
                ],
                "Labels": [],
                "Kind": 3,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#77",
                "CreatedAt": "2020-04-21T18:05:04+00:00",
                "CreatedBy": "anurse",
                "IsClosed": false,
                "Title": "Proxy is supplied as a project template for dotnet new",
                "DescriptionMarkdown": "We believe one delivery mechanism for the proxy (perhaps the main one) is a \u0060dotnet new\u0060 template. We should have what we need to create one, so let\u2019s add it to this repo and start producing it in our builds.",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Enhancement",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#261",
                "CreatedAt": "2020-06-23T18:34:23+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Proxy is supplied as a pre-built exe with core functionality available via configuration",
                "DescriptionMarkdown": "The original issue #247 got hijacked as a request for docker, so forking this as an issue for creating an exe.\r\n\r\n\u003E We\u0027ve proposed shipping YARP in three formats:\r\n\u003E \r\n\u003E * A library - https://www.nuget.org/packages/Microsoft.ReverseProxy/\r\n\u003E * A template - #77\r\n\u003E * A pre-built application exe (this issue)\r\n\u003E \r\n\u003E The pre-built app should:\r\n\u003E \r\n\u003E * Read from a config file\r\n\u003E * Cover basic scenarios\r\n\u003E * Support a variety of platforms\r\n\u003E \r\n\u003E # Scenarios\r\n\u003E * Config based routes, clusters, \u0026 backends\r\n\u003E * Remote route config? E.g. load from a database, service fabric, k8?\r\n\u003E * Dashboards?  #123\r\n\u003E * Health checks for the proxy itself.\r\n\u003E * Static files? #187\r\n\u003E * Auth?\r\n\u003E * Multi-instance?\r\n\u003E   \r\n\u003E   * Data protection (Session Affinity)\r\n\u003E * Single-file exe with linking: #7\r\n\u003E * Config UI? #184\r\n\u003E \r\n\u003E # Config\r\n\u003E The library already supports loading routes from a config file. However, an app will need to expose additional config for the scenarios described above.\r\n\u003E \r\n\u003E # Platforms\r\n\u003E * Windows, Mac, Linux\r\n\u003E * Builds for both runtime dependent and standalone (servicing?)\r\n\u003E \r\n\u003E # Acquisition\r\n\u003E * Microsoft download center?",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "microsoft/reverse-proxy#247",
                "CreatedAt": "2020-06-16T19:13:22+00:00",
                "CreatedBy": "Tratcher",
                "IsClosed": false,
                "Title": "Proxy is supplied as a pre-built docker image",
                "DescriptionMarkdown": "We\u0027ve proposed shipping YARP in three formats:\r\n- A library - https://www.nuget.org/packages/Microsoft.ReverseProxy/\r\n- A template - https://github.com/microsoft/reverse-proxy/issues/77\r\n- A pre-built application exe #261\r\n- A docker image (this issue)\r\n\r\nThe pre-built app should:\r\n- Read from a config file\r\n- Cover basic scenarios\r\n- Support a variety of platforms\r\n\r\n# Scenarios\r\n- Config based routes, clusters, \u0026 backends\r\n- Remote route config? E.g. load from a database, service fabric, k8?\r\n- Dashboards?  https://github.com/microsoft/reverse-proxy/issues/123\r\n- Health checks for the proxy itself.\r\n- Static files? https://github.com/microsoft/reverse-proxy/issues/187\r\n- Auth?\r\n- Multi-instance?\r\n  - Data protection (Session Affinity)\r\n- Single-file exe with linking: https://github.com/microsoft/reverse-proxy/issues/7\r\n- Config UI? https://github.com/microsoft/reverse-proxy/issues/184\r\n\r\n# Config\r\nThe library already supports loading routes from a config file. However, an app will need to expose additional config for the scenarios described above.\r\n\r\n# Platforms\r\n- Windows, Mac, Linux\r\n- Builds for both runtime dependent and standalone (servicing?)\r\n\r\n# Acquisition\r\n- Microsoft download center?",
                "Milestone": "YARP 1.0.0",
                "Assignees": [],
                "Labels": [
                  {
                    "Name": "Type: Idea",
                    "BackgroundColor": "0075ca"
                  },
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": null
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/core#5408",
            "CreatedAt": "2020-10-22T20:38:45+00:00",
            "CreatedBy": "glennc",
            "IsClosed": false,
            "Title": "Provide an API experience that scales down well and is easier to learn",
            "DescriptionMarkdown": "Title: Provide an API experience that scales down well and is easier to learn\r\n\r\nASP.NET Core does not provide a smooth way to scale an API down. We provide MVC which has lots of features, but also lots of concepts to learn. We want to provide experiences for building APIs that can start simpler, with a clearer getting started experience, and can smoothly progress to controllers if desired.\r\n\r\nOur results from [Feather](https://github.com/featherhttp/framework) studies and some of our Cloud Native user studies have shown that developers new to .NET react well to more simplified API experiences, and we think that also dovetails well with the Cloud Native theme as frequently the complexity that Controllers are designed to allow you to manage are instead managed across process/project boundaries.\r\n\r\nThis epic will allow us to enhance our API offering by extracting features currently only available in MVC, allowing them to be used outside of MVC. The intent is to allow these extracted features to be used in a functions/lambda model as well as a controller model of APIs. We started this work with Endpoint routing, but today that experience lacks a lot of desirable features, like model binding and validation, and doesn\u0027t have a clear story for better code organization once you grow beyond what fits well in an inline lambda.\r\n\r\n**Initial Principles/Goals:**\r\n\r\n1. Improve the endpoint routing APIs to the point that we could make it the default API story in ASP.NET Core\r\n   1. Allow using features that are currently only available in MVC that make sense (model binding is the big one)\r\n   1. Provide a smooth migration experience from inline lambda, to functions, to classes or controllers as code organization for an API\r\n1. Don\u0027t create APIs for small apps. The idea is not to create a less capable API experience. Instead we want to allow simple things to be simple. Allowing seamless mixing of controllers and non-controllers, sharing of all the concepts and infrastructure that make sense.\r\n1. Ensure APIs are good for our single-file/trimming/AOT experiences. Ensuring that a small API also produces a small binary output when built.\r\n\r\n",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/core#5366",
        "CreatedAt": "2020-10-15T22:29:35+00:00",
        "CreatedBy": "bradygaster",
        "IsClosed": false,
        "Title": "Meeting Developer Expectations",
        "DescriptionMarkdown": ".NET 5 introduced more incremental improvements for applications to realize faster startup times and smaller exe sizes using single file and app trimming. As we look ahead on how we continue to make .NET a compelling platform for developers to build their modern apps on, we will continue to evolve the platform by building on top of what .NET 5 has brought to the ecosystem.\r\n\r\nEpics under this theme:\r\n\r\n- [ ] Epic: Make .NET a good choice for environments that require single file and AOT https://github.com/dotnet/runtime/issues/43538\r\n- [ ] Epic: Deliver on the remaining .NET Core customer promises from .NET 5 #5395\r\n- [ ] Epic: Democratize Machine Learning for .NET developer https://github.com/dotnet/machinelearning-modelbuilder/issues/1053\r\n- [ ] Enable APIs to be discoverable and integrated in the Power Platform\r\n  - [ ] Epic: Enabling Power Platform Scenarios with HTTP APIs #5367\r\n  - [ ] Epic: HTTP API Testing Tools #5368\r\n- [ ] Epic: Make sure .NET is continuously improved #5410",
        "Milestone": null,
        "Assignees": [
          "cathysull"
        ],
        "Labels": [
          {
            "Name": "Theme",
            "BackgroundColor": "800080"
          }
        ],
        "Kind": 0,
        "ProjectStatus": {
          "ProjectName": ".NET 6.0",
          "Column": "Proposed"
        }
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#43538",
            "CreatedAt": "2020-10-16T21:25:31+00:00",
            "CreatedBy": "samsp-msft",
            "IsClosed": false,
            "Title": "Make .NET a good choice for environments that require single file and AOT",
            "DescriptionMarkdown": "# Why\r\n.NET 5 introduced more incremental improvements for applications to realize faster startup times and smaller exe sizes using single file and app trimming. As we look ahead on how we continue to make .NET a compelling platform for developers to build their modern apps on, we need to continue to evolve the platform by building on top of what .NET 5 has brought to the ecosystem. AOT in particular, is an area where we need to start to make more investments, which will likely span across several upcoming releases of .NET. Many developers want a specific solution when they refer to \u201CAOT.\u201D They want a solution that has the following characteristics: extremely fast startup, no IL present (for size and obfuscation reasons), a JIT is (at most) optional, and binary size is as small as it can be. We use the term \u201Cnative AOT\u201D to describe that point on the AOT spectrum. The single file solution we have in .NET 5.0 doesn\u2019t satisfy this definition of AOT. It\u2019s a big step forward, but it isn\u2019t \u201Cnative AOT.\u201D\r\n\r\nA recent [Native AOT community survey](https://github.com/dotnet/runtime/issues/41522), showed us that there\u2019s more of a need to officially support native AOT in .NET. 52% of our survey respondents (n=1,344) told us that they would like to write more projects in .NET (but can\u2019t) or have written .NET projects in a different environment (Rust and Go) because of missing native AOT options.\r\n\r\n# Summary\r\nThis objective describes the continued investment and evolution in the features and integration of single file, trimming, and source generators (to name just a few). Many of these areas are complimentary to each other such that a characteristic of source generators for example is that it can help remove major barriers to linker-based and AOT (ahead-of-time) compilation optimizations.\r\n\r\nMany of these areas will require ecosystem and library authors to participate in as well (i.e. trimming) and we will need to build specific tooling to enable these features to be utilized in libraries and will need an outreach program for them as well. We\u2019ve also identified that many of the top NuGet packages people make heavy use of reflection to discover types at runtime. Incorporating these packages is essential for most .NET apps, so the \u201Clinkability\u201D and ability for your code to make use of AOT compiler optimizations is greatly affected. We\u2019re looking forward to working with our wonderful OSS community to see how these packages could use source generators and improve the overall .NET ecosystem.\r\n\r\n# User Stories\r\n\r\n- [ ] Start the journey to enable Native AOT in runtimelabs https://github.com/dotnet/runtimelab/issues/248\r\n- [ ] Developers can confidently generate single file apps that work for the supported target platforms #43540\r\n- [ ] Annotate more .NET libraries (trimming) and guidance for library authors #43543\r\n- [ ] Expand .NET WebAssembly Capabilities\r\n- [ ] Support assembly load context throughout the product #43544\r\n- [ ] Source generators continue to assist with runtime and framework features #43545",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              },
              {
                "Name": "area-Meta",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "untriaged",
                "BackgroundColor": "fbca04"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/runtimelab#248",
                "CreatedAt": "2020-10-19T17:54:42+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Start the journey to enable Native AOT in runtimelabs",
                "DescriptionMarkdown": "We have seen a surge of interest in statically linked binaries with minimal dependencies in recent years. This is a reversal of a multi-decade trend to deliver dependencies as shared libraries. The benefits to deployment and the ability to optimize a single app outweigh the benefits of sharing for certain types of workloads. The gain is most significant for workloads with a high number of deployed instances: cloud infrastructure, hyper-scale services, popular apps or games. The number of apps of this type is relatively small, but they are highly visible, impactful, and often cost a lot of money to operate (savings can be meaningful).\r\n\r\nEmerging programming environments (e.g. Go, Rust) tend to be designed for this form factor. Established programming environments are catching up on this trend to be relevant for this highly visible segment, for example Java Graal, Dart, Kotlin/Native.\r\n\r\nVarious implementations of .NET (Xamarin, Unity, .NET Native) have demonstrated that .NET is well suited to native AOT in terms of fundamentals, however, there are tools experience and ecosystem challenges that currently prevent .NET from being a great general purpose solution. We intend to start addressing these issues with this project. It is very likely that the first set of improvements will have rough edges that may prevent adoption for some developers. We will use feedback to determine which experience issues to prioritize. We are also not comitting to any particular end point for this project, at this time.\r\n\r\nThis high level section sets our intention to invest in native AOT scenarios and more definition from the teams will be needed to define our phased approach over the next few .NET releases.\r\n\r\n# Work Items\r\n\r\n- [ ] Developer experience\r\n  - [ ] Developers have a way to tell IDE that they are targeting Native AOT \r\n  - [ ] Developers should be shown errors/warnings for AOT incompatible code during development\r\n  - [ ] Inner loop experience for AOT projects\r\n- [ ] Framework annotations - shared with Trimming\r\n  - [ ] Additional annotations for Native AOT specific problem areas\r\n- [ ] Blazor Experience\r\n",
                "Milestone": null,
                "Assignees": [
                  "richlander",
                  "jkotas",
                  "jeffschwMSFT",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-NativeAOT",
                    "BackgroundColor": "d4c5f9"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43540",
                "CreatedAt": "2020-10-16T21:41:41+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Developers can confidently generate single file apps that work for the supported target platforms",
                "DescriptionMarkdown": "Single file apps are a journey, we progressed from a self-extract approach in 3.x to a superhost in 5.0, but there is more to be done to complete the story. Single file apps need to work for every .NET workload and app framework where the target platform allows for it (to reduce developer perceived complexity of seeing several output files vs one output file), including:\r\n* Winforms\r\n* WPF\r\n* MAUI\r\n* ASP.NET including MVC, Razor Pages, Server-side Blazor, WebAPI, gRPC etc.\r\n\r\nGoals:\r\n* Predictability: Developers should be aware of what will and won\u0027t work in a single file experience\r\n   * Ensuring that referenced libraries are also not going to produce issues\r\n* Completeness for specific workloads\r\n\r\n# Work Items\r\n- [ ] Flush out testing for each of the scenarios\r\n- [ ] Extend superhost beyond Linux #43071\r\n  - [ ] Create superhost for Windows\r\n  - [ ] Create superhost for MacOS\r\n- [ ] Enable debugging of superhost apps with Visual Studio\r\n- [ ] Tooling \u0026 Experience\r\n  - [ ] Add analyzers for common issues that occur with single file apps, such as file path resolution from the assembly\r\n  - [ ] Integrate the analyzers into Visual Studio\r\n  - [ ] Add attribute to decorate places which are incompatible with single file\r\n",
                "Milestone": null,
                "Assignees": [
                  "agocke",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": [
                {
                  "Issue": {
                    "Id": "dotnet/runtime#43071",
                    "CreatedAt": "2020-10-06T01:17:26+00:00",
                    "CreatedBy": "agocke",
                    "IsClosed": false,
                    "Title": "Superhost for Windows \u0026 Mac",
                    "DescriptionMarkdown": "All native runtime libraries should be statically linked into a single file host for Windows \u0026 Mac.\r\n\r\n- [X] Make \u0060clrjit\u0060 and \u0060coreclr\u0060 friendlier to static linking on multiple platforms. #43423\r\n- [ ] Statically link \u0060clrjit\u0060 and \u0060coreclr\u0060 into singlefile host #43072 \r\n- [ ] Link native libraries in a way that is multiplatform friendly. #41299\r\n- [ ] Statically link native libraries on Windows, OSX and other platforms that we test/support. #43699\r\n- [ ] Move build of hosts to clr partition. #43700\r\n (not a requirement but will make things simpler going forward, hard to do though before we do the above)\r\n- [ ] Debugging support",
                    "Milestone": "6.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Team Epic",
                        "BackgroundColor": "754fff"
                      },
                      {
                        "Name": "area-Single-File",
                        "BackgroundColor": "d4c5f9"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": [
                    {
                      "Issue": {
                        "Id": "dotnet/runtime#43423",
                        "CreatedAt": "2020-10-14T21:51:13+00:00",
                        "CreatedBy": "VSadov",
                        "IsClosed": true,
                        "Title": "Reducing DllMain responsibilities, so that singlefile would not need it",
                        "DescriptionMarkdown": "- Removed CoreDllMain.\r\nIt just initializes CRT and GS cookie in the same way it would happen by itself.  \r\nComments imply that this was needed because of certain static constructors. Looks like nothing requires this any more.\r\n\r\n- Switched thread detachment handling in EE to be off a \u0060thread_local\u0060 object destructor \r\nThis is a cross-platform way that works regardless of .dll or .exe scenario and thus preferable.\r\n\r\n- Refactor DLL_PROCESS_ATTACH so it would do only Dll-specific work (saving module handles)\r\nOther initialization was moved to \u0060EEStartupHelper\u0060 where it runs regardless of platform or whether it is .dll/.exe scenario\r\n\r\ncontributes towards:#43072",
                        "Milestone": null,
                        "Assignees": [],
                        "Labels": [
                          {
                            "Name": "area-Infrastructure-coreclr",
                            "BackgroundColor": "d4c5f9"
                          },
                          {
                            "Name": "auto-merge",
                            "BackgroundColor": "159818"
                          }
                        ],
                        "Kind": 3,
                        "ProjectStatus": null
                      },
                      "Children": []
                    },
                    {
                      "Issue": {
                        "Id": "dotnet/runtime#43072",
                        "CreatedAt": "2020-10-06T01:19:33+00:00",
                        "CreatedBy": "agocke",
                        "IsClosed": false,
                        "Title": "Link \u0060clrjit.dll\u0060 and \u0060coreclr.dll\u0060 into Windows/Mac host",
                        "DescriptionMarkdown": "Part of the process of getting a superhost on Windows\u002BMac",
                        "Milestone": "6.0.0",
                        "Assignees": [
                          "VSadov"
                        ],
                        "Labels": [
                          {
                            "Name": "area-Single-File",
                            "BackgroundColor": "d4c5f9"
                          }
                        ],
                        "Kind": 3,
                        "ProjectStatus": null
                      },
                      "Children": []
                    },
                    {
                      "Issue": {
                        "Id": "dotnet/runtime#41299",
                        "CreatedAt": "2020-08-24T22:47:11+00:00",
                        "CreatedBy": "VSadov",
                        "IsClosed": false,
                        "Title": "Improving and unifying handling of native Libraries code in embedded/singlefile scenarios",
                        "DescriptionMarkdown": "### Improving handling of native Libraries code in embedded/singlefile scenarios\r\n\r\nFor reasons that vary .Net libraries rely on nontrivial amount of native code. The native code is factored into a few well-known native dynamic-link libraries (.dll, .so, etc). As an example we have 4 libraries like this on Linux \u2013 \u0022libSystem.Native\u0022, \u0022libSystem.IO.Compression.Native\u0022, \u0022libSystem.Net.Security.Native\u0022, \u0022libSystem.Security.Cryptography.Native.OpenSsl\u0022. The number of libraries varies depending on platform.\r\n\r\nThis is a very simple model which has its own advantages. In particular there is no need for coreclr to have any special knowledge about these libraries.\r\n\r\nWhere this becomes inconvenient and fragile is when we want to package the native libraries differently - for example as a part of a single file host. To handle such requirement in the current implementation we produce static libraries for the native code and link that into coreclr/host. Since the native dlls are not longer around in this configuration, coreclr intercepts loading of these libraries and redirects to the containing host binary.\r\n\r\nThere is a number of issues:\r\n-\tSince coreclr and libraries are built separately, there is a possibility of a mismatch that could make them incompatible. (i.e. Debug vs. Release, different versions of libc, new/free operator mismatch ...)\r\n-\tIntercepting and redirecting the load happens in PAL layer. This is a problem when the same must be done on Windows.\r\n-\tAccessing the native methods via regular PInvokes requires that the native host re-exports the methods. That easily runs into platform or linker dependent behaviors regarding re-exporting of library functions from final executables.\r\n\r\n**Proposal:**\r\n\r\n-\tBuild native libraries as a part of CoreClr build.\r\nThe source files should still be located under Libraries partition, so that they can be shared in source form with Mono, for example.\r\n\r\n-\tThe \u201Cembedded\u201D case builds native libraries as a part of coreclr binary, thus bypassing the explicit lib files.\r\n\r\n-\tThe \u0022embedded\u0022 case recognizes well-known libraries as a special case of [QCall](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/corelib.md#calling-from-managed-to-native-code) and dispatches calls to the embedded implementations.\r\nExample: \u201ClibSystem.Native\u201D would normally be a name of the native library to load, but in \u201Cembedded\u201D case, the DLLEXPORT methods of libSystem.Native would be registered in the runtime similarly to QCall and \u201ClibSystem.Native\u201D would be recognized as  another QCall variety.\r\nQCall mechanism here allows us to \u201Cshim\u201D the location of native methods while not changing the managed code that calls them.\r\n\r\n-\tThe QCall registration table for the native calls will be automatically generated by scanning managed libraries.\r\n\r\n\r\n**Some unresolved details:**\r\n-\tIf managed callers are built after coreclr, we would need to reconcile how to do the QCall generation before coreclr builds.\r\n-\tShould the generation of QCall entries be a part of the build (producing a temporary source file) or a dev-time step (the file is explicitly generated and stored in Git).\r\n",
                        "Milestone": "6.0.0",
                        "Assignees": [
                          "VSadov"
                        ],
                        "Labels": [
                          {
                            "Name": "area-Infrastructure-coreclr",
                            "BackgroundColor": "d4c5f9"
                          }
                        ],
                        "Kind": 3,
                        "ProjectStatus": null
                      },
                      "Children": []
                    },
                    {
                      "Issue": {
                        "Id": "dotnet/runtime#43699",
                        "CreatedAt": "2020-10-21T18:25:55+00:00",
                        "CreatedBy": "VSadov",
                        "IsClosed": false,
                        "Title": "Statically link native libraries into singlfilehost on OSX and Windows",
                        "DescriptionMarkdown": "Currently we only support this on Linux.\r\nWe should extend the support to other supported/tested platforms.\r\n\r\nPrerequisite:#41299",
                        "Milestone": null,
                        "Assignees": [
                          "VSadov"
                        ],
                        "Labels": [
                          {
                            "Name": "area-Single-File",
                            "BackgroundColor": "d4c5f9"
                          }
                        ],
                        "Kind": 3,
                        "ProjectStatus": null
                      },
                      "Children": []
                    },
                    {
                      "Issue": {
                        "Id": "dotnet/runtime#43700",
                        "CreatedAt": "2020-10-21T18:35:04+00:00",
                        "CreatedBy": "VSadov",
                        "IsClosed": false,
                        "Title": "Hosts, in particular statically linked ones should be built in clr partition.",
                        "DescriptionMarkdown": "It is so happened that hosts are built in Installer.\r\n\r\nThis is not a problem for hosts that refer to native libraries dynamically. However when they need to statically link a number of components (coreclr, jit, libs), building them all in the same partition would simplify the logistics of the build and will make it easer to assure mutual compatibility of the parts.\r\n\r\nIt is hard to arrange this move while we pivk native libraries form libs partition, but once #43699 is implemented we should move static host to clr partition.\r\nThis will have to include:\r\n- moving/writing appropriate tests\r\n- most likely moving other hosts as well.",
                        "Milestone": null,
                        "Assignees": [],
                        "Labels": [
                          {
                            "Name": "area-Infrastructure-coreclr",
                            "BackgroundColor": "d4c5f9"
                          },
                          {
                            "Name": "untriaged",
                            "BackgroundColor": "fbca04"
                          }
                        ],
                        "Kind": 3,
                        "ProjectStatus": null
                      },
                      "Children": []
                    }
                  ]
                }
              ]
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43543",
                "CreatedAt": "2020-10-16T22:27:17+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": ".NET libraries are annotated to support trimming and we provide trimming guidance for library authors",
                "DescriptionMarkdown": "The trimming story is a journey where we are improving the capabilities release to release. With .NET 5, we have added the linker capability for trimming and started the annotation effort for the framework.\r\n\r\nFor an application to be correctly fully trimmable, we need to know all the places where dynamic code patterns such as reflection and reflection emit are used. Along with that we will provide annotations for the linker so that it knows how to find the required types so that they are not trimmed, provide a source generator equivalent, or if the functionality is inherently supportable in conjunction with trimming then to provide an error to the app developer.\r\n\r\n# Goals\r\n\r\n* Developers should have clarity on whether the application will be trimmable\r\n* Trimming should be possible for all mainline scenarios. Work with owners for each of the workloads to:\r\n  * define the mainline scenarios\r\n  * remove / mitigate issues in libraries for the mainline scenarios\r\n  * supply representative apps for validation\r\n* Linker should produce an error for every case where trimming will fail\r\n* Remove \u0022Preview\u0022 tag from the trimmer\r\n* Enable trimming for the following app types:\r\n  * Blazor\r\n  * Mobile apps\r\n  * ASP.NET\r\n  * Console apps\r\n  * Ideally an additional UI framework (e.g. WinForms or WPF)\r\n\r\n## Annotating the framework\r\n\r\nThis is a recursive initiative as each layer of the onion will potentially increase the surface area that can be trimmable and uncover additional APIs that need to be annotated. Decisions on which APIs should be focused on should be driven by usage stats (if we have them).\r\n\r\n## Annotating Libraries\r\n\r\nMost customer applications make use of libraries from third parties, commonly via NuGet, those also need to be annotated for trimming. We need to provide tooling to assist the developers in determining which of their APIs need to be annotated, and how to annotate them. The current library analysis uses hidden command line switches and needed to be augmented with custom tools created by the engineer currently working on annotations. The experience needs to be exposed in Visual Studio for both library consumers and library authors, with the ability to drill into the specifics of which API dependencies are causing issues.\r\n\r\nWe will need an outreach program for library authors, and probably have a way to filter out packages that are not trimmable from NuGet searches.\r\n\r\n## AOT annotations\r\n\r\nAll the annotations for trimming also assist in native AOT scenarios, as that has the same problem with not being able to determine dependencies when reflection is used. There are some additional limitations of native AOT that needs similar annotations to the attributes used for trimming. This should be added early so that the annotation exercise can consider both scenarios.\r\n\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "jeffschwMSFT",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43544",
                "CreatedAt": "2020-10-16T22:41:22+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Assembly load context is supported throughout .NET so developers can create scopes to support load/unload scenarios",
                "DescriptionMarkdown": "The assembly load context has been rather successful in solving a large set of customer problems. The most prominent one is the so called \u201Cplugin\u201D model where the application (host) loads other components to augment its functionality in some way. Such components are typically loaded into separate load contexts to avoid dependency collisions. Additionally, in some apps it\u2019s also desirable to be able to eventually unload such components either to free resources or to enable update of the component.\r\n\r\nProducing such applications has proven rather challenging in the current state of .NET Core because there are certain parts of the frameworks produces by us which are not compatible with multiple load contexts and/or unload ability.\r\nWe should drive the frameworks we own to fix these issues so that customer\u2019s code doesn\u2019t have to handle issues in frameworks they rely on. We should focus this effort on certain application types first to prioritize the work. We\u2019ve seen feedback on mainly ASP.NET and WPF applications. There might be overlap with the \u201Cfaster inner loop\u201D effort which would affect the prioritization as well.\r\n\r\nThe work can be split into two parts (and prioritized differently):\r\n* Given feature works correctly in presence of secondary load context \u2013 for example XamlParser has problems when used with assemblies in non-default load context. Similarly, ASP.NET\u2019s hosting code also doesn\u2019t work well in such a scenario. It might be possible to use static analyzers to detect some of the problems in this area.\r\n* Usage of a given feature doesn\u2019t prevent secondary load context from unloading correctly \u2013 for example TypeConverter holds onto all types which were used with it, and thus prevents unloading of such types. Static analyzers are probably not going to help in this area.\r\n\r\nIn both cases an important part of the work should be a general approach to testing \u2013 for example reuse existing test assets but run them under different conditions and providing customer guidance for first \u0026 third parties.\r\n\r\n# Work Items\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "vitek-karas",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43545",
                "CreatedAt": "2020-10-16T22:43:05+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Source generators are added to common libraries to enable apps using them to be trimmed.",
                "DescriptionMarkdown": "Source Generators are a new technology that was added to Roslyn in the .NET 5 timeframe, but we have not yet utilized them by creating generators to assist with runtime and framework features. We will work to define customer scenarios in more detail here with customer development.\r\n\r\nCode that uses runtime reflection and reflection.emit causes issues for Trimming and Native AOT. Source generators can be used to generate alternative code at build time that is static so can be used in conjunction with Trimming and AOT. Work on trimming ASP.NET apps has revealed where there are current limitations that can be solved by source generators.\r\n\r\nGenerators should be investigated/added for the following prioritized scenarios:\r\n\r\n- [ ] Trimming / Blazor / Native \u0026 Mono AOT \u2013 source generators can be used to convert code that does reflection.emit at runtime to source generators which will create code at build time rather than runtime. The generated code can then be analyzed by the illinker or native AOT enabling those scenarios.\r\n- [ ] Dependency Injection \u2013 is an important part of ASP.NET startup that could be replaceable with code generation at build time.\r\n- [ ] System.Text.Json serialization \u2013 code generators can work around the need for runtime reflection, and generate serializers for specific classes.\r\n- [ ] EventSource \u2013 event source uses reflection.emit to simplify creation of classes (manifests) for custom event sources \u2013 this can be changed to a build-time activity using source generators.\r\n- [ ] Regular Expressions \u2013 can be converted from using reflection.emit to build-time source generation, improving the startup time, making them fast in AOT, and possible in native AOT (Bing recently requested this \u2013 fast startup and fast regex).\r\n- [ ] Marshaling interop\r\n",
                "Milestone": null,
                "Assignees": [
                  "vitek-karas",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/core#5395",
            "CreatedAt": "2020-10-19T22:54:17+00:00",
            "CreatedBy": "cathysull",
            "IsClosed": false,
            "Title": "Deliver on the remaining .NET Core customer promises from .NET 5",
            "DescriptionMarkdown": "# Why\r\nIn .NET 5, many factors contributed to the fact that some features were developed in one area, and were not always supported across the entire stack or for all workloads. While many of these features are dialable, investing in finishing these promises will both help .NET developers to better adopt these platform features as we continue to evolve the .NET platform. \r\n\r\n# Summary\r\nFinishing the remaining promises from .NET 5 includes features that support cross-cutting platform enablement and ensure that we have a more complete end-to-end experience in the .NET platform. Many of these features will require more definition and scoping during .NET 6 planning beyond what is described in the User Stories below.\r\n\r\n# User Stories\r\n\r\n- [ ] Expand platform compat annotations to cover more configurations https://github.com/dotnet/runtime/issues/43616\r\n- [ ] Support more Analyzers \u0026 Code Fixers https://github.com/dotnet/runtime/issues/43617\r\n- [ ] Complete Nullable annotations for more of the framework https://github.com/dotnet/runtime/issues/43619\r\n- [ ] Expanding Linker tooling in VS\r\n- [ ] Finish System.Text.Json https://github.com/dotnet/runtime/issues/43620\r\n- [ ] Support HTTP3 in .NET 6 https://github.com/dotnet/runtime/issues/43546",
            "Milestone": null,
            "Assignees": [
              "cathysull"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/runtime#43616",
                "CreatedAt": "2020-10-19T23:05:25+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Expand platform compat annotations to cover more configurations",
                "DescriptionMarkdown": "In .NET 5 we started with annotations for features and APIs which are not universally available everywhere. We picked Windows and browsers as the initial targets for the experience. To make the experience complete we need to continue annotating remaining platforms we support (e.g. Linux-specific APIs that we expect to add). It goes beyond this as well.  It\u0027s certainly a \u0022last mile\u0022 experience, but for example today you won\u0027t get any warnings if you try to use MemoryMappedFile.CreateNew(string, ...) with a non-null string path, even though only a null string path is supported on Linux and macOS. The current platform analyzer doesn\u0027t account for such possibilities, with annotations done to just say \u0022if any usage of this API works on a platform, then consider it supported on that platform\u0022. We should look at what APIs fall into those partially-supported buckets and consider ways of improving the experience around them. This might be the next issue developers porting to .NET 5 get hung up on from a cross-platform perspective.\r\n\r\nWe also realized that the platform vertical is not the only limiting factor for APIs availability. There are others based primarily on workload limitations which should offer developers the same experience. We will expand compatibility annotations to cover configurations such as AOT, self-contained bundles and single file.\r\n\r\nThe projects which benefits most from the annotations are large scale solutions with many dependencies which are usually not available as a source code implementation. Exploring how to run the analysis on the final output would further improve the impact of tooling.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43617",
                "CreatedAt": "2020-10-19T23:09:52+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Support more Analyzers \u0026 Code Fixers",
                "DescriptionMarkdown": "In .NET 5, we shipped approximately 250 analyzers with the .NET SDK. Many of them already existed but were shipped out-of-band as NuGet packages. Now, .NET comes with an in-depth code analysis and code fixer experiences. This means developers don\u0027t have to purely rely on their choices based on reading code completion; .NET can help them pro-actively identify when their code has issues, right from the start. However, many of the code analyzers created don\u2019t come with code fixers yet. We will look at telemetry and customer feedback to prioritize (around a TBD set of principles) which code analyzers would most benefit from code fixers along with which are most popular and consider adding fixers for those. Also, there is a sizable backlog of code analyzers that didn\u0027t get included in .NET 5, which will need to prioritized and considered. Furthermore, our goal for .NET 6 is that new features in .NET 6 should come with analyzers.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43619",
                "CreatedAt": "2020-10-19T23:14:51+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Complete Nullable annotations for more of the framework",
                "DescriptionMarkdown": "In .NET 5, 94% of Microsoft.NetCore.App has been completed, which is the lowest layer in the shared framework and represents the set of APIs that are referenced by default by all applications types. We\u2019ll work to get this number to 100% and we intend to maintain 100% coverage into the future.\r\n\r\nWhat\u2019s still missing are the higher layers (WPF, WinForms, ASP.NET Core) as well as the out-of-band packages (such as EFCore and several out-of-band packages from dotnet/runtime, as well as assemblies that aren\u0027t in netcoreapp but are included with aspnetcoreapp). While each is likely to be too big to be completed in .NET 6, we will start planning and making inroads for the rest of the stack and decide if we are comfortable introducing new libraries which may have no nullable annotations (e.g. mobile SDKs/Forms for .NET 6). An MVP (minimum viable product) for this, we believe (and will test) that any new libraries are annotated, moving forward nullable reference types are just part of the language, and when you decide the data type of some method parameter or return value, it\u0027s just one of the things you need to factor in, just as we need to factor in new types added in the libraries, new language features around optional parameters or params arguments and such things.\r\n\r\n# Work Items\r\n\r\n- [ ] [Annotate remainder of .NET Core assemblies for nullable reference types](https://github.com/dotnet/runtime/issues/41720)\r\n- [ ] [Turn Nullable on for new projects](https://github.com/dotnet/sdk/issues/14272)",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": [
                {
                  "Issue": {
                    "Id": "dotnet/runtime#41720",
                    "CreatedAt": "2020-09-02T00:20:15+00:00",
                    "CreatedBy": "jeffhandley",
                    "IsClosed": false,
                    "Title": "Annotate remainder of .NET Core assemblies for nullable reference types",
                    "DescriptionMarkdown": "Across .NET Core 3.0 and .NET 5.0, we annotated 94% of the \u0060netcoreapp\u0060 assemblies for nullable reference types.  In .NET 6.0, we plan to annotate the remaining 6% of that surface area and continue through other assemblies built from the dotnet/runtime repo.\r\n\r\nThis issue represents the assemblies previously tracked in #2339 that did not get completed in .NET 5.0. Following the same practices we used in .NET 5.0, we will:\r\n\r\n* Submit individual PRs, one for each assembly. Each PR should include changes to both the src and the ref. Each PR should contain only changes related to the nullable annotations/attributes, no other changes.\r\n* PRs can be merged once the annotations have been appropriately reviewed in PR.\r\n\r\n*In .NET 5.0, as was tracked in #2339, we completed groups 1-8, most of group 9, all of group 10, and some items in groups 11 and 12*\r\n\r\n#### Group 9 ####\r\n- [ ] System.ComponentModel.TypeConverter (in progress by @safern)\r\n- [ ] Finish System.Data.Common (i.e. APIs depending on TypeConverter)\r\n\r\n#### Group 11 (not part of netcoreapp but reference netcoreapp) ####\r\n- [ ] System.DirectoryServices\r\n- [ ] System.Diagnostics.EventLog\r\n- [ ] System.DirectoryServices.Protocols\r\n- [ ] System.Security.Permissions\r\n- [ ] System.Windows.Extensions\r\n\r\n#### Group 12 (built from dotnet/runtime but not in netcoreapp and reference netstandard) ####\r\nWith netstandard not annotated, we will need to be cognizant of the fact that all dependencies will be viewed as oblivious:\r\n- [ ] System.CodeDom =\u003E netstandard\r\n- [ ] System.ComponentModel.Composition.Registration =\u003E netstandard, System.Reflection.Context\r\n- [ ] System.Composition.AttributedModel =\u003E netstandard\r\n- [ ] System.Composition.Convention =\u003E netstandard, System.Composition.AttributedModel\r\n- [ ] System.Composition.Hosting =\u003E netstandard, System.Composition.Runtime\r\n- [ ] System.Composition.Runtime =\u003E netstandard\r\n- [ ] System.Composition.TypedParts =\u003E netstandard, System.Composition.Runtime, System.Composition.AttributedModel, System.Composition.Hosting\r\n- [ ] System.Configuration.ConfigurationManager =\u003E netstandard, System.Security.Cryptography.ProtectedData\r\n- [ ] System.Diagnostics.PerformanceCounter =\u003E System.Configuration.ConfigurationManager\r\n- [ ] System.DirectoryServices.AccountManagement =\u003E System.Configuration.ConfigurationManager\r\n- [ ] System.IO.Ports =\u003E netstandard\r\n- [ ] System.Management =\u003E System.CodeDom\r\n- [ ] System.Runtime.Caching =\u003E netstandard, System.Configuration.ConfigurationManager\r\n- [ ] System.Security.Cryptography.Xml =\u003E netstandard\r\n- [ ] System.ServiceModel.Syndication =\u003E netstandard\r\n\r\n#### Lastly ####\r\n- [ ] Remove \u0060#nullable enable\u0060 from individual files after all dependent projects annotated  ",
                    "Milestone": "6.0.0",
                    "Assignees": [
                      "jeffhandley"
                    ],
                    "Labels": [
                      {
                        "Name": "area-Meta",
                        "BackgroundColor": "d4c5f9"
                      },
                      {
                        "Name": "tracking",
                        "BackgroundColor": "b60205"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": {
                      "ProjectName": ".NET 6.0",
                      "Column": "Proposed"
                    }
                  },
                  "Children": []
                },
                {
                  "Issue": {
                    "Id": "dotnet/sdk#14272",
                    "CreatedAt": "2020-10-21T18:44:09+00:00",
                    "CreatedBy": "terrajobst",
                    "IsClosed": false,
                    "Title": "Turn Nullable on for new projects",
                    "DescriptionMarkdown": "We want to set \u0060\u003CNullable\u003EEnabled\u003C/Nullable\u003E\u0060 for new projects.\r\n\r\nWe probably don\u0027t want to infer this as part of the TFM and instead make it part of the project template. Otherwise retargeting becomes a major hurdle.",
                    "Milestone": null,
                    "Assignees": [
                      "cartermp"
                    ],
                    "Labels": [],
                    "Kind": 3,
                    "ProjectStatus": {
                      "ProjectName": ".NET 6.0",
                      "Column": "Proposed"
                    }
                  },
                  "Children": []
                }
              ]
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43620",
                "CreatedAt": "2020-10-19T23:17:17+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Finish System.Text.Json",
                "DescriptionMarkdown": "There are about 200 open issues for JSON and community engagement continues to be high along with direct asks from authors like NSwag. There are still have some missing features that prevents System.Text.Json to be successful as the standard JSON stack for .NET. Two major areas of investment are beefing up the serialization support (~20 features) and providing a source generator for JSON serialization to make it friendly for trimming.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": "6.0.0",
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-System.Text.Json",
                    "BackgroundColor": "d4c5f9"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43546",
                "CreatedAt": "2020-10-16T23:36:49+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Support HTTP3 in .NET 6",
                "DescriptionMarkdown": "HTTP3 is the next major version of HTTP and the successor to HTTP2. It is in the final stages of standardization in the IETF. Some browsers (notably Chrome) already support draft versions of HTTP3. HTTP3 runs over QUIC, which replaces TCP as the underlying transport. QUIC is also in the final stages of standardization in the IETF. It provides secure, multiplexed streams over UDP. QUIC is a general-purpose, extensible transport protocol and we expect it to be used by other application protocols aside from HTTP3.\r\n\r\nFor .NET 6.0, we plan to deliver the following capabilities:\r\n- [ ] A set of public classes for using the QUIC protocol on either client or server. This is System.Net.Quic. It is the equivalent of System.Net.Sockets for the QUIC protocol.\r\n - [ ] HTTP3 client support in HttpClient/SocketsHttpHandler.\r\n- [ ] HTTP3 server support in Kestrel/ASP.NET.\r\n\r\nWe have already made some progress on this in .NET 5.0 and are delivering HTTP3 support in a \u201Cpreview\u201D, unsupported capacity. There is no public API for QUIC in .NET 5.0.\r\n\r\nWe intend to share as much HTTP3 code as is reasonably possible between the client and server implementation.",
                "Milestone": null,
                "Assignees": [
                  "geoffkizer",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "In progress"
                }
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/machinelearning-modelbuilder#1053",
            "CreatedAt": "2020-10-21T21:06:39+00:00",
            "CreatedBy": "briacht",
            "IsClosed": false,
            "Title": "Democratize Machine Learning for .NET developers",
            "DescriptionMarkdown": "# Why\r\n\r\n\r\n# Summary\r\n\r\n\r\n# User Stories",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/core#5367",
            "CreatedAt": "2020-10-15T22:53:09+00:00",
            "CreatedBy": "bradygaster",
            "IsClosed": false,
            "Title": "Enable Power Platform Scenarios with HTTP APIs",
            "DescriptionMarkdown": "Since November 2019, we\u2019ve done significant work to improve the overall end-to-end experience for developers who need to extend PowerApps (or any other Power Platform resource). The goals of this multi-organization partnership spanning DevDiv, Azure, and Power Platform, have been to enable the following application development scenario: \r\n\r\n1. A citizen developer needs to build a business app using PowerApps. \r\n2. The PowerApp needs to use existing application infrastructure, so the citizen dev works with a .NET developer who is either building or who has already built and deployed an existing HTTP API. \r\n3. The API developer creates a PowerApps Custom Connector to give the citizen developer a connection to the HTTP API. \r\n4. The citizen developer uses the connection to the HTTP API to build their PowerApp. \r\n5. The citizen developer makes the PowerApp available to users in their enterprise via Teams. \r\n\r\nSince the partnership began in November, we\u2019ve accomplished significant strides across all partner teams, and now ASP.NET Core Web API customers have a clear path to getting HTTP APIs published into Azure API Management, which makes them easy to ingest into PowerApps.  \r\n\r\nUser Stories under this Experience:",
            "Milestone": null,
            "Assignees": [
              "bradygaster"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/core#5368",
            "CreatedAt": "2020-10-15T23:02:48+00:00",
            "CreatedBy": "bradygaster",
            "IsClosed": false,
            "Title": "HTTP API Testing Tools",
            "DescriptionMarkdown": "As the investments we make into building out HTTP APIs for use in the Power Platform take shape, an interesting by-product is that we\u2019re hearing from more developers that they need a way to call their APIs from clients hosted somewhere else. Consider the following scenarios in which developers are building HTTP APIs for use by either Azure or Power Platform clients: \r\n\r\n1. A developer needs to create an Azure Function that, given an ID, gets an order from a database and sends an adaptive card to a Teams channel representing the products in the order. The Function will be called within a Logic App.  \r\n2. A citizen developer is building a mobile app to replace an internal supply chain implemented using an intranet site. The product database page will be replicated as an HTTP API that will be called from a PowerApp. \r\n\r\nIn both scenarios a developer needs to build a \u201Cclient\u201D for an API on which they\u2019re also developing. In the Logic App scenario, a developer needs to be able to debug an HTTP API running on localhost but call that HTTP API from a Logic App running in Azure. In the PowerApp scenario, a citizen dev using the PowerApps maker experience \u2013 a web-based IDE \u2013 will be building and testing a app in a web browser.  \r\n\r\nIn both scenarios, the \u201Cclient\u201D will need to call the API, and the API developer will need a way to receive those calls and to step through their code using the rich debugging tools present in the Visual Studio family of products. But in both scenarios, the \u201Cclient\u201D will need a tunnel to localhost, as both are running on the open internet.  \r\n\r\nDevelopers need an \u201CF5 to Localhost Tunnel\u201D experience to answer this problem. \r\nUser Stories under this Experience:",
            "Milestone": null,
            "Assignees": [
              "bradygaster"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/core#5410",
            "CreatedAt": "2020-10-22T22:38:24+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": false,
            "Title": "Make sure .NET is continuously improved",
            "DescriptionMarkdown": "### Summary\r\n\r\nWe\u0027ll use this epic to collect bottom-up improvements coming from the engineering team.\r\n\r\n### User Stories\r\n\r\nUser Stories under this Epic:\r\n\r\n- [ ] [Title of the linked User Story](hyperlink to the User Story issue).\r\n",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/core#5238",
        "CreatedAt": "2020-09-22T01:51:59+00:00",
        "CreatedBy": "jamshedd",
        "IsClosed": false,
        "Title": "Enterprise and LTS",
        "DescriptionMarkdown": ".NET 6.0 will be a Long-Term Support (LTS) release. We see many enterprises prefer our LTS releases over Current releases for their longer support (relative to Current releases), they pick an LTS version so they don\u2019t have to move forward every year. This is not very different from what we see with OS LTS versions \u2013 enterprise customers go from one LTS to the next and skip the in-between SAC releases. Since .NET 6.0 will be the successor to 3.1 LTS we expect customers presently using 3.1 LTS and wanting to target the next LTS will pick 6.0 LTS. We will support 3.1 through December 2022, so once .NET 6.0 ships, customers will have 1 year to plan for, rebuild and test their apps and complete their deployment. Customers that cannot migrate their apps to 6.0 in this timeframe will probably ask us to provide longer support.  \r\n\r\nIf customers can successfully complete their migration forward in this 1-year period everyone benefits. So, it is in everyone\u2019s interest that we do everything we can to enable customers to come forward to 6.0 as easily, smoothly and quickly as possible. \r\n\r\nEpics under this Theme:\r\n\r\n- [ ] [Enterprises have a first class experience acquiring and deploying .NET 6.0](https://github.com/dotnet/core/issues/5240).\r\n- [ ] [Enterprises get first-class support when using .NET 6.0 on Linux](https://github.com/dotnet/core/issues/5333).\r\n- [ ] [Path to migrate an app from Framework to .NET 6.0 is well understood and streamlined](https://github.com/dotnet/core/issues/5396)",
        "Milestone": null,
        "Assignees": [
          "jamshedd"
        ],
        "Labels": [
          {
            "Name": "Theme",
            "BackgroundColor": "800080"
          }
        ],
        "Kind": 0,
        "ProjectStatus": {
          "ProjectName": ".NET 6.0",
          "Column": "Proposed"
        }
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/core#5240",
            "CreatedAt": "2020-09-22T02:05:57+00:00",
            "CreatedBy": "jamshedd",
            "IsClosed": false,
            "Title": "Enterprises have a first class experience acquiring and deploying .NET 6.0",
            "DescriptionMarkdown": "User Stories under this Epic:\r\n\r\n- [ ] [As an IT Pro I have easy access to .NET Core installer release information and scripts in my air gapped environment so I can use this to determine which updates need to be deployed](https://github.com/dotnet/core/issues/5241).\r\n",
            "Milestone": null,
            "Assignees": [
              "jamshedd"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/core#5241",
                "CreatedAt": "2020-09-22T02:12:28+00:00",
                "CreatedBy": "jamshedd",
                "IsClosed": false,
                "Title": "As an IT Pro I have easy access to .NET Core installer release information and scripts in my air gapped environment so I can use this to determine which updates need to be deployed. ",
                "DescriptionMarkdown": "Multiple customers need a way to deploy their app along with the dependent Core runtime to private clouds. This is difficult for them today because the installers/bits are only available on the public CDN and public Azure blob storage. Also the tools, scripts and release metadata we offer today is designed to work with these public end points.  Each customer is working around this in a different way, for e.g. one customer is packaging our installer with their source build in order to piggy-back with the build to get it over to the air-gapped cloud. Another is copying over bits from our public blob storage to their private blob storage and maintains its own version of install scripts that go to the private blob. We have work to do here to make it easier for customers that need to use Core in air-gapped scenarios. \r\n\r\nA key question is which distributions types (zips, MSIs, debs, containers) are the most critical to participate in air-gapped flows. Also, Azure- air-gapped versus on-prem air-gapped. \r\n \r\nThis area needs further customer development.  ",
                "Milestone": null,
                "Assignees": [
                  "jamshedd"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "0e8a16"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/core#5333",
            "CreatedAt": "2020-10-12T02:20:11+00:00",
            "CreatedBy": "jamshedd",
            "IsClosed": false,
            "Title": "Enterprises get first-class support when using .NET 6.0 on Linux",
            "DescriptionMarkdown": "\r\nUser Stories under this Epic:\r\n\r\n- [ ] [Title of the linked User Story](hyperlink to the User Story issue).\r\n",
            "Milestone": null,
            "Assignees": [
              "jamshedd"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/core#5396",
            "CreatedAt": "2020-10-19T23:26:10+00:00",
            "CreatedBy": "cathysull",
            "IsClosed": false,
            "Title": "Path to migrate an app from Framework to .NET 6.0 is well understood and streamlined",
            "DescriptionMarkdown": "\r\n# User Stories\r\n\r\n- [ ] TBD",
            "Milestone": null,
            "Assignees": [
              "cathysull"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "c6415a"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#41478",
        "CreatedAt": "2020-08-27T21:54:53+00:00",
        "CreatedBy": "HongGit",
        "IsClosed": true,
        "Title": "WCF Team Issues",
        "DescriptionMarkdown": "Group of issues include the following areas:\n- System.Serialization\n- System.Runtime.Caching\n- System.Syndication\n- System.Distribution",
        "Milestone": null,
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-System.ServiceModel.Syndication",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#41313",
        "CreatedAt": "2020-08-25T03:03:59+00:00",
        "CreatedBy": "layomia",
        "IsClosed": true,
        "Title": "JsonSerializer improvements in .NET 5",
        "DescriptionMarkdown": "In 5.0, we have added new features to \u0060JsonSerializer\u0060, improved performance and reliability, and made the serializer work on more platforms. This list goes over the most user-facing improvements.\r\n\r\n| Issue  | Description                                                                   | Category               |\r\n|--------|-------------------------------------------------------------------------------|------------------------|\r\n| #30820 | Add mechanism to preserve object references when (de)serializing              | Feature                |\r\n| #32937 | Add extension methods for HttpClient that allow (de)serializing JSON          | Feature                |\r\n| #30255 | Support (de)serializing quoted numbers                                        | Feature                |\r\n| #29895 | Support deserializing objects using parameterized constructors                | Feature                |\r\n| #876   | Support (de)serializing fields                                                | Feature                |\r\n| #779   | Support ignoring value-type defaults | Feature |\r\n| #30687 | Support conditionally ignoring properties (always, never, when null/default)  | Feature                |\r\n| #30524 | Support non-string dictionary keys                                            | Feature                |\r\n| #29743 | Allow using non-public property accessors for (de)serialization               | Feature                |\r\n| #34439 | Provide opt-in for custom converters to handle null                           | Feature                |\r\n| #38539 | Support new C# record types | Feature |\r\n| #30445 | Add a copy constructor to JsonSerializerOptions                               | Feature                |\r\n| #34626 | Add constructor to JsonSerializerOptions that takes serialization defaults    | Feature                |\r\n| #2259  | Improve (de)serialization performance for collections             | Performance            |\r\n| #36635 | Improve serialization performance for small or value-type POCOS (TechEmpower) | Performance            |\r\n| #35848 | Improve deserialization perf for case-insensitive and missing-property cases  | Performance            |\r\n| https://github.com/dotnet/corefx/pull/41845 | Improve perf for deserializing long JSON strings              | Performance            |\r\n| #31326 | Enable JsonSerializer to work on Xamarin iOS/Android                          | Platform support       |\r\n\r\nCheck out demos for the new features: https://github.com/layomia/NET5JsonDemos.",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-System.Text.Json",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#38367",
        "CreatedAt": "2020-06-25T01:17:36+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": "Support WebAssembly (Mono Runtime)",
        "DescriptionMarkdown": "# Support WebAssembly (Mono Runtime)\r\n\r\n[WebAssembly](https://webassembly.org/) is a relatively new virtual machine execution environment that can run any program that can be described in and target the web assembly [binary instruction format](https://webassembly.github.io/spec/core/binary/index.html). It is supported by all major browsers, although isn\u2019t browser-specific. We expect more general uses of WebAssembly to become commonplace in the coming years. It is important that .NET developers can publish apps to environments that support WebAssembly.\r\n\r\nWe released a first version of support for WebAssembly with [Bazor WebAssembly 3.2](https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available/). It was based on the Mono runtime and libraries. [Uno Platform](https://platform.uno/uno-platform-for-web-webassembly/) also relies on Mono for its WebAssembly support.\r\n\r\nIn .NET 5.0, we will continue to use the Mono runtime, and will switch to using the .NET 5.0 libraries. There are two major benefits to this change: better throughput performance, and higher compatibility with .NET 5.0 non-WebAssembly code. The compatbility isn\u2019t perfect, since we\u2019re using two different runtimes (Mono for WebAssembly and CoreCLR for everything else), and the WebAssembly environment imposes restrictions on what .NET code can do.\r\n\r\nThe following work items describe the work items required for the project. These bullets will be changed to links as we create new issues for them.\r\n\r\nMono Runtime Performance\r\n\r\n-\tInterpreter performance improvements\r\n-\tV8 performance improvement reports\r\n- Add browser wasm support for BenchmarkDotNet\r\n\r\nAdopt .NET Runtime Libraries\r\n\r\n-\tAdd support for browser based networking\r\n-\tEnable globalization with ICU\r\n-\tSupport async/tasks in an environment without explicit threads\r\n-\tAdd new library decorations and IL linker capabilities to reduce final application sizes and improve trimming reliability\r\n\r\nSDK\r\n\r\n- Create browser wasm runtime pack for net5.0 tfm\r\n- Add a reference to the runtime pack in SDK for building and publishing Blazor wasm projects",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "arch-wasm",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "runtime-mono",
            "BackgroundColor": "005e5e"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#38349",
        "CreatedAt": "2020-06-24T18:36:34+00:00",
        "CreatedBy": "richlander",
        "IsClosed": false,
        "Title": "Improving credit for community contributions",
        "DescriptionMarkdown": "# Improving credit for community contributions\r\n\r\nWe\u0027re nearly five years into [.NET Core as an open source project](https://devblogs.microsoft.com/dotnet/net-core-is-open-source/). As a .NET team member and Microsoft rep, I want to share a big thanks to everyone in the community that has taken the time and interest to participate in the project. I would like to start a conversation about community credit and attribution. Right now, we don\u2019t have a consistent model in place that everyone can point to for giving credit for community contributions. That doesn\u0027t seem right, and I propose we fix it. What do you think?\r\n\r\nThe thesis of this document is that credit will be given more (both quantity and frequency) if everyone is empowered to give it, and that enabling more people to participate in credit giving will increase not diminish its meaningfulness.\r\n\r\n## What is credit?\r\n\r\n\u003E Dictionary: Public acknowledgment or praise, typically that given or received when a person\u0027s responsibility for an action or idea becomes or is made apparent\r\n\r\nLet\u0027s start with why credit is an important topic. \r\n\r\nOn the one hand, it\u0027s not necessary to give credit. Let\u0027s take one of the most well known contributors, [Ben Adams](https://github.com/benaadams). Anyone can query for  [Ben\u0027s commits](https://github.com/search?o=desc\u0026q=org%3Adotnet\u002Bis%3Apr\u002Bauthor%3Abenaadams\u0026s=committer-date\u0026type=Commits). It\u0027s all open, right? And, if you look at some of his merged PRs, you\u0027ll see people saying [thank you](https://github.com/dotnet/runtime/pull/35765#issuecomment-623204929) or [approving Ben\u0027s work without any fanfare](https://github.com/dotnet/runtime/pull/32296) (an implicit validation of high-quality work). Sure, sure. I think we all know that this isn\u0027t credit, but basic personal interaction. \r\n\r\nSide-bar: Are we doing a good enough job on personal interaction, or are .NET team members too terse and business-like? Do you see and recieve enough appreciation in PRs and issues in the dotnet org? Tell us.\r\n\r\nBack to the main topic. Credit is something significantly beyond saying \u0022thank you.\u0022 Credit is given when a contribution is elevated so that everyone can see it. It\u0027s the higher level of visibility that\u0027s important. Here\u0027s an example from the [.NET 5.0 Preview 2 post](https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-2/) where one of Ben\u0027s contributions is given a high level of visibility. FYI: This example of credit is only given to community members.\r\n\r\n\u003Cimg width=\u0022779\u0022 alt=\u0022Screen Shot 2020-06-06 at 9 54 59 PM\u0022 src=\u0022https://user-images.githubusercontent.com/2608468/83960687-9175a100-a840-11ea-8062-7be9547f09a0.png\u0022\u003E\r\n\r\nThere are similar examples in the [Preview 3](https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-3/), [Preview 4](https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/) and [Preview 5](https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-5/) posts. Visual Studio Code gives credit with their [Thank You section in their release notes](https://code.visualstudio.com/updates/v1_45#_thank-you). The Xamarin team has a similar model in their [release notes](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/release-notes/4.6/4.6.0-sr2#thank-you).\r\n\r\nOther projects focus on contributors of the month, like [Galaxy Project](https://galaxyproject.org/blog/2018-09-cotm-carrie-ganote/) and [Netdata](https://github.com/netdata/netdata/issues/7133). Note: These examples were found through searches. I have no idea what these projects do or what their history is.\r\n\r\n## Developing a better model for credit\r\n\r\n\u003E People appreciate and are motivated by credit for their contributions, ideas, and hard work. We need to find more and better ways to give people the credit they deserve and need.\r\n\r\nWe can develop and adopt a better and multi-faceted model. Here are some thoughts on what that might look like:\r\n\r\n* Clearly defined and regularly applied.\r\n* Managed as a joint project between the .NET Team and the community.\r\n* Broad definition of contributions (PRs and issues, code and docs, blog posts and videos, ...)\r\n\r\nIn a lot of ways, credit is just another project, that requires up-front thought, broad agreement on the value, and  features that need to be developed. While the goal of credit is admirable, we need to consider the regular care and feeding of a project focused on credit in order to satisfy the stated need. I propose we start with a good MVP (minimum viable product) in the dotnet/runtime repo, and watch how it is received. We can then extend or adjust (more repos, more ways of giving credit) from there.\r\n\r\nThe following is a proposal. It is a layered model that is intended to give 100% of contributors credit, enable both the community and Microsoft to play key roles, and start us down the path of more innovative models for credit giving.\r\n\r\n- Publish contributor lists for each release (for the whole product, not just the runtime repo)\r\n  - We did this [up until .NET Core 2.1](https://github.com/dotnet/core/blob/master/release-notes/2.1/2.1.0-contributor.md). Producing this list was unintentionally dropped as a release activity.\r\n  - Many projects product contributor lists in various forms. Mozilla\u0027s [evergreen list of contributors](https://www.mozilla.org/credits/) is a good example.\r\n  - Question: Do you like [this format](https://github.com/dotnet/core/blob/master/release-notes/2.1/2.1.0-contributor.md), or should we adopt a new one? Should it include GitHub avatars? Is it important to split contributors by repo? Should Microsoft and community contributions be mixed or separated (FYI: they have been mixed to date, and it is a technically simpler approach)? Should we look at an existing tool/model like [All Contributors](https://allcontributors.org/)?\r\n- Create a community-maintained contribution epic linked to from the [release epic](https://github.com/dotnet/runtime/issues/37269).\r\n  - The epic would be called \u0022Community contributions\u0022.\r\n  - The comunity would decide the bar for adding PRs/issues to its epic, and also the categorization within the epic.\r\n  - GitHub permissions are a challenge, so the community would need to pick an editor and then have that person create and maintain the issue.\r\n- Consider creating monthly issues that give credit more frequently for contributions (this would be a closer analogue to the VS Code \u0022thanks\u0022 approach, which is monthly)\r\n  - These contributor lists need to be significantly curated or adopt some other unique approach in order to provide value beyond the release-specific contributor lists.\r\n  - There are a many different (non-mututally-exclusive) approaches we could adopt/highlight: largest and most valuable contributions, first time contributors, multi-month contributors (\u003E6 months, \u003E12 months, ...), contribution with most reactions ([example](https://github.com/dotnet/runtime/pull/34393)), most interesting closed-not-merged contribution ([example](https://github.com/dotnet/runtime/pull/33152)), stale/closed community issue/PR that merits reconsideration ...\r\n  - This idea would require an ongoing and significant time investment. It would need a lot of community engagement (if not managed exclusively by the community) to keep alive.\r\n  - (re)Tweet these monthly issues from [@dotnet](https://twitter.com/dotnet) twitter account when they are published.\r\n- Continue to use the same approach to offering credit in the Microsoft blog posts for previews and releases.\r\n  - Link to the \u0022community contributions\u0022 epic and to monthly contributions issues.\r\n  - [For the .NET blog writer] Use those contribution issues for inspiration, to expand the offering of credit in the blog posts.\r\n- Consider an end-of-release blog post dedicated to community contributions\r\n  - This post might be written by the same people managing the community-contribution issues described earlier.\r\n- Ensure that Microsoft PRs that borrow from the community give credit\r\n   - A good example of giving credit: https://github.com/dotnet/runtime/pull/36405\r\n   - A not-yet-credited example ... we\u0027ve been working with @damageboy on his [this goes to 11](https://bits.houmus.org/2020-01-28/this-goes-to-eleven-pt1) project. Credit needs to be paid to [@damageboy](https://github.com/damageboy) as part of the 5.0 project.\r\n   - These type of contributions need to be elevated beyond contributor lists, including in the final 5.0 release blog post.\r\n\r\nIs this a good MVP? What else should we do or consider?\r\n\r\n## Diversity and inclusion (D\u0026I)\r\n\r\nThe credit topic is focused on raising people and their contributions up. This is an objectively noble goal, however, it\u0027s only truly noble if we also use it as an opportunity for change. It is widely known that women, people of color, LBTGQ\u002B folks, people with disabilities (visible and invisible), and other groups, are [under-represented in tech](https://en.wikipedia.org/wiki/Underrepresented_group#Underrepresented_groups_in_STEM). We need to find ways to increase, motivate and celebrate contributions from people under-represented in tech. Equally important, we should also motivate and celebrate people who step up, as allies, to mentor underrepresented people to participate in tech. Please help us explore other ways to help connect people with barriers to contribution with help.\r\n\r\nIs it necessary to bring D\u0026I into a topic as simple and straightforward as credit? Yes. This is a perfect opportunity for raising people up that have well-established barriers to participation. Putting aside the moral reasons to do this, these are large groups of people that do not have the same ability to participate (as established groups that participate), and may be forward-looking sources of great contributors.\r\n\r\n## Next Steps\r\n\r\nThis .NET project started with Microsoft, but lives with the community. We need a set of community editors and curators to step forward to make much of this credit proposal real, and for the community to organize in some way to accept them as good stewards of community-generated credit giving.\r\n\r\nA better credit system is an overdue addition for ensuring that everyone in the community feels that their participation is appreciated and acknowledged. I\u0027ve offered some pretty obvious changes (like re-starting publishing contributor lists) and some more novel ones (like the \u0022community contributions\u0022 epic ). We can simply start with those if you want. We would like to start a dialog. Please share your thoughts.\r\n",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#37534",
        "CreatedAt": "2020-06-06T01:21:09+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": "Improving P95\u002B latency",
        "DescriptionMarkdown": "## Improving P95\u002B latency\r\n\r\nWe see an increasing number of large internet-facing sites and services being hosted on .NET. While there is a lot of legitimate focus on the [requests per second (RPS) metric](https://twitter.com/ben_a_adams/status/1260792649625280513), we find that very few big site owners ask us about that or even need to satisfy throughput approaching 1000 RPS (1000 RPS == 86M requests per day). We hear a lot more about latency, specifically about improving [P95 or P99 latency](https://docs.microsoft.com/en-us/azure/internet-analyzer/internet-analyzer-scorecard). Often, the number of machines or cores that are provisioned for (and biggest cost driver of) a site are chosen based on achieving a specific P95 metric (for example, 200ms), as opposed to a lower P50 metric (for example, 50ms). We think of latency as being the true \u201Cmoney metric\u201D.\r\n\r\nWe want .NET to be a platform that makes it cheaper to host your applications with each new release. In order to achieve that, it\u0027s important that latency is both good (low) but also predictable. That\u0027s the whole point of measuring P95\u002B latency. We have increased our focus on predictably consistent performance, reducing performance cliffs and outliers, with an emphasis on P95\u002B latency.\r\n\r\nAn equally important theme is predictable performance. Some of these epics are more related to that, then specifically targeting P95 latency. We\u0027re going to be a bit lazy here, and mix the two topics.\r\n\r\n## GC\r\n\r\n* [Card mark stealing for better work balance in Server GC](https://github.com/dotnet/coreclr/pull/25986)\r\n* [Optimize decommitting GC heap memory pages](https://github.com/dotnet/runtime/pull/35896)\r\n * [Pinned object heap](https://github.com/dotnet/runtime/pull/32283) to reduce heap fragmentation caused by pinning\r\nReduce GC pause times in specific situations, like [Array.Copy](https://github.com/dotnet/coreclr/pull/27776), [Array.Sort](https://github.com/dotnet/runtime/pull/35297) or [object unboxing](https://github.com/dotnet/runtime/pull/32353#issuecomment-586642480)\r\n\r\n## Runtime\r\n\r\n* [Improve call counting mechanism](https://github.com/dotnet/runtime/pull/32250) used by tiered JIT compilation to smooth out performance during startup\r\n* [Casting in a loop may cause long GC pause times](https://github.com/dotnet/runtime/issues/13821)\r\n* [Dynamic expansion of internal generic dictionary](https://github.com/dotnet/runtime/pull/32270) that eliminate performance cliffs hit by generic code\r\n* [Fix for solving lock contention issue in GC statics scanning](https://github.com/dotnet/runtime/pull/32795)\r\n* [GC polling in unboxing JIT helpers](https://github.com/dotnet/runtime/pull/32353#issuecomment-586642480)\r\n* [Buffer::BlockCopy may spend too long without GC polling](https://github.com/dotnet/runtime/issues/13554)\r\n* [Calling System.Math floating point operations in a loop causes long GC pause times ](https://github.com/dotnet/runtime/issues/13820)\r\n* [Inlined GC poll for methods marked with SuppressGCTransitionAttribute](https://github.com/dotnet/runtime/issues/13582)\r\n\r\n## Libraries\r\n\r\n* [Very high latency for GC when using (lots of) ThreadLocal](https://github.com/dotnet/runtime/issues/2382)",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "tenet-performance",
            "BackgroundColor": "c2e0c6"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#37269",
        "CreatedAt": "2020-06-01T20:42:52+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": ".NET 5.0 Runtime Epics",
        "DescriptionMarkdown": "# .NET 5.0 Runtime Epics\r\n\r\nThe .NET 5.0 release is composed of many improvements and features. This issue lists the \u0022epics\u0022 that are part of the release (for dotnet/runtime). Beyond these epics are many \u0022features\u0022 in this release that are not listed here, because they are not truly epics. An epic is a collection of features that together form a step-function level improvement in .NET, and typically requires the epic owner (a single developer or a small team) to go on a [journey to satisfy the epic goals](https://en.wikipedia.org/wiki/Epic_poetry). Such a journey can require taking great personal risk or fighting dragons, but it\u0027s all worth it to make .NET better.\r\n\r\nThis list will be filled out over the course of the release. Team members working on epics are encouraged to edit this issue directly to add their epic. The order of the epics is arbitrary (like epics should be grouped together). A small set of these 5.0 epics may be enabling early (but partial) support for .NET 6.0 scenarios.\r\n\r\n## Libraries\r\n\r\n* [Optimize library code using arm64 intrinsics](https://github.com/dotnet/runtime/issues/33308)\r\n* [Enable \u0060net5.0\u0060 TFM](https://github.com/dotnet/runtime/issues/34173)\r\n* [Enabling libraries support for iOS, Android, and Xamarin.Mac](https://github.com/dotnet/runtime/issues/35410) (6.0)\r\n* [Improving JsonSerializer functionality and performance](https://github.com/dotnet/runtime/issues/41313)\r\n\r\n## Runtime\r\n\r\n* [Improving P95\u002B latency](https://github.com/dotnet/runtime/issues/37534)\r\n* [Improving ARM64 Performance in .NET 5.0 \u2013 Closing the gap with x64](https://github.com/dotnet/runtime/issues/35853)\r\n* [Support Windows ARM64](https://github.com/dotnet/runtime/issues/36699)\r\n* [Support Single-File Apps](https://github.com/dotnet/runtime/issues/36590)\r\n* [Support WinRT APIs in .NET 5](https://github.com/dotnet/runtime/issues/35318)\r\n* [Support WebAssembly (Mono Runtime)](https://github.com/dotnet/runtime/issues/38367)\r\n\r\n## Tools\r\n\r\n* [Roslyn code analyzers for interop](https://github.com/dotnet/runtime/issues/37039)\r\n\r\n## Experiments\r\n\r\n* [Implement simple version of On Stack Replacement (OSR)](https://github.com/dotnet/runtime/pull/32969)\r\n\r\n## Other\r\n\r\n* [New Roslyn analyzers for library authors](https://github.com/dotnet/runtime/projects/46)\r\n* [Detect platform-specific API using analyzers](https://github.com/dotnet/runtime/issues/37359)",
        "Milestone": "5.0.0",
        "Assignees": [
          "richlander"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#36699",
        "CreatedAt": "2020-05-19T14:15:52+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": "Support Windows ARM64",
        "DescriptionMarkdown": "# Support Windows ARM64\r\n\r\nWe are in the process of adding support for [Windows ARM64](https://docs.microsoft.com/en-us/windows/arm/) as part of the .NET 5.0 project. As a result, you will be able to run Windows Forms, WPF and ASP.NET Core apps on Windows ARM64 devices, such as the [Surface Pro X](https://www.microsoft.com/en-us/p/surface-pro-x/8VDNRP2M6HHC).\r\n\r\nWe intend to support the same .NET capabilities on ARM64 as on x64. Related: https://github.com/dotnet/runtime/issues/35853\r\n\r\nThis project follows a similar effort to add Console and ASP.NET Core support for [Linux ARM64](https://github.com/dotnet/announcements/issues/82).\r\n\r\nThe [.NET 5.0 Preview 4 SDK](https://dotnet.microsoft.com/download/dotnet/5.0) supports building and running ASP.NET Core and Console apps.\r\n\r\nYou can install [\u0060master\u0060 branch builds](https://github.com/dotnet/installer#installers-and-binaries) if you would like want to test Windows Forms on ARM64. \u0060master\u0060 branch builds do not yet include WPF support for ARM64.\r\n\r\n## Remaining .NET 5 Work\r\n\r\n- [x] Windows ARM64 ASP.NET Core MSI (necessary for the SDK install): https://github.com/dotnet/aspnetcore/pull/25579\r\n- [ ] Windows ARM64 SDK MSI: https://github.com/dotnet/installer/pull/8470\r\n\r\n## Post .NET 5 Work\r\n\r\n* [ ] Produce and publish Windows Desktop Runtime Pack for ARM64\r\n  * [x] Add Windows Forms to the Windows Desktop Runtime Pack\r\n  * [ ] Add WPF to the Windows Desktop Runtime Pack\r\n* [ ] Add Windows Desktop framework to the SDK\r\n  * [x] Add Windows Forms to the Windows Desktop framework in the SDK\r\n  * [ ] Add WPF to the Windows Desktop framework in the SDK\r\n  * [x] Crossgen Windows Desktop Pack for ARM64\r\n* [ ] Test PowerShell on Windows ARM64 (PowerShell team will do this, but it is an important signoff criteria)\r\n\r\n## Timeline\r\n\r\nThe following timeline is for .NET 5.0 and Windows ARM64:\r\n*\t.NET 5.0 Preview 4 -- Ship the .NET SDK, without Windows Desktop\r\n*\t.NET 5.0 Preview 5 -- Add Windows Desktop to SDK, with Windows Forms\r\n*\t.NET 5.0 Preview 6 -- Add ARM64 MSI installer for .NET Runtime \r\n* \t.NET 5.0 RC2 -- Add ARM64 MSI installer for SDK\r\n* TBD -- Add WPF to Windows Desktop\r\n\r\nAfter this project is complete, the Windows ARM64 SDK will have functional parity with x64.\r\n\r\n## Examples\r\n\r\nThe following image demonstrate the [Conway\u0027s Game of life](https://github.com/dotnet/samples/tree/master/windowsforms/Conway\u0027s-Game-of-Life/VB) VB sample running on Windows ARM64.\r\n\r\n\u003Cimg width=\u0022398\u0022 alt=\u00222020-05-15\u0022 src=\u0022https://user-images.githubusercontent.com/2608468/82086979-20f5bd00-96a4-11ea-8d73-abed8f2505fb.png\u0022\u003E\r\n\r\nThe following demonstrates displaying [version information in a Windows Forms app](https://github.com/richlander/testapps/tree/master/versioninfo-windowsforms) on ARM64.\r\n\r\n![image](https://user-images.githubusercontent.com/2608468/87205382-2cd4b880-c2bc-11ea-9c3f-a9d6f02b3af2.png)\r\n\r\nThe following image demonstrates 32-bit x86 Windows PowerShell 5.1 running emulated (on .NET Framework 4.8), and 64-bit ARM64 PowerShell 7.1 running natively (on .NET 5.0) on Windows ARM64.\r\n\r\n\u003Cimg width=\u0022375\u0022 alt=\u00222020-05-15 (5)\u0022 src=\u0022https://user-images.githubusercontent.com/2608468/82128604-3dabf680-9771-11ea-9847-ca977549b21d.png\u0022\u003E\r\n\r\nSee [PowerShell/PowerShell](https://github.com/powershell/powershell) to download the Windows ARM64 version. You can also install the [PowerShell .NET tool](https://www.nuget.org/packages/PowerShell/) on Windows ARM64.\r\n\r\nSee [versioninfo](https://github.com/richlander/testapps/blob/master/versioninfo/Program.cs) for APIs that you can use to get version and architecture information.",
        "Milestone": "5.0.0",
        "Assignees": [
          "richlander",
          "tommcdon"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "arch-arm64",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "blocking-release",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#36590",
        "CreatedAt": "2020-05-16T00:22:58+00:00",
        "CreatedBy": "swaroop-sridhar",
        "IsClosed": true,
        "Title": "Support Single-File Apps in .NET 5",
        "DescriptionMarkdown": "The goal of this effort is enable .Net-Core apps to be published and distributed as a single executable. \r\n\r\n## Goals\r\n\r\nThe .Net 5.0 single file solution should be:\r\n\r\n* Widely compatible: Apps containing IL assemblies, ready-to-run assemblies, composite assemblies, native binaries, configuration files, etc. can be packaged into one executable.\r\n* Can run managed components of the app directly from bundle, without need for extraction to disk. \r\n* Usable with debuggers and tools.\r\n\r\n## User Experience\r\n\r\nHere\u0027s the overall experience for publishing a HelloWorld single-file app in .net 5: \r\n\r\n* Framework-dependent \r\n    * Publish command: \u0060dotnet publish -r win-x64 --self-contained=false /p:PublishSingleFile=true\u0060\r\n    * Published files: \u0060HelloWorld.exe\u0060, \u0060HelloWorld.pdb\u0060\r\n\r\n* Self-contained (Linux)\r\n    * Publish command: \u0060dotnet publish -r linux-x64 /p:PublishSingleFile=true\u0060\r\n    * Published files: \u0060HelloWorld\u0060, \u0060HelloWorld.pdb\u0060\r\n\r\n* Self-contained (Windows): \r\n    * Publish command: \u0060dotnet publish -r win-x64 /p:PublishSingleFile=true\u0060\r\n    * Published files: \u0060HelloWorld.exe\u0060, \u0060HelloWorld.pdb\u0060, \u0060coreclr.dll\u0060, \u0060clrjit.dll\u0060, \u0060clrcompression.dll\u0060,  \u0060mscordaccore.dll\u0060\r\n\r\n* Self-contained (Windows) with bundled native components:\r\n    * Publish command: \u0060dotnet publish -r win-x64 /p:PublishSingleFile=true /p:IncludeNativeLibrariesInSingleFile=true\u0060 \r\n    * Published files: \u0060HelloWorld.exe\u0060, \u0060HelloWorld.pdb\u0060\r\n\r\n## Design Document\r\n\r\nA detailed discussion of the goals, non-goals, related-work, options, design decisions, and implementation details of supporting single-file apps is available in this [design document](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md)\r\n\r\n## Tracking Progress\r\n\r\n- [x] Initial proposal and poll for customer response: \r\n    - [x] Poll on GitHub: #11201\r\n    - [x] Enterprise customer poll \r\n- [x] Propose [staged implementation](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/staging.md) of the feature.\r\n- [x] Support single-file apps through extraction (.net core 3)\r\n    - [x] Self-Extractor [Design](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design_3_0.md).\r\n    - [x] SDK support for publishing apps as a single-file. https://github.com/dotnet/sdk/pull/3132\r\n    - [x] AppHost support for extracting contents of a single-file bundle at startup. https://github.com/dotnet/core-setup/pull/5742\r\n- [x] Support single-file apps running from bundle (.net 5)\r\n   - [x] HostModel library\r\n       - [x] Implement bundle format [version 2](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/bundler.md#bundle-layout). https://github.com/dotnet/core-setup/pull/5742\r\n   - [x] SDK\r\n       - [x] Implement support for publishing [a few files](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#user-experience) when necessary for \u0060PublishSingleFile\u0060.  https://github.com/dotnet/sdk/pull/11586\r\n       - [x] Implement [optional settings](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#optional-settings) for single-file publishing. https://github.com/dotnet/sdk/pull/11797\r\n       - [x] Use [SingleFileHost](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#host-builds) when publishing self-contained single-file apps. https://github.com/dotnet/sdk/issues/11567 https://github.com/dotnet/sdk/pull/11797\r\n       - [x] Trim the set of native dependencies used for single-file publish. https://github.com/dotnet/runtime/pull/36578 https://github.com/dotnet/sdk/pull/11797\r\n    - [x] Host\r\n        - [x] Move bundle-processing from the host to the [framework](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#the-host) . https://github.com/dotnet/runtime/pull/34274\r\n       - [x] Process \u0060deps.json\u0060 and \u0060runtimeconfig.json\u0060 files directly from bundle. https://github.com/dotnet/runtime/pull/34274\r\n       - [x] Implement a callback for the runtime to probe the contents of the bundle. https://github.com/dotnet/runtime/pull/34845\r\n     - [x] Host Builds\r\n        - [x] Windows: Implement \u0060SingleFileHost\u0060 with \u0060AppHost\u0060, \u0060HostFxr\u0060, and \u0060HostPolicy\u0060 statically linked. #32823 #36230\r\n       - [x] Linux: Implement \u0060SingleFileHost\u0060 with host and runtime components statically linked. \r\n           - [x] Statically link \u0060CoreCLR\u0060 and \u0060ClrJIT\u0060 with \u0060SingleFileHost\u0060 #37119 #36847\r\n           - [x] Statically link core native libraries with \u0060SingleFileHost\u0060 #38304\r\n     - [x] Runtime\r\n         - [x] Load assemblies [directly from bundle](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#peimage-loader). #32822 #36052 \r\n         - [x] Dependency resolution: [Resolve assemblies from bundle](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#dependency-resolution). #36052\r\n    - [x] APIs\r\n         - [x] \u0060AppContext.BaseDirectory\u0060 should return the [location of the single-file executable](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#appcontextbasedirectory) https://github.com/dotnet/runtime/pull/34274\r\n ",
        "Milestone": "5.0.0",
        "Assignees": [
          "VSadov",
          "swaroop-sridhar"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Single-File",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#11201",
            "CreatedAt": "2018-10-05T21:48:53+00:00",
            "CreatedBy": "morganbr",
            "IsClosed": true,
            "Title": "Support single-file distribution",
            "DescriptionMarkdown": "This issue tracks progress on the .NET Core 3.0 single-file distribution feature. \r\nHere\u0027s the [design doc](https://github.com/dotnet/designs/blob/master/accepted/single-file/design.md) and [staging plan](https://github.com/dotnet/designs/blob/master/accepted/single-file/staging.md) for the feature.",
            "Milestone": "Future",
            "Assignees": [
              "swaroop-sridhar"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11567",
            "CreatedAt": "2020-05-05T21:35:09+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Use SingleFileHost for self-contained single-file apps",
            "DescriptionMarkdown": "There are two main tasks that need to be done for self-contained single-file publish scenario:\r\n\r\n## Use \u0060singlefilehost\u0060\r\n* @VSadov\u0027s [PR](https://github.com/dotnet/runtime/pull/35368)  adds \u0060singlefilehost\u0060 to the \u0060microsoft.netcore.app.host.*\u0060 packages.\r\n* [ResolveAppHosts](https://github.com/dotnet/sdk/blob/611fcdd2ce0b29abae9967ca8e425db1a4def176/src/Tasks/Microsoft.NET.Build.Tasks/ResolveAppHosts.cs#L58-L64) will resolve \u0060singlefilehost\u0060 to the same package as \u0060apphost\u0060, \u0060ijwhost\u0060, and \u0060comhost\u0060.\r\n* When publishing for self-contained single-file apps, the [CreateAppHost task]( https://github.com/dotnet/sdk/blob/36ef8b2aa8e5d579c921704bdab69a7407936889/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Sdk.targets#L427) will be invoked with the singlefilehost path as its \u0060AppHostSourcePath\u0060. This will generate an app using \u0060singlefilehost\u0060.\r\n* This may not work very well for a sequence such below. However, I think fixing this case is not crucial, because the \u0060--no-build\u0060 already has [similar concerns](https://github.com/dotnet/sdk/issues/10608) for self-contained vs framework-dependent publish.\r\n\r\n\u0060\u0060\u0060\r\n    dotnet build -r win-x64 \r\n    dotnet publish --no-build -r win-x64 /p:PublishSingleFile=true.\r\n\u0060\u0060\u0060\r\n\r\n## Trim the native components of the runtime:\r\n* Certain files in \u0060microsoft.netcore.app.runtime.*\u0060 package are no longer necessary to be published for single-file apps.\r\n* For example, \u0060hostfxr\u0060 and \u0060hostpolicy\u0060 are not necessary since they are statically linked with \u0060singlefilehost\u0060. Later \u0060coreclr\u0060, \u0060clrjit\u0060 will also be linked with the \u0060singlefilehost\u0060, and they are also not necessary. Certain other files such as \u0060createdump\u0060 are excluded from the publish as a matter of policy decision. \r\n* This exclusion is different from \u0060ExcludeFromSingleFile\u0060\r\n    * In this case, the files, the excluded files are not published at all (neither in the bundle nor in the publish directory beside the single-file bundle).\r\n    * Files marked \u0060ExcludeFromSingleFile\u0060 are copied to publish directory alongside the single-file app.\r\n* The plan to realize this exclusion of runtime components is:\r\n    * The \u0060RuntimeList.xml\u0060 in \u0060microsoft.netcore.app.runtime.*\u0060 package will contain special meta-data identifying that the file is not necessary for single-file scenario\r\n\u0060\u003CFile FileVersion=\u00220.0.0.0\u0022 Path=\u0022runtimes/linux-x64/native/createdump\u0022 Type=\u0022Native\u0022 DropFromSingleFile=\u0022true\u0022/\u003E\u0060\r\n    * The  [\u0060ResolveRuntimePackAssets\u0060 task](https://github.com/dotnet/sdk/blame/611fcdd2ce0b29abae9967ca8e425db1a4def176/src/Tasks/Microsoft.NET.Build.Tasks/ResolveRuntimePackAssets.cs#L92) will transfer this annotation as (\u0060DropFromSingleFile\u0060) meta-data on the asset.\r\n  * The Single-file [publish targets](https://github.com/dotnet/sdk/blob/611fcdd2ce0b29abae9967ca8e425db1a4def176/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Publish.targets#L938-L941) will use this meta-data to drop these files, and not publish them in the single-file app.\r\n",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "swaroop-sridhar"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#32823",
            "CreatedAt": "2020-02-25T21:29:05+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Implement statically linked apphost",
            "DescriptionMarkdown": "In order to support single-file apps, implement the \u0022static-host\u0022 host-builds as described [here](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#host-builds), publish them to be consumed by the SDK.\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "VSadov"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#37119",
            "CreatedAt": "2020-05-28T06:57:20+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Implement Linux SingleFileHost with statically linked runtime",
            "DescriptionMarkdown": "In order to support single-file apps, implement the \u0060singlefilehost\u0060 with runtime linked in.\r\nThis host is codenamed \u0022super-host\u0022 in the [design-doc](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#host-builds).\r\n\r\nIn .net 5, this host will be implemented only for Linux X64.\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "VSadov"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-linux",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#38304",
            "CreatedAt": "2020-06-23T22:29:34+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "SingleFile: Statically link core native libraries to Linux SingleFileHost",
            "DescriptionMarkdown": "Statically link System.Native, System.IO.Compression.Native, System.IO.Ports.Native, System.Net.Http.Native, System.Net.Security.Native and System.Security.Cryptography.Native.OpenSsl native libraries with singlefilehost.\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "VSadov"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-linux",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#32822",
            "CreatedAt": "2020-02-25T21:26:39+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Implement loading assemblies from bundle",
            "DescriptionMarkdown": "Implement runtime changes necessary to load assemblies directly from the bundle, as described here:\r\nhttps://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#peimage-loader",
            "Milestone": "5.0.0",
            "Assignees": [
              "swaroop-sridhar"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#36052",
            "CreatedAt": "2020-05-07T22:32:12+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Run from Bundle",
            "DescriptionMarkdown": "This change implements:\r\n\r\n* Runtime changes necessary to load assemblies directly from the bundle:\r\n    * Design notes about [Load from Bundle](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#peimage-loader)\r\n    * Most of these changes are directly from https://github.com/dotnet/coreclr/pull/26504 and https://github.com/dotnet/coreclr/pull/26904\r\n\r\n* Hostpolicy change to not add bundled assemblies to TPA list:\r\n    * Design notes about [Dependency Resolution](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#dependency-resolution)\r\n    * TBD (separately) items: Fix for hammer servicing #36031\r\n\r\nFixes #32822",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#36449",
        "CreatedAt": "2020-05-14T14:14:05+00:00",
        "CreatedBy": "lambdageek",
        "IsClosed": true,
        "Title": "[Mono] Add QCalls to the runtime",
        "DescriptionMarkdown": "In CoreCLR QCalls ([documented in botr](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/corelib.md#calling-from-managed-to-native-code)) are one way to call back into the runtime from managed code.  They are basically P/Invokes, but with a lookup that goes through a runtime table.\r\n\r\nSupporting QCalls in Mono will have a couple of benefits:\r\n1. Less churn on the managed side of S.P.C when it makes sense we can just share managed declarations instead of having to mark them with \u0060[MethodImpl (MethodImplOptions.InternalCall)]\u0060 for Mono and as a QCall for CoreCLR.\r\n2. We won\u0027t need to make the native symbols visible - right now for \u0060DllImport (__Internal)\u0060 - which we\u0027ve used for the ICU shims and some System.Native methods that we link into the MonoVM, we rely on \u0060dlsym\u0060 which means the symbol needs to be visible.  And also we have to do hacks for \u0060RTLD_LOCAL\u0060 in order for lookups to work both in the runtime and in the embedding host on Android, OSX, etc.  With QCalls the lookup logic doesn\u0027t depend on dlsym - we just build a table at runtime.\r\n3. Ability to share more native code - since QCalls are just PInvokes they will run in GC Safe mode and will need to switch to GC Unsafe when they call into the runtime APIs.  This is similar to how these methods behave in CoreCLR, so for projects like the EventPipe C implementation we can have uniform logic around thread GC state transitions.\r\n\r\nDownsides:\r\n1. Transitions from GC Unsafe (which managed code uses) to GC Safe (when going to a P/Invoke) aren\u0027t free.  Which is why CoreCLR has a \u0060SuppressGCTransitionAttribute\u0060 https://github.com/dotnet/runtime/issues/30741 attribute which we should also implement.\r\n2. A table in the runtime means we\u0027ll need to do \u0060#ifdef\u0060 stuff to remove definitions for methods that shouldn\u0027t be in a particular runtime configuration.  Can\u0027t just rely on not linking the functions into the final binary.\r\n3. There will still be differences in how the native code is implemented. For passing object references to native code, CLR uses a [\u0060REF\u003CT\u003E\u0060](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/vars.hpp#L228)  C\u002B\u002B template (or rather specific the base class \u0060OBJECTREF\u0060 or instances like \u0060SAFEHANDLEREF\u0060) and we won\u0027t be able to make use of it in Mono directly.  Which means that sharing will only be possible in native code like the EventPipe C impl that already takes great care to abstract over the differences between CoreCLR and MonoVM\r\n\r\nTasks:\r\n- [x] Add support for registering and looking up QCalls\r\n- [x] Add support for \u0060SuppressGCTransitionAttribute\u0060\r\n- [x] Share the \u0060QCallHandles\u0060 structs https://github.com/dotnet/runtime/blob/master/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/CompilerServices/QCallHandles.cs\r\n   - ~Add special marshalling support for these (or do they just work - unclear)~ these should just work\r\n   - we will need some implementations of \u0060GetUnderlyingNativeHandle\u0060 for \u0060Module\u0060 and \u0060Assembly\u0060 in our System.Reflection implementation.\r\n- [ ] Design and implement some analog of the \u0060REF\u003CT\u003E\u0060 template that we can use to pass object references to the C code in a relatively painless way.  ideally something that works with our \u0060object-internals.h\u0060 and \u0060handles.h\u0060 types.  Although the ideal with QCalls is to pass only a very limited number of object references to native code if it can be at all avoided.",
        "Milestone": "5.0.0",
        "Assignees": [
          "thaystg"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Interop-mono",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "runtime-mono",
            "BackgroundColor": "005e5e"
          },
          {
            "Name": "tracking",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#35318",
        "CreatedAt": "2020-04-23T00:12:07+00:00",
        "CreatedBy": "AaronRobinsonMSFT",
        "IsClosed": true,
        "Title": "Support WinRT APIs in .NET 5",
        "DescriptionMarkdown": "We are moving to a new model for supporting WinRT APIs as part of .NET 5.0. This includes calling APIs (in either direction; CLR \u003C==\u003E WinRT), marshaling of data between the two type systems, and unification of types that are intended to be single instance (i.e. \u0022projected types\u0022). We will be removing the existing WinRT interop system from the .NET runtime (and any other associated components) as part of .NET 5.0.\r\n\r\nWe will rely on a new set of tools provided by the WinRT team in Windows that will generate C#-based WinRT interop assemblies. We are currently working closely with that team. The tools will be delivered for .NET 5.0.\r\n\r\nThere are several benefits to the new system:\r\n* Can be developed and improved separate from the .NET runtime.\r\n* Symmetrical with interop systems provided for other OSes, like iOS and Android.\r\n* Can take advantage of many other .NET features (AOT, C# features, IL linking).\r\n* Simplifies the .NET runtime codebase.\r\n\r\n### Goals\r\n* Allow the WinRT ecosystem to move independently of the .NET runtime with respect to WinRT projections.\r\n* Migration of existing applications and libraries to this new model should require minimal code changes. Creating a new project and recompilation is considered acceptable.\r\n* Provide a WinRT solution that is AOT and [ILLinker](https://github.com/mono/linker) friendly.\r\n* Permit the ability to remove built-in .NET Runtime support of WinRT. \r\n* Provide similar performance to what is available with .NET Core 3.1.\r\n\r\n### Non-Goals\r\n* Support existing WinMD-based managed WinRT assemblies.\r\n* Replace the MCG tool used by .NET Native.\r\n\r\n## .NET Runtime/SDK work\r\n- [x] Creation and management of [COM wrappers](https://github.com/dotnet/runtime/issues/1845).\r\n  - [x] Support [\u0060ICustomQueryInterface\u0060](https://github.com/dotnet/runtime/issues/34717).\r\n  - [x] Provide [a mechanism to determine if \u0060ComWrappers\u0060 are being called from legacy APIs](https://github.com/dotnet/runtime/issues/35530).\r\n  - [x] Ensure [\u0060IWeakReference\u0060](https://docs.microsoft.com/windows/win32/api/weakreference/nn-weakreference-iweakreference) continues to interact with the .NET types: [\u0060WeakReference\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference) and [\u0060WeakReference\u003CT\u003E\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference-1). See https://github.com/dotnet/runtime/issues/35745.\r\n  - [x] [Support an \u0060ICastable\u0060-esque solution](https://github.com/dotnet/runtime/issues/36654).\r\n- [C# function pointers](https://github.com/dotnet/roslyn/issues/39865) to achieve performance goals.\r\n  - This work was already in flight with the [C# function pointers proposal](https://github.com/dotnet/csharplang/blob/master/proposals/function-pointers.md).\r\n  - [x] Expose ~~[\u0060NativeCallableAttribute\u0060](https://github.com/dotnet/runtime/issues/32462)~~ [\u0060UnmanagedCallersOnlyAttribute\u0060](https://github.com/dotnet/runtime/issues/35433).\r\n  \r\n## [CsWinRT](https://github.com/microsoft/CsWinRT) work\r\n\r\n- [x] Consume the new [\u0060ComWrappers\u0060](https://github.com/dotnet/runtime/issues/1845) API.\r\n- [x] Help generate C# source for interop code.\r\n  - [x] Support correct managed object wrapper lifetime management. https://github.com/microsoft/CsWinRT/issues/37\r\n  - [x] Support default implemented interfaces. https://github.com/microsoft/CsWinRT/issues/49\r\n  - [x] Marshaling of arrays of interfaces. https://github.com/microsoft/CsWinRT/issues/61\r\n  - [x] Support [\u0060IRestrictedErrorInfo\u0060](https://docs.microsoft.com/windows/win32/api/restrictederrorinfo/nn-restrictederrorinfo-irestrictederrorinfo). https://github.com/microsoft/CsWinRT/issues/76\r\n  - [x] Support [\u0060ICustomPropertyProvider\u0060](https://docs.microsoft.com/uwp/api/windows.ui.xaml.data.icustompropertyprovider). https://github.com/microsoft/CsWinRT/issues/102\r\n\r\n## Breaking changes\r\n\r\nRemoval of built-in WinRT support. See https://github.com/dotnet/runtime/issues/37672.\r\n - https://github.com/dotnet/runtime/pull/36715\r\n\r\n/cc @richlander @jeffschwMSFT @jkoritzinsky @elinor-fung ",
        "Milestone": "5.0.0",
        "Assignees": [
          "jkoritzinsky",
          "AaronRobinsonMSFT"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Interop-coreclr",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "breaking-change",
            "BackgroundColor": "ffa500"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#1845",
            "CreatedAt": "2020-01-17T02:01:47+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "Low level API support for RCW and CCW management",
            "DescriptionMarkdown": "Work has begun to provide support for [WinUI 3.0](https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md#winui-3). This support is expected to manifest in a way similar to the [CppWinRT](https://github.com/microsoft/cppwinrt) tool by way of a new source generation tool (e.g. CsWinRT). In order to support this new tool, APIs for integrating and coordinating with the runtime object lifetime are necessary.\r\n\r\n# Rationale and Usage\r\n\r\nThe below API surface provides a way for a third party tool to generate what are colloquially known as [Runtime Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/runtime-callable-wrapper) (RCW) and [COM Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/com-callable-wrapper) (CCW) in a way that allows safe interaction with managed object lifetime and identity.\r\n\r\nA specific example of the need for lifetime coordination is in WinRT scenarios involving UI (e.g.  WinUI 3.0) via the [\u0060IReferenceTrackerManager\u0060](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackermanager) interface.\r\n\r\n## Goals:\r\n* Enable source generation of interop code in WinRT/WinUI scenarios.\r\n* An API that generally aligns with how existing 3rd party source generators work (e.g. [SharpGenTools](https://github.com/SharpGenTools/SharpGenTools)).\r\n* Limit exposing APIs that manage lifetime in a micro way (e.g. avoid GC hooks at dangerous times).\r\n* Semantics in .NET Framework/.NET Core for WinRT scenarios should be able to be replicated.\r\n* Provide a mechanism for 3rd parties to be able to support [Reference Tracker scenarios](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/).\r\n* Ensure AOT scenarios are considered.\r\n\r\n## Non-Goals:\r\n* Replace the existing built-in RCW/CCW infrastructure.\r\n* Change anything related to P/Invoke Interop.\r\n* Hide WinRT and/or COM concepts.\r\n\r\n## Outstanding questions:\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385491739\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385498872\r\n\r\n# Proposed API\r\n\r\n\u0060\u0060\u0060 CSharp\r\nnamespace System.Runtime\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Allocate memory that is associated with the \u003Cparamref name=\u0022type\u0022/\u003E and\r\n        /// will be freed if and when the \u003Csee cref=\u0022System.Type\u0022/\u003E is unloaded.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022type\u0022\u003EType associated with the allocated memory.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022size\u0022\u003EAmount of memory in bytes to allocate.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe allocated memory\u003C/returns\u003E\r\n        public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateComInterfaceFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The caller will provide an IUnknown Vtable.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is useful in scenarios when the caller has no need to rely on an IUnknown instance\r\n        /// that is used when running managed code is not possible (i.e. during a GC). In traditional\r\n        /// COM scenarios this is common, but scenarios involving \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EReference Tracker hosting\u003C/see\u003E\r\n        /// calling of the IUnknown API during a GC is possible.\r\n        /// \u003C/remarks\u003E\r\n        CallerDefinedIUnknown = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Flag used to indicate the COM interface should implement \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EIReferenceTrackerTarget\u003C/see\u003E.\r\n        /// When this flag is passed, the resulting COM interface will have an internal implementation of IUnknown\r\n        /// and as such none should be supplied by the caller.\r\n        /// \u003C/summary\u003E\r\n        TrackerSupport = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateObjectFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicate if the supplied external COM object implements the \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetracker\u0022\u003EIReferenceTracker\u003C/see\u003E.\r\n        /// \u003C/summary\u003E\r\n        TrackerObject = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Ignore any internal caching and always create a unique instance.\r\n        /// \u003C/summary\u003E\r\n        UniqueInstance = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Class for managing wrappers of COM IUnknown types.\r\n    /// \u003C/summary\u003E\r\n    [CLSCompliant(false)]\r\n    public abstract partial class ComWrappers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Interface type and pointer to targeted VTable.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceEntry\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Interface IID.\r\n            /// \u003C/summary\u003E\r\n            public Guid IID;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Memory must have the same lifetime as the memory returned from the call to \u003Csee cref=\u0022ComputeVtables(object, CreateComInterfaceFlags, out int)\u0022/\u003E.\r\n            /// \u003C/summary\u003E\r\n            public IntPtr Vtable;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// ABI for function dispatch of a COM interface.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceDispatch\r\n        {\r\n            public IntPtr vftbl;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Given a \u003Csee cref=\u0022System.IntPtr\u0022/\u003E from a generated VTable, convert to the target type.\r\n            /// \u003C/summary\u003E\r\n            /// \u003Ctypeparam name=\u0022T\u0022\u003EDesired type.\u003C/typeparam\u003E\r\n            /// \u003Cparam name=\u0022dispatchPtr\u0022\u003EPointer supplied to VTable function entry.\u003C/param\u003E\r\n            /// \u003Creturns\u003EInstance of type associated with dispatched function call.\u003C/returns\u003E\r\n            public static unsafe T GetInstance\u003CT\u003E(ComInterfaceDispatch* dispatchPtr) where T : class;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create an COM representation of the supplied object that can be passed to an non-managed environment.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022instance\u0022\u003EA GC Handle to the managed object to expose outside the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to configure the generated interface.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe generated COM interface that can be passed outside the .NET runtime.\u003C/returns\u003E\r\n        public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Compute the desired VTables for \u003Cparamref name=\u0022obj\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003ETarget of the returned VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to compute VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022count\u0022\u003EThe number of elements contained in the returned memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003E\u003Csee cref=\u0022ComInterfaceEntry\u0022 /\u003E pointer containing memory for all COM interface entries.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All memory returned from this function must either be unmanaged memory, pinned managed memory, or have been\r\n        /// allocated with the \u003Csee cref=\u0022System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(Type, int)\u0022/\u003E API.\r\n        ///\r\n        /// If the interface entries cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected unsafe abstract ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the currently registered managed object or creates a new managed object and registers it.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022wrapper\u0022\u003EAn optional \u003Csee cref=\u0022object\u0022/\u003E to be used as the wrapper for the external object\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing a \u003Cparamref name=\u0022wrapper\u0022/\u003E instance means \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E\r\n        /// will not be called.\r\n        ///\r\n        /// If the \u003Cparamref name=\u0022wrapper\u0022/\u003E instance already has an associated external object a \u003Csee cref=\u0022System.NotSupportedException\u0022/\u003E will be thrown.\r\n        /// \u003C/remarks\u003E\r\n        public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object? wrapper = null);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create a managed object for the object pointed at by \u003Cparamref name=\u0022externalComObject\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the object cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected abstract object? CreateObject(IntPtr externalComObject, CreateObjectFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Called when a request is made for a collection of objects to be released.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022objects\u0022\u003ECollection of objects to release.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// The default implementation of this function throws \u003Csee cref=\u0022System.NotImplementedException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected virtual void ReleaseObjects(IEnumerable objects);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Register this class\u0027s implementation to be used as the single global instance.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This function can only be called a single time. Subsequent calls to this function will result\r\n        /// in a \u003Csee cref=\u0022System.InvalidOperationException\u0022/\u003E being thrown.\r\n        ///\r\n        /// Scenarios where the global instance may be used are:\r\n        ///  * Object tracking via the \u003Csee cref=\u0022CreateComInterfaceFlags.TrackerSupport\u0022 /\u003E and \u003Csee cref=\u0022CreateObjectFlags.TrackerObject\u0022 /\u003E flags.\r\n        ///  * Usage of COM related Marshal APIs.\r\n        /// \u003C/remarks\u003E\r\n        public void RegisterAsGlobalInstance();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the runtime provided IUnknown implementation.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022fpQueryInterface\u0022\u003EFunction pointer to QueryInterface.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpAddRef\u0022\u003EFunction pointer to AddRef.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpRelease\u0022\u003EFunction pointer to Release.\u003C/param\u003E\r\n        protected static void GetIUnknownImpl(out IntPtr fpQueryInterface, out IntPtr fpAddRef, out IntPtr fpRelease);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n# Example usage\r\n\r\nThe below example is merely for illustrative purposes. In a production ready consumption of the API many of the \u0060Marshal\u0060 APIs would not be used and the VTable layouts should be done in a static manner for optimal efficiency.\r\n\r\n\u0060\u0060\u0060CSharp\r\n[Guid(\u0022197BC142-7A71-4637-B504-894DE79C4A22\u0022)]\r\ninterface IPrint\r\n{\r\n    public void PrintInt(int i);\r\n}\r\n\r\nclass Print : IPrint\r\n{\r\n    public void PrintInt(int i)\r\n    {\r\n        Console.WriteLine($\u0022{nameof(IPrint.PrintInt)} - 0x{i:x}\u0022);\r\n    }\r\n}\r\n\r\nstruct IUnknownVftbl\r\n{\r\n    public IntPtr QueryInterface;\r\n    public IntPtr AddRef;\r\n    public IntPtr Release;\r\n}\r\n\r\nstruct IPrintVftbl\r\n{\r\n    public IUnknownVftbl IUnknownImpl;\r\n    public IntPtr PrintInt;\r\n\r\n    public delegate int _PrintInt(IntPtr thisPtr, int i);\r\n    public static _PrintInt pPrintInt = new _PrintInt(PrintIntInternal);\r\n\r\n    public static int PrintIntInternal(IntPtr dispatchPtr, int i)\r\n    {\r\n        unsafe\r\n        {\r\n            try\r\n            {\r\n                ComWrappers.ComInterfaceDispatch.GetInstance\u003CIPrint\u003E((ComWrappers.ComInterfaceDispatch*)dispatchPtr).PrintInt(i);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n            return e.HResult;\r\n            }\r\n        }\r\n\r\n        return 0; // S_OK;\r\n    }\r\n}\r\n\r\nstruct VtblPtr\r\n{\r\n    public IntPtr Vtbl;\r\n}\r\n\r\nclass IExternalObject\r\n{\r\n    private struct IExternalObjectVftbl\r\n    {\r\n        public IntPtr QueryInterface;\r\n        public _AddRef AddRef;\r\n        public _Release Release;\r\n        public _AddObjectRef AddObjectRef;\r\n        public _RemoveObjectRef DropObjectRef;\r\n    }\r\n\r\n    private delegate int _AddRef(IntPtr This);\r\n    private delegate int _Release(IntPtr This);\r\n    private delegate int _AddObjectRef(IntPtr This, IntPtr o);\r\n    private delegate int _RemoveObjectRef(IntPtr This, IntPtr o);\r\n\r\n    private readonly IntPtr instance;\r\n    private readonly IExternalObjectVftbl vtable;\r\n\r\n    public IExternalObject(IntPtr instance)\r\n    {\r\n        var inst = Marshal.PtrToStructure\u003CVtblPtr\u003E(instance);\r\n        this.vtable = Marshal.PtrToStructure\u003CIExternalObjectVftbl\u003E(inst.Vtbl);\r\n        this.instance = instance;\r\n    }\r\n\r\n    ~IExternalObject()\r\n    {\r\n        if (this.instance != IntPtr.Zero)\r\n        {\r\n            this.vtable.Release(this.instance);\r\n        }\r\n    }\r\n\r\n    public void AddObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n\r\n    public void DropObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n}\r\n\r\nclass MyComWrappers : ComWrappers\r\n{\r\n    protected unsafe override ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count)\r\n    {\r\n        IntPtr fpQueryInteface = default;\r\n        IntPtr fpAddRef = default;\r\n        IntPtr fpRelease = default;\r\n        ComWrappers.GetIUnknownImpl(out fpQueryInteface, out fpAddRef, out fpRelease);\r\n\r\n        var tables = new List\u003CComInterfaceEntry\u003E();\r\n\r\n        var vtbl1 = new IPrintVftbl()\r\n        {\r\n            IUnknownImpl = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            },\r\n            PrintInt = Marshal.GetFunctionPointerForDelegate(IPrintVftbl.pPrintInt)\r\n        };\r\n        var vtblRaw1 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IPrintVftbl), sizeof(IPrintVftbl));\r\n        Marshal.StructureToPtr(vtbl1, vtblRaw1, false);\r\n        tables.Add(new ComInterfaceEntry { IID = IID_IPrint, Vtable = vtblRaw1 });\r\n\r\n        if (flags.HasFlag(CreateComInterfaceFlags.CallerDefinedIUnknown))\r\n        {\r\n            var vtbl2 = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            };\r\n            var vtblRaw2 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IUnknownVftbl), sizeof(IUnknownVftbl));\r\n            Marshal.StructureToPtr(vtbl2, vtblRaw2, false);\r\n            tables.Add(new ComInterfaceEntry { IID = IID_IUnknown, Vtable = vtblRaw2 });\r\n        }\r\n\r\n        // Return pointer to memory containing ComInterfaceEntry collection\r\n    }\r\n\r\n    protected override object CreateObject(IntPtr externalComObject, CreateObjectFlags flags)\r\n    {\r\n        return new IExternalObject(externalComObject);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n/cc @jkotas @Scottj1s @dunhor @jkoritzinsky @davidwrighton @terrajobst @tannergooding @jeffschwMSFT ",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-windows",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#34717",
            "CreatedAt": "2020-04-08T22:07:34+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "ComWrappers should support ICustomQueryInterface for Managed Object Wrappers",
            "DescriptionMarkdown": "The ComWrappers API should support falling back to [\u0060ICustomQueryInterface\u0060](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.icustomqueryinterface) if the managed object wrapper didn\u0027t supply a VTable for the requested IID.\r\n\r\n/cc @jkoritzinsky @scottj1s",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35530",
            "CreatedAt": "2020-04-27T18:38:50+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "ComWrappers API does not provide a mechanism to identify when it is called from old-style APIs",
            "DescriptionMarkdown": "In #33485, we wired up the ComWrappers API to be called first-chance from the Marshal APIs and from the IL stub marshalers. This has started to prove a problem for CsWinRT, since there\u0027s no way to determine when to use the ComWrappers\u0027 implementation and when to use the runtime\u0027s built-in APIs.\r\n\r\nIn particular, the CsWinRT ComWrappers implementation of \u0060ComputeVtables\u0060 has to be able to handle all types, including types that do not implement any WinRT APIs, to correctly implement WinRT semantics for WinUI. Additionally, since WinUI depends on the reference tracking support from ComWrappers, the CsWinRT ComWrappers implementation has to be registered as the global implementation. As a result, if someone such as WPF calls \u0060Marshal.GetIUnknownForObject\u0060, this call will go down the ComWrappers route first if the Windows SDK is also being used. WPF is expecting to get the built-in runtime-implemented CCWs, but by default CsWinRT would provide one instead.\r\n\r\nThis proves to be a problem when the user (either WPF or someone else directly using the Marshal APIs or using COM objects in P/Invoke signatures) is trying to pass a managed implementations of COM APIs to native. CsWinRT\u0027s ComWrappers only support the WinRT model (as it should be, they shouldn\u0027t have to completely re-implement the runtime\u0027s CCW/RCW implementation), so they would create a WinRT CCW of the managed object.\r\n\r\nWe could attempt to use a heuristic in the CsWinRT ComWrappers implementation to determine whether to use the ComWrappers or just return null and fall back, but that heuristic may be tricky or downright impossible to get exactly right. I\u0027ve included an example below where the heuristic is extremely difficult if not impossible:\r\n\r\nLet\u0027s take a class \u0060class Foo : System.Collections.IEnumerable { ... }\u0060 and a P/Invoke signature \u0060void Bar(System.Collections.IEnumerable ienum)\u0060. In the WinRT world, we would want to treat this as a \u0060Microsoft.UI.Xaml.Interop.IBindableIterable\u0060. However, the built-in CCW system would generate an \u0060IDispatch\u0060 implementation that exposes the \u0060GetEnumerator\u0060 method as \u0060DISPID_NEWENUM\u0060.\r\n\r\nSince there is no way to determine from within a \u0060ComWrappers\u0060 implementation if it is being called from the \u0060Marshal\u0060 APIs or a P/Invoke marshaler (without attempting to just look up the call stack), the CsWinRT ComWrappers would never be able to know if it should marshal an instance of \u0060Foo\u0060 itself or if it should let the runtime marshal it.\r\n\r\nThere is a corresponding problem for the RCW direction, but using a heuristic of \u0022does this object implement IInspectable\u0022 works well as a heuristic for ComWrappers.\r\n\r\nThere are a few possible solutions here:\r\n- Provide an additional flag on the \u0060CreateObjectFlags\u0060 and \u0060CreateComInterfaceFlags\u0060 enumeration to denote when the ComWrappers methods are being called from the \u0060Marshal\u0060 APIs or from an IL stub.\r\n- Remove the support wiring up a ComWrappers instance as a first-chance handler for the Marshal APIs or from an IL stub.\r\n\r\nI\u0027m also open to additional ideas.\r\n\r\ncc: @AaronRobinsonMSFT @elinor-fung @jkotas ",
            "Milestone": "5.0.0",
            "Assignees": [
              "elinor-fung"
            ],
            "Labels": [
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35745",
            "CreatedAt": "2020-05-02T06:48:24+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "WeakReference and WeakReference\u003CT\u003E should continue to support IWeakReference",
            "DescriptionMarkdown": "The work implied in https://github.com/dotnet/runtime/issues/33330 indicates much of the WinRT sub-system will be removed. One area that should be retained is the support between [\u0060IWeakReference\u0060](https://docs.microsoft.com/windows/win32/api/weakreference/nn-weakreference-iweakreference) and the .NET types [\u0060WeakReference\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference) and [\u0060WeakReference\u003CT\u003E\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference-1).\r\n\r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#36654",
            "CreatedAt": "2020-05-18T15:33:50+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "IDynamicInterfaceCastable interface",
            "DescriptionMarkdown": "## Background and Motivation\r\n\r\nIn the .NET Native runtime support existed for a .NET class to participate in a C-style cast when that class didn\u0027t support the cast-to type. The COM [\u0060QueryInterface()\u0060](https://docs.microsoft.com/windows/win32/com/queryinterface--navigating-in-an-object) is an example where this kind of scenario exists. In COM, the instance is represented by an opaque \u0060IUnknown\u0060 pointer and the only way to discover what is supported by the instance is to call \u0060QueryInterface()\u0060 with a \u0060GUID\u0060 representing the question of \u0022Does this instance support this type?\u0022. The answer is typically a simple \u0022yes\u0022 (\u0060S_OK\u0060) or \u0022no\u0022 (\u0060E_NOINTERFACE\u0060). If the answer is \u0022yes\u0022, a casted to instance of the type is returned, otherwise \u0060null\u0060. There are scenarios where the current instance may not have implemented this type but can provide an instance that does - this is called a tear-off.\r\n\r\nIn .NET, the metadata for a type is static and therefore if a type can\u0027t be cast to another type because it isn\u0027t in metadata that is correct. This means that a type has no reason to participate in the casting question. However, when implementing support for a COM scenario this rigidity isn\u0027t as beneficial since it may not be possible to know all the supported types on an instance. This proposal provides a way to let types provide an answer and an \u0060object\u0060 instance that does satisfy the requested type eventhough the original instance does not and still adhere to the static metadata constraints of .NET.\r\n\r\nIn .NET Native there are two mechanisms to address this problem. The first, \u0060ICastable\u0060 interface, proved to have usability issues. Usage of the \u0060ICastable\u0060 API was error prone and had a potentially catastrophic consequence if used incorrectly - silent success or an unstable runtime. The [\u0060ICastable\u0060 API][icastable_link] exists in the CoreCLR runtime but is not publicly exposed and exists only to support MCG scenarios.\r\n\r\nThe second approach was \u0060CastableObject\u0060. This approach didn\u0027t return a type but instead returned an actual \u0060object\u0060 instance to dispatch on. The \u0060CastableObject\u0060 type is an \u0060abstract\u0060 type that contained some minor state for caching purposes. This approach did require inserting a new type into the user\u0027s type hierarchy. Updating the type hierarchy and the stored state of the \u0060abstract\u0060 type made this solution more reliable, but less performant than \u0060ICastable\u0060.\r\n\r\nFor CoreCLR, the following proposal is based on lessons learned from .NET Native along with a recent C# language feature, [default interfaces](https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/), that make a modified version of the \u0060ICastable\u0060 approach easier to implement with confidence. The proposed interface followed by a usage example are described below.\r\n\r\n**Goals**\r\n\r\n- Support the [\u0060ComWrappers\u0060 API]((https://github.com/dotnet/runtime/issues/1845)) in creating C# friendly wrappers for external \u0060IUnknown\u0060 based objects.\r\n- Avoid having to call \u0060QueryInterface()\u0060 for all possible supported types when an external \u0060IUnknown\u0060 based object enters the runtime.\r\n- Support IL Linker scenarios.\r\n\r\n**Non-Goals**\r\n\r\n- Remove or alter current \u0060ICastable\u0060 scenarios.\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060CSharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Interface used to participate in a type cast failure.\r\n    /// \u003C/summary\u003E\r\n    public interface ICastableObject\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Called when an implementing class instance is cast to an interface type that\r\n        /// is not contained in the class\u0027s metadata.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022interfaceType\u0022\u003EThe interface type.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022throwIfNotFound\u0022\u003EIndicates if the function should throw an exception rather than default(RuntimeTypeHandle).\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe type that should be used to dispatch for \u003Cparamref name=\u0022interfaceType\u0022/\u003E on the current object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is called if casting this object to the given interface type would\r\n        /// otherwise fail. Casting here means the IL isinst and castclass instructions\r\n        /// in the case where they are given an interface type as the target type. This\r\n        /// function may also be called during interface dispatch.\r\n        ///\r\n        /// The returned type must be an interface type marked with the \u003Csee cref=\u0022CastableObjectImplementationAttribute\u0022/\u003E, otherwise \u003Csee cref=\u0022System. InvalidOperationException\u0022 /\u003E\r\n        /// will be thrown. When the \u003Cparamref name=\u0022throwIfNotFound\u0022 /\u003E is set to false,\r\n        /// a return value of default(RuntimeTypeHandle) is permitted. If \u003Cparamref name=\u0022throwIfNotFound\u0022 /\u003E\r\n        /// is true and default(RuntimeTypeHandle) is returned then \u003Csee cref=\u0022System.InvalidCastException\u0022 /\u003E\r\n        /// will be thrown unless an exception is thrown by the implementation.\r\n        /// \u003C/remarks\u003E\r\n        RuntimeTypeHandle GetInterfaceImplementation(RuntimeTypeHandle interfaceType, bool throwIfNotFound);\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Attribute required by any type that is returned by \u003Csee cref=\u0022ICastableObject.GetInterfaceImplementation(RuntimeTypeHandle, bool)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// This attribute is used to enforce policy in the runtime and make\r\n    /// \u003Csee cref=\u0022ICastableObject\u0022 /\u003E scenarios linker friendly.\r\n    /// \u003C/remarks\u003E\r\n    [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]\r\n    public sealed class CastableObjectImplementationAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Design notes\r\n\r\n- The default interface method itself will be called with a \u0060this\u0060 pointer that by definition should implement the enclosing type (e.g. \u0060IFooImpl\u0060) as well as any implementing types (e.g. \u0060IFoo\u0060). We will need to define the exact semantics and requirements here.\r\n- Virtual Stub Dispatch (VSD) caching.\r\n    - \u0060ICastableObject\u0060 could control casting on a per object basis, as we can easily call \u0060GetInterfaceImplementation()\u0060 at each cast opportunity.\r\n    - \u0060ICastableObject\u0060 would control the result of a dispatching on an interface at a per TYPE level. So, a given type could not use different default interface type (e.g. \u0060IFooImpl\u0060) for different instances. This would be sufficient for any plausible use of this feature for interop, but it might impact useablility for aspect oriented programming, etc. \r\n    - The end result is that a given object may or may not implement the interface, but if it does, all implementations must be the same.\r\n- By throwing an exception from the interface impl the debugger will report the exception as coming from that type. We should suggest to users of this API to utilize some debugger attributes to make everything look normal. \r\n\r\n## Usage Examples\r\n\r\nConsider the following interface and class.\r\n\r\n\u0060\u0060\u0060 CSharp\r\n\r\ninterface IFoo\r\n{\r\n    int CallMe(int i);\r\n}\r\n\r\nclass Baz\r\n{\r\n    ...\r\n}\r\n\r\nclass Bar : ICastableObject\r\n{\r\n    ...\r\n\r\n    // Call when cast is performed on an instance of Bar but the type isn\u0027t in Bar\u0027s metadata.\r\n    RuntimeTypeHandle ICastableObject.GetInterfaceImplementation(RuntimeTypeHandle interfaceType, bool throwIfNotFound)\r\n    {\r\n        Debug.Assert(interfaceType.Value != IntPtr.Zero);\r\n\r\n        if (interfaceType == typeof(IFoo).TypeHandle)\r\n            return typeof(IFooImpl).TypeHandle;\r\n        \r\n        if (throwIfNotFound)\r\n        {\r\n            var typeName = Type.GetTypeFromHandle(interfaceType).FullName;\r\n            throw new InvalidCastException($\u0022Don\u0027t support {typeName}\u0022);\r\n        }\r\n\r\n        return default;\r\n    }\r\n\r\n    // An \u0022implemented\u0022 interface instance that will handle \u0022this\u0022 of type \u0022Bar\u0022.\r\n    // Note that when this default interface implementation is called, the \u0022this\u0022 will\r\n    // be typed as a \u0022IFooImpl\u0022.\r\n    [CastableObjectImplementation]\r\n    public interface IFooImpl : IFoo\r\n    {\r\n        int IFoo.CallMe(int i)\r\n        {\r\n            // Perform desired action on the \u0022this\u0022 pointer which will be of type Bar.\r\n            //  - Cast to some other type\r\n            //  - Unsafe.As\u003CT\u003E()\r\n            //  - Table look up\r\n            //  - etc.\r\n            ...\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe following is an example of usage.\r\n\r\n\u0060\u0060\u0060CSharp\r\nBaz z = ...;\r\n\r\n// Will result in InvalidCastException being thrown.\r\nIFoo zf = (IFoo)z;\r\n\r\nBar b = ...;\r\n\r\n// However, since Bar implements ICastableObject, GetInterfaceImplementation will be called.\r\nIFoo bf = (IFoo)b;\r\n// bf is a Bar.IFooImpl with a Bar \u0027this\u0027\r\n\r\n// Will call Bar.IFooImpl.CallMe()\r\nbf.CallMe(27);\r\n\u0060\u0060\u0060\r\n\r\n## Community impact\r\n\r\n- Expose \u0060ICastable\u0060 request: https://github.com/dotnet/runtime/issues/23727\r\n- How MCG supported COM: https://github.com/dotnet/runtime/issues/10572#issuecomment-400129044\r\n- Discussion for \u0060ICastable\u0060: https://github.com/dotnet/corert/issues/4219#issuecomment-623671255\r\n- Support in \u0060ComWrappers\u0060 API: https://github.com/dotnet/runtime/issues/35929\r\n- Mono request: https://github.com/mono/mono/issues/9423\r\n\r\n\u003C!-- Links --\u003E\r\n[icastable_link]: https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ICastable.cs\r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Runtime.CompilerServices",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#32462",
            "CreatedAt": "2020-02-18T01:41:51+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "NativeCallableAttribute should be a public API",
            "DescriptionMarkdown": "**Update** This API\u0027s name has changed. See https://github.com/dotnet/runtime/issues/35433.\r\n\r\nThe [\u0060NativeCallableAttribute\u0060](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NativeCallableAttribute.cs) should be made public since it will provide a symmetrical solution with the [C# Function pointer proposal](https://github.com/dotnet/csharplang/blob/master/proposals/function-pointers.md).\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060Csharp\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Any method marked with \u003Csee cref=\u0022System.Runtime.InteropServices.NativeCallableAttribute\u0022 /\u003E can be directly called from\r\n    /// native code. The function token can be loaded to a local variable using LDFTN\r\n    /// and passed as a callback to native method.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// Methods marked with this attribute have the following restrictions:\r\n    ///   * Method must be marked \u0022static\u0022.\r\n    ///   * Must not be called from managed code.\r\n    ///   * Must only have \u003Csee href=\u0022https://docs.microsoft.com/dotnet/framework/interop/blittable-and-non-blittable-types\u0022\u003Eblittable\u003C/see\u003E arguments.\r\n    /// \u003C/remarks\u003E\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed class NativeCallableAttribute : Attribute\r\n    {\r\n        public NativeCallableAttribute();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Optional. If omitted, compiler will choose one for you.\r\n        /// \u003C/summary\u003E\r\n        public CallingConvention CallingConvention;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Optional. If omitted, then the method is native callable, but no export is emitted during AOT compilation.\r\n        /// \u003C/summary\u003E\r\n        public string? EntryPoint;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nRelated:\r\n* [C# Function pointer concerns](https://github.com/dotnet/csharplang/blob/master/proposals/function-pointers.md#nativecallableattribute).\r\n* [COM Wrappers API](https://github.com/dotnet/runtime/pull/32091).\r\n* CoreCLR tests for usage [examples](https://github.com/dotnet/runtime/blob/master/src/coreclr/tests/src/Interop/NativeCallable/NativeCallableTest.cs).\r\n\r\n/cc @jkotas @jaredpar @davidwrighton ",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#1845",
            "CreatedAt": "2020-01-17T02:01:47+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "Low level API support for RCW and CCW management",
            "DescriptionMarkdown": "Work has begun to provide support for [WinUI 3.0](https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md#winui-3). This support is expected to manifest in a way similar to the [CppWinRT](https://github.com/microsoft/cppwinrt) tool by way of a new source generation tool (e.g. CsWinRT). In order to support this new tool, APIs for integrating and coordinating with the runtime object lifetime are necessary.\r\n\r\n# Rationale and Usage\r\n\r\nThe below API surface provides a way for a third party tool to generate what are colloquially known as [Runtime Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/runtime-callable-wrapper) (RCW) and [COM Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/com-callable-wrapper) (CCW) in a way that allows safe interaction with managed object lifetime and identity.\r\n\r\nA specific example of the need for lifetime coordination is in WinRT scenarios involving UI (e.g.  WinUI 3.0) via the [\u0060IReferenceTrackerManager\u0060](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackermanager) interface.\r\n\r\n## Goals:\r\n* Enable source generation of interop code in WinRT/WinUI scenarios.\r\n* An API that generally aligns with how existing 3rd party source generators work (e.g. [SharpGenTools](https://github.com/SharpGenTools/SharpGenTools)).\r\n* Limit exposing APIs that manage lifetime in a micro way (e.g. avoid GC hooks at dangerous times).\r\n* Semantics in .NET Framework/.NET Core for WinRT scenarios should be able to be replicated.\r\n* Provide a mechanism for 3rd parties to be able to support [Reference Tracker scenarios](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/).\r\n* Ensure AOT scenarios are considered.\r\n\r\n## Non-Goals:\r\n* Replace the existing built-in RCW/CCW infrastructure.\r\n* Change anything related to P/Invoke Interop.\r\n* Hide WinRT and/or COM concepts.\r\n\r\n## Outstanding questions:\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385491739\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385498872\r\n\r\n# Proposed API\r\n\r\n\u0060\u0060\u0060 CSharp\r\nnamespace System.Runtime\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Allocate memory that is associated with the \u003Cparamref name=\u0022type\u0022/\u003E and\r\n        /// will be freed if and when the \u003Csee cref=\u0022System.Type\u0022/\u003E is unloaded.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022type\u0022\u003EType associated with the allocated memory.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022size\u0022\u003EAmount of memory in bytes to allocate.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe allocated memory\u003C/returns\u003E\r\n        public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateComInterfaceFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The caller will provide an IUnknown Vtable.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is useful in scenarios when the caller has no need to rely on an IUnknown instance\r\n        /// that is used when running managed code is not possible (i.e. during a GC). In traditional\r\n        /// COM scenarios this is common, but scenarios involving \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EReference Tracker hosting\u003C/see\u003E\r\n        /// calling of the IUnknown API during a GC is possible.\r\n        /// \u003C/remarks\u003E\r\n        CallerDefinedIUnknown = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Flag used to indicate the COM interface should implement \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EIReferenceTrackerTarget\u003C/see\u003E.\r\n        /// When this flag is passed, the resulting COM interface will have an internal implementation of IUnknown\r\n        /// and as such none should be supplied by the caller.\r\n        /// \u003C/summary\u003E\r\n        TrackerSupport = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateObjectFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicate if the supplied external COM object implements the \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetracker\u0022\u003EIReferenceTracker\u003C/see\u003E.\r\n        /// \u003C/summary\u003E\r\n        TrackerObject = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Ignore any internal caching and always create a unique instance.\r\n        /// \u003C/summary\u003E\r\n        UniqueInstance = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Class for managing wrappers of COM IUnknown types.\r\n    /// \u003C/summary\u003E\r\n    [CLSCompliant(false)]\r\n    public abstract partial class ComWrappers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Interface type and pointer to targeted VTable.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceEntry\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Interface IID.\r\n            /// \u003C/summary\u003E\r\n            public Guid IID;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Memory must have the same lifetime as the memory returned from the call to \u003Csee cref=\u0022ComputeVtables(object, CreateComInterfaceFlags, out int)\u0022/\u003E.\r\n            /// \u003C/summary\u003E\r\n            public IntPtr Vtable;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// ABI for function dispatch of a COM interface.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceDispatch\r\n        {\r\n            public IntPtr vftbl;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Given a \u003Csee cref=\u0022System.IntPtr\u0022/\u003E from a generated VTable, convert to the target type.\r\n            /// \u003C/summary\u003E\r\n            /// \u003Ctypeparam name=\u0022T\u0022\u003EDesired type.\u003C/typeparam\u003E\r\n            /// \u003Cparam name=\u0022dispatchPtr\u0022\u003EPointer supplied to VTable function entry.\u003C/param\u003E\r\n            /// \u003Creturns\u003EInstance of type associated with dispatched function call.\u003C/returns\u003E\r\n            public static unsafe T GetInstance\u003CT\u003E(ComInterfaceDispatch* dispatchPtr) where T : class;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create an COM representation of the supplied object that can be passed to an non-managed environment.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022instance\u0022\u003EA GC Handle to the managed object to expose outside the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to configure the generated interface.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe generated COM interface that can be passed outside the .NET runtime.\u003C/returns\u003E\r\n        public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Compute the desired VTables for \u003Cparamref name=\u0022obj\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003ETarget of the returned VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to compute VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022count\u0022\u003EThe number of elements contained in the returned memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003E\u003Csee cref=\u0022ComInterfaceEntry\u0022 /\u003E pointer containing memory for all COM interface entries.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All memory returned from this function must either be unmanaged memory, pinned managed memory, or have been\r\n        /// allocated with the \u003Csee cref=\u0022System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(Type, int)\u0022/\u003E API.\r\n        ///\r\n        /// If the interface entries cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected unsafe abstract ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the currently registered managed object or creates a new managed object and registers it.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022wrapper\u0022\u003EAn optional \u003Csee cref=\u0022object\u0022/\u003E to be used as the wrapper for the external object\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing a \u003Cparamref name=\u0022wrapper\u0022/\u003E instance means \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E\r\n        /// will not be called.\r\n        ///\r\n        /// If the \u003Cparamref name=\u0022wrapper\u0022/\u003E instance already has an associated external object a \u003Csee cref=\u0022System.NotSupportedException\u0022/\u003E will be thrown.\r\n        /// \u003C/remarks\u003E\r\n        public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object? wrapper = null);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create a managed object for the object pointed at by \u003Cparamref name=\u0022externalComObject\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the object cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected abstract object? CreateObject(IntPtr externalComObject, CreateObjectFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Called when a request is made for a collection of objects to be released.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022objects\u0022\u003ECollection of objects to release.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// The default implementation of this function throws \u003Csee cref=\u0022System.NotImplementedException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected virtual void ReleaseObjects(IEnumerable objects);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Register this class\u0027s implementation to be used as the single global instance.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This function can only be called a single time. Subsequent calls to this function will result\r\n        /// in a \u003Csee cref=\u0022System.InvalidOperationException\u0022/\u003E being thrown.\r\n        ///\r\n        /// Scenarios where the global instance may be used are:\r\n        ///  * Object tracking via the \u003Csee cref=\u0022CreateComInterfaceFlags.TrackerSupport\u0022 /\u003E and \u003Csee cref=\u0022CreateObjectFlags.TrackerObject\u0022 /\u003E flags.\r\n        ///  * Usage of COM related Marshal APIs.\r\n        /// \u003C/remarks\u003E\r\n        public void RegisterAsGlobalInstance();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the runtime provided IUnknown implementation.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022fpQueryInterface\u0022\u003EFunction pointer to QueryInterface.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpAddRef\u0022\u003EFunction pointer to AddRef.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpRelease\u0022\u003EFunction pointer to Release.\u003C/param\u003E\r\n        protected static void GetIUnknownImpl(out IntPtr fpQueryInterface, out IntPtr fpAddRef, out IntPtr fpRelease);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n# Example usage\r\n\r\nThe below example is merely for illustrative purposes. In a production ready consumption of the API many of the \u0060Marshal\u0060 APIs would not be used and the VTable layouts should be done in a static manner for optimal efficiency.\r\n\r\n\u0060\u0060\u0060CSharp\r\n[Guid(\u0022197BC142-7A71-4637-B504-894DE79C4A22\u0022)]\r\ninterface IPrint\r\n{\r\n    public void PrintInt(int i);\r\n}\r\n\r\nclass Print : IPrint\r\n{\r\n    public void PrintInt(int i)\r\n    {\r\n        Console.WriteLine($\u0022{nameof(IPrint.PrintInt)} - 0x{i:x}\u0022);\r\n    }\r\n}\r\n\r\nstruct IUnknownVftbl\r\n{\r\n    public IntPtr QueryInterface;\r\n    public IntPtr AddRef;\r\n    public IntPtr Release;\r\n}\r\n\r\nstruct IPrintVftbl\r\n{\r\n    public IUnknownVftbl IUnknownImpl;\r\n    public IntPtr PrintInt;\r\n\r\n    public delegate int _PrintInt(IntPtr thisPtr, int i);\r\n    public static _PrintInt pPrintInt = new _PrintInt(PrintIntInternal);\r\n\r\n    public static int PrintIntInternal(IntPtr dispatchPtr, int i)\r\n    {\r\n        unsafe\r\n        {\r\n            try\r\n            {\r\n                ComWrappers.ComInterfaceDispatch.GetInstance\u003CIPrint\u003E((ComWrappers.ComInterfaceDispatch*)dispatchPtr).PrintInt(i);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n            return e.HResult;\r\n            }\r\n        }\r\n\r\n        return 0; // S_OK;\r\n    }\r\n}\r\n\r\nstruct VtblPtr\r\n{\r\n    public IntPtr Vtbl;\r\n}\r\n\r\nclass IExternalObject\r\n{\r\n    private struct IExternalObjectVftbl\r\n    {\r\n        public IntPtr QueryInterface;\r\n        public _AddRef AddRef;\r\n        public _Release Release;\r\n        public _AddObjectRef AddObjectRef;\r\n        public _RemoveObjectRef DropObjectRef;\r\n    }\r\n\r\n    private delegate int _AddRef(IntPtr This);\r\n    private delegate int _Release(IntPtr This);\r\n    private delegate int _AddObjectRef(IntPtr This, IntPtr o);\r\n    private delegate int _RemoveObjectRef(IntPtr This, IntPtr o);\r\n\r\n    private readonly IntPtr instance;\r\n    private readonly IExternalObjectVftbl vtable;\r\n\r\n    public IExternalObject(IntPtr instance)\r\n    {\r\n        var inst = Marshal.PtrToStructure\u003CVtblPtr\u003E(instance);\r\n        this.vtable = Marshal.PtrToStructure\u003CIExternalObjectVftbl\u003E(inst.Vtbl);\r\n        this.instance = instance;\r\n    }\r\n\r\n    ~IExternalObject()\r\n    {\r\n        if (this.instance != IntPtr.Zero)\r\n        {\r\n            this.vtable.Release(this.instance);\r\n        }\r\n    }\r\n\r\n    public void AddObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n\r\n    public void DropObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n}\r\n\r\nclass MyComWrappers : ComWrappers\r\n{\r\n    protected unsafe override ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count)\r\n    {\r\n        IntPtr fpQueryInteface = default;\r\n        IntPtr fpAddRef = default;\r\n        IntPtr fpRelease = default;\r\n        ComWrappers.GetIUnknownImpl(out fpQueryInteface, out fpAddRef, out fpRelease);\r\n\r\n        var tables = new List\u003CComInterfaceEntry\u003E();\r\n\r\n        var vtbl1 = new IPrintVftbl()\r\n        {\r\n            IUnknownImpl = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            },\r\n            PrintInt = Marshal.GetFunctionPointerForDelegate(IPrintVftbl.pPrintInt)\r\n        };\r\n        var vtblRaw1 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IPrintVftbl), sizeof(IPrintVftbl));\r\n        Marshal.StructureToPtr(vtbl1, vtblRaw1, false);\r\n        tables.Add(new ComInterfaceEntry { IID = IID_IPrint, Vtable = vtblRaw1 });\r\n\r\n        if (flags.HasFlag(CreateComInterfaceFlags.CallerDefinedIUnknown))\r\n        {\r\n            var vtbl2 = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            };\r\n            var vtblRaw2 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IUnknownVftbl), sizeof(IUnknownVftbl));\r\n            Marshal.StructureToPtr(vtbl2, vtblRaw2, false);\r\n            tables.Add(new ComInterfaceEntry { IID = IID_IUnknown, Vtable = vtblRaw2 });\r\n        }\r\n\r\n        // Return pointer to memory containing ComInterfaceEntry collection\r\n    }\r\n\r\n    protected override object CreateObject(IntPtr externalComObject, CreateObjectFlags flags)\r\n    {\r\n        return new IExternalObject(externalComObject);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n/cc @jkotas @Scottj1s @dunhor @jkoritzinsky @davidwrighton @terrajobst @tannergooding @jeffschwMSFT ",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-windows",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#37",
            "CreatedAt": "2019-12-19T19:31:34+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "ObjectReference\u003CT\u003E needs to support the Dispose pattern for correct CCW lifetime",
            "DescriptionMarkdown": "To help maintain CCW lifetime across native calls, we should change \u0060WinRT.ObjectReference\u003CT\u003E\u0060 to implement the [Dispose pattern](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose) (and possibly move the release logic up to the base \u0060IObjectReference\u0060 class). This will allow us to use \u0060using()\u0060 blocks around the native calls to keep the \u0060ObjectReference\u003CT\u003E\u0060 to a CCW alive across the native call.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#49",
            "CreatedAt": "2020-01-13T21:20:11+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Provide method for projections to add \u0022default-implemented\u0022 interfaces for CCWs",
            "DescriptionMarkdown": "To match parity with the .NET projections system, CsWinRT needs to provide a way for libraries to provide implementations of native interfaces for the native wrappers of managed objects. For example, CsWinRT needs to supply 2 implementations of \u0060Windows/Microsoft.UI.Xaml.Data.ICustomPropertyProvider\u0060 (one for .NET objects, one for CCWs that wrap RCWs); however, these types don\u0027t exist without running cswinrt to generate a projection.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#61",
            "CreatedAt": "2020-02-06T23:58:44+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Marshalling Arrays of Interfaces to ABI selects the incorrect marshaler",
            "DescriptionMarkdown": "The \u0060set_abi_marshaler\u0060 method incorrectly selects the \u0060MarshalNonBlittable\u003CT\u003E\u0060 marshaler for arrays of interfaces instead of the \u0060MarshalInterface\u003CT\u003E\u0060 marshaler.\r\n\r\nThe native-\u003Emanaged direction selects the correct marshaler.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#76",
            "CreatedAt": "2020-02-14T22:09:21+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Add support for IRestrictedErrorInfo",
            "DescriptionMarkdown": "Our current usage of \u0060Marshal.ThrowExceptionForHR\u0060 doesn\u0027t support \u0060IRestrictedErrorInfo\u0060 correctly. To fully support the WinRT platform, we need to add support for \u0060IRestrictedErrorInfo\u0060, at least to a matching level as CoreCLR.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#102",
            "CreatedAt": "2020-03-27T18:18:36+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Provide ICustomPropertyProvider interface by default.",
            "DescriptionMarkdown": "The .NET runtime projection provides the ICustomPropertyProvider interface on all WinRT CCWs. CsWinRT should also provide this interface for compatibility.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#34173",
        "CreatedAt": "2020-03-26T23:55:44+00:00",
        "CreatedBy": "terrajobst",
        "IsClosed": true,
        "Title": "Work that needs to happen for .NET 5 TFMs",
        "DescriptionMarkdown": "The spec for .NET 5 TFMs can be found [here](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md).\r\n\r\n### Runtime/SDK\r\n\r\n* [x] [Ensure SDK explodes .NET 5 \u0060TargetFramework\u0060 into \u0060TargetFramework*\u0060 and \u0060TargetPlatform*\u0060 properties](https://github.com/dotnet/sdk/issues/11231)\r\n* [x] [Make the build fail when a TFM with an unsupported OS or OS version is being used](https://github.com/dotnet/sdk/issues/11232)\r\n* [x] Update RIDs for Xamarin platforms\r\n* [x] [Add preprocessor symbols for OS](https://github.com/dotnet/sdk/issues/11236)\r\n* [x] [Handle new TFMs in runtimeconfig and host](https://github.com/dotnet/runtime/issues/34033)\r\n* [x] [Produce a warning when a \u0060net5.0\u0060 project references \u0060netcoreapp3.1\u0060 (or earlier) with WPF/WinForms](https://github.com/dotnet/sdk/issues/11241)\r\n* Cut\r\n   - ~~Add shared framework for Xamarin platforms~~\r\n   - ~~Add SDK-style build support for Xamarin~~\r\n\r\n### NuGet\r\n\r\n* [x] [net5 tfm: framework precedence rules](https://github.com/nuget/Home/issues/9436)\r\n* [x] [net5 tfm: produce error when missing TPV](https://github.com/nuget/Home/issues/9441)\r\n* [x] [net5 tfm: \u0022hydrating\u0022 empty TargetPlatformVersions](https://github.com/nuget/Home/issues/9444)\r\n* [x] [net5.0 VS APIs](https://github.com/nuget/Home/issues/9650)\r\n* [x] [With multi targeted projects, NuGet should read the target framework related information from the inner build.](https://github.com/nuget/Home/issues/9756)\r\n* [ ] [NuGet pack should catch incorrect omitting of the dot in version numbers](https://github.com/nuget/Home/issues/9215)\r\n* Cut\r\n    - ~~Make NuGet understand that the existing Xamarin TFMs can be installed into the new \u0060net5.0-xxx\u0060 TFMs~~ (Xamarin is pushed to .NET 6)\r\n    - ~~Fail pack when packing equivalent TFMs like \u0060net5.0-ios\u0060 and \u0060net5.0-ios13.0\u0060~~ (this state is impossible now)\r\n    - ~~Produce a warning when a project consumes a library with a higher \u0060TargetPlatformMinVersion\u0060~~ (handled by analyzer)\r\n    - ~~[net5 tfm: TargetPlatformMinVersion in packed nuspec](https://github.com/nuget/Home/issues/9439)~~ (handled by analyzer)\r\n* Future\r\n    - [ ] [Add a TFM for Unity\u0027s DOTS profile](https://github.com/nuget/Home/issues/9347)\r\n\r\n### MSBuild\r\n\r\n* [x] [Allow TFM/TPM checks in a concise, understandable way](https://github.com/microsoft/msbuild/issues/5171)\r\n\r\n### Project System\r\n\r\n* [x] Pass the correct information to NuGet restore, specifically TFI, TFV, TPI, TPV\r\n\r\n@rainersigwald @dsplaisted @rrelyea @ericstj @ViktorHofer Please help me complete the list of items. Also, we would make sure that each item is linked to a corresponding GitHub issue.",
        "Milestone": "5.0.0",
        "Assignees": [
          "terrajobst"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "blocking-release",
            "BackgroundColor": "b60205"
          },
          {
            "Name": "tracking",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/sdk#11231",
            "CreatedAt": "2020-04-10T20:28:37+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Update Microsoft.NET.Sdk TargetFramework parsing to understand OS name and versions",
            "DescriptionMarkdown": "The parsing in Microsoft.NET.TargetFrameworkInference.targets needs to be updated to parse the \u0060TargetPlatformIdentifier\u0060 and \u0060TargetPlatformVersion\u0060 from the \u0060TargetFramework\u0060.\r\n\r\nThe existing parsing implementation (which uses string manipulation) should be replaced with calls to [new MSBuild Intrinsic functions](https://github.com/microsoft/msbuild/issues/5171) which will call the NuGet parsing APIs.\r\n\r\n[.NET 5 TargetFramework spec](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md)",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11232",
            "CreatedAt": "2020-04-10T20:33:14+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Fail build if an unsupported or unknown operating system is specified in TargetFramework",
            "DescriptionMarkdown": "If the \u0060TargetFramework\u0060 is something like \u0060net5.0-mycustomos\u0060, we should fail the build with an error that we don\u0027t know what \u0060mycustomos\u0060 is.\r\n\r\nSuggested logic:\r\n\r\n- Platform-specific targets (usually in workloads) will set \u0060TargetPlatformSupported\u0060 to true if the \u0060TargetPlatformIdentifier\u0060 is set to something they recognize and support\r\n- Base SDK will generate an error message if \u0060TargetPlatformIdentifier\u0060 is non-empty and \u0060TargetPlatformSupported\u0060 is not true\r\n\r\nIf a workload supports a given target platform, it should be responsible for generating error messages if the target platform version specified is one it doesn\u0027t support (or doesn\u0027t support in combination with the target framework version).",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11236",
            "CreatedAt": "2020-04-10T20:48:25+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Automatically define preprocessor symbols for target platforms",
            "DescriptionMarkdown": "Spec is here: https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md#preprocessor-symbols\r\n\r\nNote that this includes defining preprocessor symbols for the target platform, as well as defining preprocessor symbols for previous versions of .NET and the OS",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#34033",
            "CreatedAt": "2020-03-24T19:10:03+00:00",
            "CreatedBy": "vitek-karas",
            "IsClosed": true,
            "Title": "Usage of new TFMs in runtimeconfig and host",
            "DescriptionMarkdown": "The new set of TFMs as per the [design](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md) is relatively large as the TFM now contains not just the version of .NET but also the target OS and possibly even OS version.\r\n\r\nCurrently the SDK writes the TFM into \u0060.runtimeconfig.json\u0060 into a \u0060tfm\u0060 property. Typical \u0060.runtimeconfig.json\u0060: \r\n\u0060\u0060\u0060JSON\r\n{\r\n  \u0022runtimeOptions\u0022: {\r\n    \u0022tfm\u0022: \u0022netcoreapp3.1\u0022,\r\n    \u0022framework\u0022: {\r\n      \u0022name\u0022: \u0022Microsoft.NETCore.App\u0022,\r\n      \u0022version\u0022: \u00223.1.0\u0022\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe value comes directly from the \u0060\u003CTargetFramework\u003E\u0060 property in the project file.\r\n\r\nThe value in \u0060.runtimeconfig.json\u0060 is used only in two relatively fringe scenarios in the host:\r\n* When the host probes for shared store paths, the path is in the form of \u0060$DOTNET_SHARED_STORE/|arch|/|tfm|\u0060 where the \u0060|tfm|\u0060 is replaced by the value from the \u0060tfm\u0060 property.\r\n* When the host probes for additional paths (specified as either command line or config options) the path can contain the string \u0060|arch|/|tfm|\u0060 where it\u0027s again replaced with the value of the \u0060tfm\u0060 property.\r\n\r\nThe most common usage of these is the \u0060.runtimeconfig.dev.json\u0060 (auto-generated by SDK during \u0060dotnet build\u0060) which contains path to the user-local shared store:\r\n\u0060\u0060\u0060JSON\r\n{\r\n  \u0022runtimeOptions\u0022: {\r\n    \u0022additionalProbingPaths\u0022: [\r\n      \u0022C:\\\\Users\\\\username\\\\.dotnet\\\\store\\\\|arch|\\\\|tfm|\u0022,\r\n\u0060\u0060\u0060\r\n\r\nand then any usage of the shared store, where the folder structure on disk must match the TFM used in the configuration file.\r\n\r\nIf we keep the behavior as is, it would mean that these shared store paths would now include the full TFMs - like \u0060net5.0-windows10.0\u0060 or similar.\r\n\r\nWithout any changes the shared store may need to have multiple copies of the same file for all of the hierarchical TFMs: \u0060net5\u0060, \u0060net5.0\u0060, \u0060net5.0-windows\u0060 and \u0060net5.0-windows10\u0060 if it would server multiple apps each using slightly different but still fully compatible TFM.\r\n\r\nThe question is if the SDK should write the \u0022Simple\u0022 TFM into the \u0060.runtimeconfig.json\u0060 - in this case probably \u0060net5.0\u0060 or if the host will have to start understanding the hierarchical nature of TFMs and be able to parse them.",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Host",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11241",
            "CreatedAt": "2020-04-10T22:49:58+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Add warnings for WindowsDesktop targeting",
            "DescriptionMarkdown": "In .NET 5.0, you will need to specify the TargetPlatform of Windows in order to use Windows Forms or WPF.  You also won\u0027t need to use Microsoft.NET.Sdk.WindowsDesktop, you can just use Microsoft.NET.Sdk.  We should add appropriate warnings in the following situations:\r\n\r\n- If the WindowsDesktop SDK is used, we may want to let you know that you can use Microsoft.NET.Sdk instead.\r\n- If \u0060UseWindowsForms\u0060 or \u0060UseWPF\u0060 is true and the TargetFramework is \u0060net5.0\u0060 or higher (with no \u0060-windows\u0060), warn or error that the TargetFramework should be \u0060net5.0-windows\u0060 to use Windows Forms or WPF\r\n- If the TargetFramework is \u0060net5.0\u0060 or higher (with no \u0060-windows\u0060), and a transitive dependency brings in one of the Microsoft.NETCore.App.WindowsDesktop shared frameworks, we should do one or more of the following:\r\n  - Warn or error that \u0060-windows\u0060 should be added to the TargetFramework\r\n  - Make things work: make sure the right framework is referenced in the runtimeconfig, and adjust the TargetPlatformIdentifier if necessary.\r\n",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9436",
            "CreatedAt": "2020-04-14T21:31:04+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "Net5 TFM: Framework Precedence Rules",
            "DescriptionMarkdown": "net5 has [specific precedence rules](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md#precedences) that need to be followed. We need to implement them.",
            "Milestone": "Sprint 174 - 2020.07.27",
            "Assignees": [
              "nkolev92"
            ],
            "Labels": [
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:Backlog",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9441",
            "CreatedAt": "2020-04-14T21:50:48+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "net5 tfm: produce error when missing TPV",
            "DescriptionMarkdown": "Produce an error when a OS flavored .NET 5 TFM is consumed but the package has no TPV in either folder name of the manifest. Is this supposed to be during restore??",
            "Milestone": "Sprint 178 - 2020.10.19",
            "Assignees": [
              "zkat"
            ],
            "Labels": [
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:Backlog",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9444",
            "CreatedAt": "2020-04-15T00:47:14+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "net5 tfm: \u0022hydrating\u0022 empty TargetPlatformVersions",
            "DescriptionMarkdown": "NuGet itself doesn\u0027t have the information it needs in order to understand what version \u0060net5.0-ios\u0060 and such might mean, but omitting versions is an important part of this feature.\r\n\r\nAfter discussions with the dotnet and msbuild teams, my understanding is that they will \u0022fill in\u0022 the \u0060NuGetFramework\u0060 instances with the actual version using some API call that\u0027s yet to be determined (or, preferably, hand us a new one, so we can keep \u0060NuGetFramework\u0060 immutable).",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Functionality:Restore",
                "BackgroundColor": "4be6f4"
              },
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Partner:MSBuild",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:Backlog",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9650",
            "CreatedAt": "2020-06-05T19:45:21+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "net5.0 VS APIs",
            "DescriptionMarkdown": "Because of the addition of a platform component to .NET tfms since 5.0 (https://github.com/NuGet/NuGet.Client/pull/3339), any APIs relying on \u0060FrameworkName\u0060 have become mostly incompatible with net5.0.\r\n\r\nIn particular, the VsFrameworkCompatibility APIs rely on these objects. We need to come up with guidance for customers who can\u0027t use the extensibility framework APIs to work around this.\r\n\r\nWe also need to figure out the impact of this change on folks who might be using this.",
            "Milestone": "Sprint 175 - 2020.08.17",
            "Assignees": [
              "zivkan"
            ],
            "Labels": [
              {
                "Name": "Area:Versioning",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "Functionality:SDK",
                "BackgroundColor": "4be6f4"
              },
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Product:VS.Client",
                "BackgroundColor": "e2a25d"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9756",
            "CreatedAt": "2020-07-06T22:54:17+00:00",
            "CreatedBy": "nkolev92",
            "IsClosed": true,
            "Title": "With multi targeted projects, NuGet should read the target framework related information from the inner build. ",
            "DescriptionMarkdown": "Currently in command line scenarios NuGet reads the target framework information in the outer build. \r\nThat is incorrect because the the contract is that we should depend on on TargetFrameworkIdentifier and the like properties. \r\nWe do that here: https://github.com/NuGet/NuGet.Client/blob/bd482514a87a0085f8eb8603842ee1cb3ca5f277/src/NuGet.Core/NuGet.Build.Tasks/NuGet.targets#L500-L526\r\n\r\nThis task is a blocker for https://github.com/NuGet/Home/issues/5154. \r\n\r\nAn incomplete list of things that need done are:\r\n\r\n* In command line scenarios, read the framework in the inner build (this should allow us to read OS Version for example). \r\n* In VS scenarios, modify the VSSOlutionREstoreService to read the information from the properties back instead of the TargetFrameworks value. \r\n* Reflect all of the changes in the assets file (not sure if we\u0027ll need any). \r\n\r\n- [ ] Commandline restore (nuget.exe, msbuild.exe dotnet.exe).\r\n- [ ] Commandline Static Graph restore.\r\n- [ ] VS restore",
            "Milestone": "Sprint 174 - 2020.07.27",
            "Assignees": [
              "nkolev92",
              "zivkan"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "3E4B9E"
              },
              {
                "Name": "Functionality:Restore",
                "BackgroundColor": "4be6f4"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:Bug",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 1,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9215",
            "CreatedAt": "2020-02-24T21:12:37+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": true,
            "Title": "NuGet pack should catch incorrect omitting of the dot in version numbers",
            "DescriptionMarkdown": "For .NET 5, [we\u0027re going](https://github.com/dotnet/designs/pull/92) to reuse the existing \u0060net\u0060 moniker. Due to our new versioning scheme (fixed schedule, major bump every year) we\u0027re only five years away from .NET 10. Developers might accidentally say \u0060net10\u0060 when they really meant \u0060net10.0\u0060. We\u0027re planning to follow in the footsteps of .NET Core where project files will generally use a dot, even when it\u0027s not necessary (e.g. \u0060net5.0\u0060) but of course this won\u0027t prevent humans from dropping the \u0060.0\u0060 either inadvertently or for aesthetics.\r\n\r\nIt was [suggested](https://github.com/dotnet/designs/pull/92#discussion_r383463597) to handle this as part of NuGet pack.\r\n\r\nThere are several ways to deal with that:\r\n\r\n1. Generally warn when a dot is missing\r\n2. Only warn on when the TFM is \u003E= \u0060net5.0\u0060 (regardless of whether there is an OS flavor or not)\r\n\r\nThe (1) is more correct but will cause a lot of noise, especially in .NET Framework projects where the ambiguity is irrelevant as the platform will remain at 4.x forever. So my preference would be something more targeted. Not sure (2) is the best way to address that but it seems to hit the sweet spot.",
            "Milestone": "Sprint 177 - 2020.09.28",
            "Assignees": [
              "zkat"
            ],
            "Labels": [
              {
                "Name": "Area:NewFrameworks",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "Pipeline:In Progress",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9347",
            "CreatedAt": "2020-03-26T12:07:11+00:00",
            "CreatedBy": "joshpeterson",
            "IsClosed": false,
            "Title": "Add a TFM for Unity\u0027s DOTS profile",
            "DescriptionMarkdown": "At Unity, we would like to explore the possibility of having a new target framework moniker for a very small base class library profile that Unity will use for some of its products.\r\n\r\nThis profile will focus on a few principles:\r\n* Small code size\r\n* No support for reflection\r\n* Focus on value types\r\n* Limited GC allocations\r\n* Limited use of exceptions\r\n* Limited use of virtual methods\r\n\r\nWe would like to make this profile available on NuGet so that it can be used in .csproj files to allow good IDE integration and to allow developers to write libraries using it.\r\n\r\nThis profile will be a proper subset for .NET Standard 2.0, and later a proper subset of .NET 5.\r\n\r\nInitially, I\u0027ll propose the name \u0022unity2.0-dots\u0022, to indicate that it is a proper subset of .NET Standard 2.0.\r\n\r\nLet\u0027s discuss whether or not this is a good idea, and if it something that can be implemented.\r\n\r\n",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Area:NewFrameworks",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:In Progress",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Resolution:BlockedByExternal",
                "BackgroundColor": "006b75"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/msbuild#5171",
            "CreatedAt": "2020-03-10T19:31:12+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": true,
            "Title": "Allow TFM/TPM checks in a concise, understandable way",
            "DescriptionMarkdown": "As part of the spec for the [.NET 5 TFM work](https://github.com/dotnet/designs/pull/92) we identified an issue with TFM checks in conditions.\r\n\r\n\u003Cdetails\u003E\r\n\u003Csummary\u003E\r\nBackground on MSBuild evaluation\r\n\u003C/summary\u003E\r\n\r\nIn SDK-style projects there are two kinds of MSBuild files that are automatically included into each project:\r\n\r\n* \u0060*.props\u0060: These files are included at the top of the user\u0027s project file and are used to define a set of default properties that the user\u0027s project file can use.\r\n\r\n* \u0060*.targets\u0060. These files are included at the bottom of the user\u0027s project file, usually meant to define build targets and additional properties/items that need to depend on properties defined by the user.\r\n\r\nFurthermore, MSBuild has a multi-pass evaluation model where properties are evaluated before items.\r\n\r\nWhy is all of this important? Because it controls which properties the user can rely on in their project file.\r\n\r\nOften, a user wants to express a condition like \u0022include this file if you\u0027re compiling for .NET 5 or higher\u0022. Logically one would like to express it like this:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CItemGroup Condition=\u0022\u0027$(TargetFramework)\u0027 \u003E= \u0027net5.0\u0027\u0060\u0022\u003E\r\n\u0060\u0060\u0060\r\n\r\nbut this doesn\u0027t work because that would be a string comparison, not a version comparison. Instead, the user has to write it like this:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CItemGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027 AND \u0027$(TargetFrameworkVersion)\u0027 \u003E= \u00273.0\u0027\u0022\u003E\r\n\u0060\u0060\u0060\r\n\r\nThis works for conditions on item groups because they are evaluated after properties. Since the user\u0027s project file defines the \u0060TargetFramework\u0060 property, the SDK logic that expands it into the other properties such as \u0060TargetFrameworkIdentifier\u0060 and \u0060TargetFrameworkVersion\u0060 has to live in \u0060*.targets\u0060, i.e. at the bottom of the project file. That means these automatically expanded properties aren\u0027t available for the user when defining other properties. This happens to work for items because items are evaluated after all properties are evaluated.\r\n\u003C/details\u003E\r\n\r\nDue to MSBuild evaluation order the user cannot define properties like this:\r\n\r\n\u0060\u0060\u0060XML\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFrameworks\u003Enetstandard2.0;netcoreapp3.1\u003C/TargetFramework\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETStandard\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome .NET Standard specific value\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome .NET Core specific value\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\nIn the past, we\u0027ve seen people working this around by using string processing functions against the \u0060TargetFramework\u0060 property, which is less than ideal.\r\n\r\n### Option using attributes\r\n\r\nIdeally, we\u0027d expose functionality such that the user can do version checks:\r\n\r\n\u0060\u0060\u0060XML\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFrameworks\u003Enetstandard2.0;netcoreapp3.1\u003C/TargetFramework\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetFramework=\u0022netstandard\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all versions of .NET Standard\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetFramework=\u0022\u003E=netcoreapp2.0\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to .NET Core 2.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetFramework=\u0022==net5.0-ios13.0\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that only applies to .NET 5 \u002B iOS 13.0\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetPlatform=\u0022windows\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all version of Windows\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetPlatform=\u0022\u003E=ios-12.0\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to iOS 12.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\nThe idea is:\r\n\r\n* Property groups, properties, and item groups get new attributes \u0060TargetFramework\u0060 and \u0060TargetPlatform\u0060.\r\n* The value can be prefixed with an optional conditional operator \u0060==\u0060, \u0060!=\u0060, \u0060\u003C\u0060, \u0060\u003C=\u0060, \u0060\u003E\u0060, and \u0060\u003E=\u0060. If the operator is omitted, \u0060==\u0060 is assumed.\r\n* \u0060TargetFramework\u0060 supports comparisons with a friendly TFM name. This can include an OS flavor for symmetry. If the \u0060TargetFramework\u0060 property includes an OS flavor but the attribute doesn\u0027t, the comparison only applies to the TFM without the OS flavor. In other words a condition of \u0060TargetFramework=\u0022\u003E=net5.0\u0022\u0060 will result in \u0060true\u0060 if the project targets \u0060net5.0\u0060, \u0060net6.0\u0060, as well as \u0060net6.0-android12.0\u0060.\r\n\r\n### Option via new syntax\r\n\r\nWe could also invent new syntax that allows parsing of constitutes like this:\r\n\r\n\u0060\u0060\u0060XML\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFrameworks\u003Enetstandard2.0;netcoreapp3.1\u003C/TargetFramework\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Identifier)==\u0027netstandard\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all versions of .NET Standard\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Name)\u003E=\u0027netcoreapp2.0\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to .NET Core 2.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Name)==\u0027net5.0-ios13.0\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that only applies to .NET 5 \u002B iOS 13.0\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Platform)==\u0027windows\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all version of Windows\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Platform)\u003E=\u0027ios-12.0\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to iOS 12.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\n### Option via functions\r\n\r\nWe could also just define new intrinsic functions on some type, but this will make using them a mouthful:\r\n\r\n\u0060\u0060\u0060XML\r\n  \u003CPropertyGroup Condition=\u0022\u0060\u0027$([MSBuild]::TargetFrameworkIdentifier($(TargetFramework)))\u0027 == \u0027.NETStandard\u0027\u0060\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all versions of .NET Standard\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0060\u0027$([MSBuild]::IsTargetFrameworkOrLater($(TargetFramework)))\u0027, \u0027net5.0\u0027))\u0060\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to .NET 5 or later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0060\u0027$([MSBuild]::IsTargetPlatformOrLater($(TargetFramework)))\u0027, \u0027ios12.0\u0027))\u0060\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to iOS 12 or later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u0060\u0060\u0060\r\n\r\nI am not married to any of these ideas; I\u0027m just spitballing here. Thoughts?",
            "Milestone": ".NET 5",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [
              {
                "Name": ".NET Core",
                "BackgroundColor": "512BD4"
              },
              {
                "Name": "Area: Language",
                "BackgroundColor": "5319e7"
              },
              {
                "Name": "Needs Design",
                "BackgroundColor": "006b75"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#33308",
        "CreatedAt": "2020-03-06T22:28:08+00:00",
        "CreatedBy": "BruceForstall",
        "IsClosed": true,
        "Title": "Optimize library code using arm64 intrinsics",
        "DescriptionMarkdown": "The following classes/functions in the libraries have Intel x86/x64 intrinsics usage. These are where \u0060_ISA_.IsSupported()\u0060 is called. This information was collected manually and might not be complete. Some of these function names represent many overloads. There are some vectorized helper methods not shown here -- where a function calls \u0060IsSupported\u0060 and then calls a specific helper function to do the actual work, such as for SSE2 or AVX2 specifically. There are other cases where \u0060Vector\u003CT\u003E\u0060 is used, but arm64 already supports that (it should be verified that the arm64 \u0060Vector\u003CT\u003E\u0060 code is complete and performant).\r\n\r\nWhen each of these has added an arm64-specific intrinsics optimization, it should be \u0022checked off\u0022.\r\n\r\nThe sections below are ordered in the presumed priority order that they should be implemented in. (There is no assumed priority order for the individual functions in each section.)\r\n\r\nIt is expected that \u0060System.Collections.BitArray\u0060, \u0060System.Numerics\u0060, and \u0060System.SpanHelpers\u0060 will be \u0022arm64 intrinsi-fied\u0022 for .NET 5. If possible, \u0060System.Buffers\u0060 and \u0060System.Text\u0060 will as well, but that is not considered required.\r\n\r\n# System.Collections.BitArray https://github.com/dotnet/runtime/issues/33309\r\n\r\n- [x] System.Collections.BitArray - constructor\r\n- [x] System.Collections.BitArray.And()\r\n- [x] System.Collections.BitArray.Or()\r\n- [x] System.Collections.BitArray.Xor()\r\n- [x] System.Collections.BitArray.Not()\r\n- [x] System.Collections.BitArray.CopyTo()\r\n\r\n# System.Runtime.Intrinsics https://github.com/dotnet/runtime/issues/33496\r\n\r\n## Vector64\r\n- [x] As\u003CT, U\u003E()\r\n- [x] AsInt64\u003CT\u003E()\r\n- [x] AsUInt64\u003CT\u003E()\r\n- [x] AsDouble\u003CT\u003E()\r\n- [x] CreateScalarUnsafe(int value);\r\n- [x] CreateScalarUnsafe(uint value);\r\n- [x] CreateScalarUnsafe(float value);\r\n- [x] CreateScalarUnsafe(byte value);\r\n- [x] CreateScalarUnsafe(sbyte value);\r\n- [x] CreateScalarUnsafe(short value);\r\n- [x] CreateScalarUnsafe(ushort value);\r\n- [x] CreateScalar(uint)\r\n- [x] CreateScalar(float)\r\n- [x] CreateScalar(sbyte)\r\n- [x] CreateScalar(ushort)\r\n- [x] CreateScalar(short)\r\n- [x] CreateScalar(byte)\r\n- [x] CreateScalar(int)\r\n- [x] Create(sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte)\r\n- [x] Create(byte, byte, byte, byte, byte, byte, byte, byte)\r\n- [x] Create(ushort, ushort, ushort, ushort)\r\n- [x] Create(short, short, short, short)\r\n- [x] Create(float, float)\r\n- [x] Create(int, int)\r\n- [x] Create(ulong)\r\n- [x] Create(uint)\r\n- [x] Create(uint, uint)\r\n- [x] Create(float)\r\n- [x] Create(sbyte)\r\n- [x] Create(long)\r\n- [x] Create(int)\r\n- [x] Create(short)\r\n- [x] Create(double)\r\n- [x] Create(byte)\r\n- [x] Create(ushort)\r\n- [x] GetElement(int index)\r\n- [x] ToScalar()\r\n- [x] ToVector128\u003CT\u003E()\r\n- [x] ToVector128Unsafe\u003CT\u003E()\r\n- [x] WithElement\u003CT\u003E(Vector64\u003CT\u003E, int, T)\r\n\r\n## Vector128\r\n- [x] As\u003CT, U\u003E()\r\n- [x] AsVector\u003CT\u003E()\r\n- [x] AsVector4(Vector128\u003Cfloat\u003E)\r\n- [x] AsVector128(Vector\u003CT\u003E)\r\n- [x] AsVector128(Vector4)\r\n- [x] CreateScalarUnsafe(int value);\r\n- [x] CreateScalarUnsafe(uint value);\r\n- [x] CreateScalarUnsafe(float value);\r\n- [x] CreateScalarUnsafe(long value);\r\n- [x] CreateScalarUnsafe(ulong value);\r\n- [x] CreateScalarUnsafe(double value);\r\n- [x] CreateScalarUnsafe(byte value);\r\n- [x] CreateScalarUnsafe(sbyte value);\r\n- [x] CreateScalarUnsafe(short value);\r\n- [x] CreateScalarUnsafe(ushort value);\r\n- [x] CreateScalar(ulong)\r\n- [x] CreateScalar(uint)\r\n- [x] CreateScalar(ushort)\r\n- [x] CreateScalar(sbyte)\r\n- [x] CreateScalar(float)\r\n- [x] CreateScalar(int)\r\n- [x] CreateScalar(short)\r\n- [x] CreateScalar(double)\r\n- [x] CreateScalar(byte)\r\n- [x] CreateScalar(long)\r\n- [x] Create(sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte)\r\n- [x] Create(byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte)\r\n- [x] Create(ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort)\r\n- [x] Create(short, short, short, short, short, short, short, short)\r\n- [x] Create(uint, uint, uint, uint)\r\n- [x] Create(float, float, float, float)\r\n- [x] Create(int, int, int, int)\r\n- [x] Create(ulong, ulong)\r\n- [x] Create(Vector64\u003Culong\u003E, Vector64\u003Culong\u003E)\r\n- [x] Create(Vector64\u003Cuint\u003E, Vector64\u003Cuint\u003E)\r\n- [x] Create(Vector64\u003Cfloat\u003E, Vector64\u003Cfloat\u003E)\r\n- [x] Create(Vector64\u003Csbyte\u003E, Vector64\u003Csbyte\u003E)\r\n- [x] Create(Vector64\u003Clong\u003E, Vector64\u003Clong\u003E)\r\n- [x] Create(Vector64\u003Cint\u003E, Vector64\u003Cint\u003E)\r\n- [x] Create(Vector64\u003Cushort\u003E, Vector64\u003Cushort\u003E)\r\n- [x] Create(Vector64\u003Cdouble\u003E, Vector64\u003Cdouble\u003E)\r\n- [x] Create(byte)\r\n- [x] Create(double)\r\n- [x] Create(short)\r\n- [x] Create(int)\r\n- [x] Create(long)\r\n- [x] Create(Vector64\u003Cshort\u003E, Vector64\u003Cshort\u003E)\r\n- [x] Create(float)\r\n- [x] Create(sbyte)\r\n- [x] Create(uint)\r\n- [x] Create(ulong)\r\n- [x] Create(double, double)\r\n- [x] Create(long, long)\r\n- [x] Create(Vector64\u003Cbyte\u003E, Vector64\u003Cbyte\u003E)\r\n- [x] Create(ushort)\r\n- [x] GetElement(int index)\r\n- [x] GetLower\u003CT\u003E()\r\n- [x] GetUpper\u003CT\u003E()\r\n- [x] WithElement\u003CT\u003E(Vector128\u003CT\u003E, int, T)\r\n- [x] WithLower\u003CT\u003E(Vector64\u003CT\u003E)\r\n- [x] WithUpper\u003CT\u003E(Vector64\u003CT\u003E)\r\n- [x] ToScalar()\r\n\r\n## Vector256\r\n- [x] Software fallback\r\n\r\n# System.Numerics\r\n\r\n## System.Numerics.BitOperations https://github.com/dotnet/runtime/issues/33495\r\n\r\n- [x] System.Numerics.BitOperations.LeadingZeroCount()\r\n- [x] System.Numerics.BitOperations.Log2()\r\n- [x] System.Numerics.BitOperations.PopCount()\r\n- [x] System.Numerics.BitOperations.TrailingZeroCount()\r\n\r\n## System.Numerics.Matrix4x4 #33565\r\n\r\n- [x] System.Numerics.Matrix4x4.Transpose()\r\n- [x] System.Numerics.Matrix4x4.Lerp()\r\n- [x] System.Numerics.Matrix4x4.operator-()\r\n- [x] System.Numerics.Matrix4x4.operator\u002B()\r\n- [x] System.Numerics.Matrix4x4.operator*()\r\n- [x] System.Numerics.Matrix4x4.operator==()\r\n- [x] System.Numerics.Matrix4x4.operator!=()\r\n\r\n# System.SpanHelpers #33707\r\n \r\n- [x] System.SpanHelpers.IndexOf(byte)\r\n- [x] System.SpanHelpers.IndexOf(char)\r\n- [x] System.SpanHelpers.IndexOfAny(byte)\r\n~[ ] System.SpanHelpers.SequenceCompareTo(byte)~  (SIMD vector implementation is fast enough)\r\n~[ ] System.SpanHelpers.SequenceEqual(byte)~ (SIMD vector implementation is fast enough)\r\n~[ ] System.SpanHelpers.LocateFirstFoundByte()~ (Only used by SIMD version of \u0060IndexOf\u0060 and \u0060IndexOfAny\u0060 which are already optimized by ARM64 intrinsics)\r\n\r\n# System.Buffers #35033\r\n*(Not completed in 5.0.0; moved to 6.0.0)*\r\n\r\n- [ ] System.Buffers.Text.Base64.DecodeFromUtf8()\r\n- [ ] System.Buffers.Text.Base64.EncodeToUtf8()\r\n\r\n# System.Text\r\n\r\n## System.Text.ASCIIUtility #35034\r\n \r\n- [x] System.Text.ASCIIUtility.GetIndexOfFirstNonAsciiByte()\r\n- [ ] System.Text.ASCIIUtility.GetIndexOfFirstNonAsciiChar() - *(Not completed in 5.0.0; moved to 6.0.0)* - PR #39507 \r\n- [x] System.Text.ASCIIUtility.NarrowFourUtf16CharsToAsciiAndWriteToBuffer()\r\n- [ ] System.Text.ASCIIUtility.NarrowUtf16ToAscii() - *(Not completed in 5.0.0; moved to 6.0.0)* - PR #39509\r\n- [x] System.Text.ASCIIUtility.WidenAsciiToUtf16()\r\n- [x] System.Text.ASCIIUtility.WidenFourAsciiBytesToUtf16AndWriteToBuffer()\r\n- [x] System.Text.ASCIIUtility.CountNumberOfLeadingAsciiBytesFromUInt32WithSomeNonAsciiData()\r\n\r\n## System.Text.Unicode #35035\r\n\r\n- [x] System.Text.Unicode.Utf16Utility.GetPointerToFirstInvalidChar()\r\n- [x] System.Text.Unicode.Utf8Utility.TranscodeToUtf8()\r\n- [x] System.Text.Unicode.Utf8Utility.GetPointerToFirstInvalidByte()\r\n\r\n## System.Text.Encodings.Web #35036\r\n\r\n- [x] System.Text.Encodings.Web.DefaultJavaScriptEncoder.FindFirstCharacterToEncodeUtf8()\r\n- [x] System.Text.Encodings.Web.DefaultJavaScriptEncoderBasicLatin.FindFirstCharacterToEncode()\r\n- [x] System.Text.Encodings.Web.DefaultJavaScriptEncoderBasicLatin.FindFirstCharacterToEncodeUtf8()\r\n- [x] System.Text.Encodings.Web.TextEncoder.FindFirstCharacterToEncodeUtf8()\r\n- [x] System.Text.Encodings.Web.UnsafeRelaxedJavaScriptEncoder.WillEncode()\r\n- [x] System.Text.Encodings.Web.UnsafeRelaxedJavaScriptEncoder.FindFirstCharacterToEncodeUtf8()\r\n",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "arch-arm64",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "up-for-grabs",
            "BackgroundColor": "23ef90"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#39507",
            "CreatedAt": "2020-07-17T08:15:30+00:00",
            "CreatedBy": "pgovind",
            "IsClosed": false,
            "Title": "Get index of first non ascii char",
            "DescriptionMarkdown": "I think this is ready and can be reviewed now. \r\n\r\nImplements GetIndexOfFirstNonAsciiChar from #35034\r\n\r\nUpdated Perf:\r\n\u0060\u0060\u0060\r\n| Faster                                                                 | base/diff | Base Median (ns) | Diff Median (ns) | Modality|\r\n| ---------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| -------- |\r\n| System.Text.Experimental.Perf.IsNormalized_GetIndexOfFirstNonAsciiChar |      1.40 |        111784.29 |         79682.34 |         |\r\n\u0060\u0060\u0060",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Runtime.Intrinsics",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#39509",
            "CreatedAt": "2020-07-17T08:22:31+00:00",
            "CreatedBy": "pgovind",
            "IsClosed": false,
            "Title": "Narrow utf16 to ascii",
            "DescriptionMarkdown": "This is ready for review now. \r\n\r\nNOTE: There is a bug here somewhere, but I can\u0027t seem to find it, so I\u0027d appreciate another pair of eyes in this code. When I try to test this on WSL2, I get an error saying \u0022Can\u0027t find file xunit.console.deps.json\u0022 when that file does in fact exist. The real error is that the xunit infra itself calls into the method being modified here and **something** goes wrong (maybe marshalling the path from \u0060string\u0060 to native also uses this code? I\u0027m not sure). AFAICT the changes are right.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Runtime.Intrinsics",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#32969",
        "CreatedAt": "2020-02-28T19:13:16+00:00",
        "CreatedBy": "AndyAyersMS",
        "IsClosed": true,
        "Title": "Implement simple version of On Stack Replacement (OSR)",
        "DescriptionMarkdown": "Add support to runtime and jit to allow switching from unoptimized to\r\noptimized code for a method while the method has active stack frames.\r\n\r\nDetails in the included document.",
        "Milestone": null,
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-CodeGen-coreclr",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#31895",
        "CreatedAt": "2020-02-06T23:56:21+00:00",
        "CreatedBy": "steveharter",
        "IsClosed": true,
        "Title": "System.Reflection and S.R.Emit roadmap for 5.0 [WIP]",
        "DescriptionMarkdown": "_[Work in Progress]_\r\n\r\nTo help with priority discussions, this issue is tracking design and functional issues.\r\n\r\nIn general, the issues fall into the following buckets:\r\n- Design \\ roadmap\r\n- Features (large API additions to smaller functional features)\r\n- Performance improvements\r\n- Bugs (crashes, inconsistencies, ...)\r\n\r\n# Areas of focus\r\n1) Determine Reflection.Emit roadmap and usage scenarios.\r\n2) Unblock .NET Framework migration scenarios.\r\n3) Support other higher-level 5.0 initiatives (impact here TBD).\r\n4) Improve quality by fixing bugs and increasing performance as necessary.\r\n\r\n# Current Issues\r\n### 5.0 Open Issues\r\nCurrently there are ~43 open issues for 5.0\r\n[System.Reflection 5.0](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection\u002Bmilestone%3A5.0)\r\n[System.Reflection.Emit 5.0](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection.Emit\u002Bmilestone%3A5.0)\r\n\r\n### Future Open Issues \r\nCurrently there are ~36 issues (a first pass was made for 5.0 inclusion; a second pass is planned):\r\n[System.Reflection future](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection\u002Bmilestone%3AFuture)\r\n[System.Reflection.Emit future](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection.Emit\u002Bmilestone%3AFuture)\r\n\r\n# Planned work\r\nFor workload reasons, the following are non-trivial issues that currently are being scheduled or discussed for 5.0:\r\n\r\n## P1 roadmap and usage scenarios.\r\n- [ ] Determine Reflection.Emit roadmap. Reflection.Emit is not supported on key platforms. How can we support common scenarios that will unblock key scenarios? For example, the JSON Serializer uses emit to generate code that quickly sets\\gets properties -- can we add a mechanism that doesn\u0027t require ref emit for this, which would allow the Serializer to be used on more platforms in a performant way?\r\n\r\nNote these are related and may or may not be addressed pending discussion:\r\n- [Proposal: Add new GetValue method to System.Reflection #19484](https://github.com/dotnet/runtime/issues/19484)\r\n- [Proposal for high-performance codegen-less Reflection factory APIs #23716](https://github.com/dotnet/runtime/issues/23716)\r\n- [Faster MethodInfo.Invoke #7560](https://github.com/dotnet/runtime/issues/7560)\r\n- todo: proposal for fast property\\field getter\\setter without using ref.emit?\r\n\r\n## P1 features\r\n- [ ] (medium) [MetadataLoadContext to support dynamic assemblies #27803](https://github.com/dotnet/runtime/issues/27803)\r\n- [x] (small) [Unable to read ReturnTypeCustomAttributes when using System.Reflection.MetadataLoadContext #30959](https://github.com/dotnet/runtime/issues/30959)\r\n\r\n## P1 performance\r\n- [x] (medium) [System.Reflection.MetadataLoadContext performance #30886](https://github.com/dotnet/runtime/issues/30886)\r\n\r\n## P1 bugs\r\n- [x] (medium) [Test Failed: System.AccessViolationException #13298](https://github.com/dotnet/runtime/issues/13298)\r\n- [x] (small) [Add .Net Framework TFM to System.Reflection.MetadataLoadContext #30810](https://github.com/dotnet/runtime/issues/30810)\r\n- [x] (?) [The dynamic type created is thrown Fileloadexception when using the GetCustomAttributes method #26912](https://github.com/dotnet/runtime/issues/26912)\r\n- [x] (small-medium) [System.Reflection.DispatchProxy inconsistently fails for internal interfaces #30917](https://github.com/dotnet/runtime/issues/30917)\r\n- [ ] (small) [Port CoreRT fix to System.Reflection.MetadataLoadContext #28046](https://github.com/dotnet/runtime/issues/28046)\r\n\r\n\r\n## P2 features\r\n- [ ] (very large; under discussion) [System.Reflection.Emit.AssemblyBuilder.Save #15704](https://github.com/dotnet/runtime/issues/15704)\r\n- [ ] (large?) [WIP API Proposal - AssemblyBuilder.DefineDynamicAssembly for AssemblyLoadContext #29842](https://github.com/dotnet/runtime/issues/29842)\r\n\r\n## P2 bugs\r\n- [ ] (small) [31195 - CustomAttribute with Array Properties sets nulls incorrectly #31195](https://github.com/dotnet/runtime/issues/31195)\r\n- [x] (small) [31127 - Mark Assembly.CodeBase as obsolete #31127](https://github.com/dotnet/runtime/issues/31127)\r\n- [ ] (small) [parameterBuilder.SetConstant NullReferenceException #5987](https://github.com/dotnet/runtime/issues/5987)\r\n- [x] (small) [ParameterInfo.HasDefaultValue throws System.FormatException on optional DateTime parameter #18844](https://github.com/dotnet/runtime/issues/18844)\r\n- [x] (investigate) [DispatchProxy doesn\u0027t handle Span #28468](https://github.com/dotnet/runtime/issues/28468)\r\n- [x] (investigate) [DispatchProxy doesn\u0027t handle ref returns #28467](https://github.com/dotnet/runtime/issues/28467)\r\n- [ ] (investigate) [Constructor_String_LoadVersionTest failing on Fedora runs #27817](https://github.com/dotnet/runtime/issues/27817)\r\n- [x] (investigate) [Reflection should check mscorlib for types #19689](https://github.com/dotnet/runtime/issues/19689)\r\n\r\n\r\n",
        "Milestone": "5.0.0",
        "Assignees": [
          "steveharter"
        ],
        "Labels": [
          {
            "Name": "Design Discussion",
            "BackgroundColor": "f7b7ee"
          },
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-System.Reflection.Emit",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#27803",
            "CreatedAt": "2018-11-02T23:18:46+00:00",
            "CreatedBy": "steveharter",
            "IsClosed": false,
            "Title": "MetadataLoadContext to support dynamic assemblies",
            "DescriptionMarkdown": "As part of the review for feature dotnet/runtime#15033 and PR dotnet/corefx#33201, there was concern about the lack of support for assemblies not backed by a physical file.\r\n\r\nFrom the comments @jkotas:\r\n\u003E There is no way to load runtime loaded assembly into MetadataLoadContext that it not backed by a physical file. The runtime has AssemblyExtensions.TryGetRawMetadata API to handle this case, but there is no way to give the blob returned by TryGetRawMetadata to MetadataLoadContext. The assemblies not backed by physical file are rare today, but they are very likely going to become more common as part of the single-file project.\r\nI am wondering whether there should be a LoadFrom method that takes MetadataReaderProvider to address both these problems and/or whether we should expose a resolver that can resolve the runtime loaded assemblies for you.\r\n\r\nImplementation\\design TBD. One approach is to use runtime reflection over the dynamic assembly, and convert those from \u0060System.RuntimeType\u0060 to the MetadataLoadContext types (\u0060System.RoType\u0060).\r\n\r\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30959",
            "CreatedAt": "2019-09-25T22:14:34+00:00",
            "CreatedBy": "barryhagan",
            "IsClosed": true,
            "Title": "Unable to read ReturnTypeCustomAttributes when using System.Reflection.MetadataLoadContext",
            "DescriptionMarkdown": "I was trying to use SR.MetadataLoadContext 4.6.0  in order to reflect an assembly and inspect for nullable reference types.    In order to do that I must get the custom attributes for a method\u0027s \u0060ReturnType\u0060 using \u0060ReturnTypeCustomAttributes\u0060.\r\n\r\nIf you attempt to call \u0060ICustomAttributeProvider.GetCustomAttributes(bool)\u0060 on \u0060ReturnTypeCustomAttributes\u0060, you get the following exception:\r\n\r\n\u0060\u0060\u0060console\r\nUnhandled exception: System.InvalidOperationException: The requested operation cannot be used on objects loaded by a MetadataLoadContext.\r\n   at System.Reflection.TypeLoading.RoParameter.GetCustomAttributes(Boolean inherit)\r\n\u0060\u0060\u0060\r\n\r\nIs there another way to get the custom attributes for a return type to inspect \u0060NullableAttribute\u0060 and \u0060NullableContextAttribute\u0060 with MetadataLoadContext?\r\n\r\nCurrent unwanted workaround is to reflect the property from the interface implementation, which lets me see the attributes:\r\n\u0060\u0060\u0060csharp\r\nMethodInfo mi;\r\nvar attributes = mi.ReturnTypeCustomAttributes.GetType().GetProperty(\u0022CustomAttributes\u0022).GetValue(mi) as IEnumerable\u003CCustomAttributeData\u003E;\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "question",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30886",
            "CreatedAt": "2019-09-18T14:33:14+00:00",
            "CreatedBy": "jonathanpeppers",
            "IsClosed": false,
            "Title": "System.Reflection.MetadataLoadContext performance",
            "DescriptionMarkdown": "I have a benchmark here: https://github.com/jonathanpeppers/Benchmarks/blob/7db49fb3d272c5b07deda166dd4f5a5112258bbe/Benchmarks/Cecil.cs#L90-L111\r\n\r\nAnd I am getting \u0022not so great\u0022 results for \u0060SR.MetadataLoadContext\u0060:\r\n\r\n\u0060\u0060\u0060\r\n// * Summary *\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.18362\r\nIntel Core i9-9900K CPU 3.60GHz, 1 CPU, 16 logical and 8 physical cores\r\n  [Host]     : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.4010.0\r\n  DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.4010.0\r\n\r\n\r\n                                Method |        Mean |      Error |     StdDev |      Median | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |\r\n-------------------------------------- |------------:|-----------:|-----------:|------------:|------------:|------------:|------------:|--------------------:|\r\n            System.Reflection.Metadata |    32.84 ms |  0.1200 ms |  0.1123 ms |    32.85 ms |   3000.0000 |     62.5000 |           - |            15.12 MB |\r\n                            Mono.Cecil |   351.81 ms |  7.1738 ms | 21.1522 ms |   339.38 ms |  16000.0000 |  12000.0000 |   4000.0000 |           103.57 MB |\r\n System.Reflection.MetadataLoadContext | 2,058.91 ms | 19.9863 ms | 18.6952 ms | 2,051.50 ms |  97000.0000 |  90000.0000 |   6000.0000 |           544.84 MB |\r\n\u0060\u0060\u0060\r\n\r\nThe performance compared to using raw SRM or Mono.Cecil is drastically worse.\r\n\r\nI expected it to be somewhere in the middle of using SRM and Mono.Cecil. Is there something I\u0027m doing here that would explain the poor performance?\r\n\r\nThanks!",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "tenet-performance",
                "BackgroundColor": "c2e0c6"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#13298",
            "CreatedAt": "2019-08-22T02:07:15+00:00",
            "CreatedBy": "VincentBu",
            "IsClosed": true,
            "Title": "Test Failed: System.AccessViolationException: Attempted to read or write protected memory.",
            "DescriptionMarkdown": "**Detail:**\r\nhttps://helix.dot.net/api/2019-06-17/jobs/061738ef-c89d-4da3-9a70-ad8ea1c6968d/workitems/System.Reflection.MetadataLoadContext.Tests/console\r\n\r\n**Mod:**\r\nCOMPlus_JitStress=2\r\nCOMPlus_JitStressRegs=4\r\nCOMPlus_TieredCompilation=0\r\n\r\n**Log:**\r\n\u0060\u0060\u0060\r\nC:\\dotnetbuild\\work\\061738ef-c89d-4da3-9a70-ad8ea1c6968d\\Work\\009dec37-7ea7-403e-97d2-0ba158ec2160\\Exec\u003E\u0022C:\\dotnetbuild\\work\\061738ef-c89d-4da3-9a70-ad8ea1c6968d\\Payload\\dotnet.exe\u0022 exec --runtimeconfig System.Reflection.MetadataLoadContext.Tests.runtimeconfig.json xunit.console.dll System.Reflection.MetadataLoadContext.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=nonnetcoreapptests -notrait category=nonwindowstests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing @C:\\dotnetbuild\\work\\061738ef-c89d-4da3-9a70-ad8ea1c6968d\\Payload\\CoreFX.issues.rsp \r\n  Discovering: System.Reflection.MetadataLoadContext.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Reflection.MetadataLoadContext.Tests (found 484 test cases)\r\n  Starting:    System.Reflection.MetadataLoadContext.Tests (parallel test collections = on, max threads = 2)\r\nFatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\r\n   at System.Reflection.TypeLoading.Ecma.EcmaModule.GetGenericTypeParameter(System.Reflection.TypeLoading.TypeContext, Int32)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeType(System.Reflection.Metadata.BlobReader ByRef, Boolean)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeTypeSequence(System.Reflection.Metadata.BlobReader ByRef)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeGenericTypeInstance(System.Reflection.Metadata.BlobReader ByRef)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeType(System.Reflection.Metadata.BlobReader ByRef, Boolean, Int32)\r\n   at System.Reflection.TypeLoading.Ecma.EcmaResolver.ResolveTypeSpec(System.Reflection.Metadata.TypeSpecificationHandle, System.Reflection.TypeLoading.Ecma.EcmaModule, System.Reflection.TypeLoading.TypeContext ByRef)\r\n   at System.Reflection.TypeLoading.Ecma.EcmaResolver.ResolveTypeDefRefOrSpec(System.Reflection.Metadata.EntityHandle, System.Reflection.TypeLoading.Ecma.EcmaModule, System.Reflection.TypeLoading.TypeContext ByRef)\r\n   at System.Reflection.TypeLoading.Ecma.EcmaDefinitionType.SpecializeBaseType(System.Reflection.TypeLoading.RoType[])\r\n   at System.Reflection.TypeLoading.RoType.ComputeBaseType()\r\n   at System.Reflection.TypeLoading.RoType.GetRoBaseType()\r\n   at System.Reflection.TypeLoading.Assignability.CanCastTo(System.Type, System.Type, System.Reflection.TypeLoading.CoreTypes)\r\n   at System.Reflection.TypeLoading.Assignability.IsAssignableFrom(System.Type, System.Type, System.Reflection.TypeLoading.CoreTypes)\r\n   at System.Reflection.TypeLoading.RoType.IsAssignableFrom(System.Type)\r\n   at System.Reflection.TypeLoading.RoType.IsAssignableFrom(System.Reflection.TypeInfo)\r\n   at System.Reflection.Tests.TypeInfoIsAssignableFromTests.VerifyIsAssignableFrom(System.String, System.Reflection.TypeInfo, System.Reflection.TypeInfo, Boolean)\r\n   at System.Reflection.Tests.TypeInfoIsAssignableFromTests.TestIsAssignable3()\r\n   at System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean, Boolean)\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo)\r\n   at Xunit.Sdk.TestInvoker\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].CallTestMethod(System.Object)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003Ec__DisplayClass48_1\u002B\u003C\u003CInvokeTestMethodAsync\u003Eb__1\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003Ec__DisplayClass48_1\u002B\u003C\u003CInvokeTestMethodAsync\u003Eb__1\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003C\u003CInvokeTestMethodAsync\u003Eb__1\u003Ed\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003Ec__DisplayClass48_1[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].\u003CInvokeTestMethodAsync\u003Eb__1()\r\n   at Xunit.Sdk.ExecutionTimer\u002B\u003CAggregateAsync\u003Ed__4.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExecutionTimer\u002B\u003CAggregateAsync\u003Ed__4, xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CAggregateAsync\u003Ed__4 ByRef)\r\n   at Xunit.Sdk.ExecutionTimer.AggregateAsync(System.Func\u00601\u003CSystem.Threading.Tasks.Task\u003E)\r\n   at Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__9.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__9, xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__9 ByRef)\r\n   at Xunit.Sdk.ExceptionAggregator.RunAsync(System.Func\u00601\u003CSystem.Threading.Tasks.Task\u003E)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003CInvokeTestMethodAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker\u00601\u002B\u003CInvokeTestMethodAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CInvokeTestMethodAsync\u003Ed__48\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestInvoker\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].InvokeTestMethodAsync(System.Object)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003CRunAsync\u003Eb__47_0\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003CRunAsync\u003Eb__47_0\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003C\u003CRunAsync\u003Eb__47_0\u003Ed\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestInvoker\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].\u003CRunAsync\u003Eb__47_0()\r\n   at Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.Decimal, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.Decimal, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__10\u00601\u003CSystem.Decimal\u003E ByRef)\r\n   at Xunit.Sdk.XunitTestRunner.InvokeTestMethodAsync(Xunit.Sdk.ExceptionAggregator)\r\n   at Xunit.Sdk.XunitTestRunner\u002B\u003CInvokeTestAsync\u003Ed__4.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.XunitTestRunner\u002B\u003CInvokeTestAsync\u003Ed__4, xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CInvokeTestAsync\u003Ed__4 ByRef)\r\n   at Xunit.Sdk.XunitTestRunner.InvokeTestAsync(Xunit.Sdk.ExceptionAggregator)\r\n   at Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__10\u00601\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.ExceptionAggregator.RunAsync[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.Func\u00601\u003CSystem.Threading.Tasks.Task\u00601\u003CSystem.__Canon\u003E\u003E)\r\n   at Xunit.Sdk.TestRunner\u00601\u002B\u003CRunAsync\u003Ed__43[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestRunner\u00601\u002B\u003CRunAsync\u003Ed__43[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__43\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.XunitTestCaseRunner.RunTestAsync()\r\n   at Xunit.Sdk.TestCaseRunner\u00601\u002B\u003CRunAsync\u003Ed__19[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCaseRunner\u00601\u002B\u003CRunAsync\u003Ed__19[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__19\u003CSystem.__Canon\u003E ByRef)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Xunit.Sdk.TestCaseRunner\u00601\u002B\u003CRunAsync\u003Ed__19[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__19\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestCaseRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.XunitTestMethodRunner.RunTestCaseAsync(Xunit.Sdk.IXunitTestCase)\r\n   at Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunTestCasesAsync\u003Ed__32[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunTestCasesAsync\u003Ed__32[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestCasesAsync\u003Ed__32\u003CSystem.__Canon\u003E ByRef)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunTestCasesAsync\u003Ed__32[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestCasesAsync\u003Ed__32\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestMethodRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestCasesAsync()\r\n   at Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunAsync\u003Ed__31[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunAsync\u003Ed__31[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__31\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.XunitTestClassRunner.RunTestMethodAsync(Xunit.Abstractions.ITestMethod, Xunit.Abstractions.IReflectionMethodInfo, System.Collections.Generic.IEnumerable\u00601\u003CXunit.Sdk.IXunitTestCase\u003E, System.Object[])\r\n   at Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunTestMethodsAsync\u003Ed__38[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunTestMethodsAsync\u003Ed__38[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestMethodsAsync\u003Ed__38\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestClassRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestMethodsAsync()\r\n   at Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunAsync\u003Ed__37[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunAsync\u003Ed__37[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__37\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestClassRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunTestClassesAsync\u003Ed__28[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunTestClassesAsync\u003Ed__28[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestClassesAsync\u003Ed__28\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestCollectionRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestClassesAsync()\r\n   at Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunAsync\u003Ed__27[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunAsync\u003Ed__27[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__27\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestCollectionRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.XunitTestAssemblyRunner\u002B\u003C\u003Ec__DisplayClass14_2.\u003CRunTestCollectionsAsync\u003Eb__2()\r\n   at System.Threading.Tasks.Task\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].InnerInvoke()\r\n   at System.Threading.Tasks.Task\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__274_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntry()\r\n   at System.Threading.Tasks.SynchronizationContextTaskScheduler\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__8_0(System.Object)\r\n   at Xunit.Sdk.MaxConcurrencySyncContext.RunOnSyncContext(System.Threading.SendOrPostCallback, System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at Xunit.Sdk.MaxConcurrencySyncContext.WorkerThreadProc()\r\n   at Xunit.Sdk.XunitWorkerThread\u002B\u003C\u003Ec.\u003CQueueUserWorkItem\u003Eb__5_0(System.Object)\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__274_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n   at System.Threading.Tasks.ThreadPoolTaskScheduler\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__10_0(System.Object)\r\n   at System.Threading.ThreadHelper.ThreadStart_Context(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.ThreadHelper.ThreadStart(System.Object)\r\nexit code -1073741819\r\n\u0060\u0060\u0060",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "arch-x64",
                "BackgroundColor": "eb6420"
              },
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-windows",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "test-corefx",
                "BackgroundColor": "81af24"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30810",
            "CreatedAt": "2019-09-10T11:02:14+00:00",
            "CreatedBy": "Daniel-Svensson",
            "IsClosed": true,
            "Title": "Add .Net Framework TFM to System.Reflection.MetadataLoadContext",
            "DescriptionMarkdown": "Please add a net4* target such as (net46 or net461 ?) to System.Reflection.MetadataLoadContext as recommended by your own [Open-source library guidance\r\n](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting).\r\n\r\nI want to consume it in a msbuild (distributed via nuget) task which should run on VS2015\u002B and I really do not want to have to ship the extra netstandard support assemblies.\r\nThey have given me problem before and I really cannot change target framework or which version of netstandard assemblies msbuild is bundled with.",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#26912",
            "CreatedAt": "2018-07-23T18:45:44+00:00",
            "CreatedBy": "joshfree",
            "IsClosed": true,
            "Title": " The dynamic type created is thrown Fileloadexception when using the GetCustomAttributes method",
            "DescriptionMarkdown": "Original issue https://github.com/dotnet/core/issues/1481\r\n\r\n**_@faib920 commented on Apr 26_**\r\nI Use TypeBuilder create a testclass, and use SetCustomAttributes to add custom attribute, then I use the method of GetCustomAttributes, throw FileLoadFileException.\r\n\r\nFileLoadException:\r\nCould not load file or assembly \u0027_testclass, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027. Operation is not supported. (Exception from HRESULT: 0x80131515)\r\n\r\ninner Exception\r\nSystem.NotSupportedException\r\nResolving to a collectible assembly is not supported.\r\n\r\nStackTrace:\r\n\u0060\u0060\u0060\r\nat System.Reflection.CustomAttribute._CreateCaObject(RuntimeModule pModule, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs)\r\nat System.Reflection.CustomAttribute.CreateCaObject(RuntimeModule module, IRuntimeMethodInfo ctor, IntPtr\u0026 blob, IntPtr blobEnd, Int32\u0026 namedArgs)\r\nat System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule, Int32 decoratedMetadataToken, Int32 pcaCount, RuntimeType attributeFilterType, Boolean mustBeInheritable, IList derivedAttributes, Boolean isDecoratedTargetSecurityTransparent)\r\nat System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)\r\nat System.Attribute.GetCustomAttributes(MemberInfo element, Type type, Boolean inherit)\r\nat System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](MemberInfo element, Boolean inherit)\r\n\u0060\u0060\u0060\r\n\r\n\r\n**_@evo01 commented 14 days ago_**\r\nI did some more testing around this issue and the temporary work around seems to be to not use named arguments.  If you leave the named arguments off, and use the following property instead, you can custom attributes in a dynamic type.\r\n\r\n\u0060\u0060\u0060\r\n[Custom1(\u0022Howdy\u0022, new []{ EnumTesting_BasicEnum_Int16 .One})] \r\npublic class ClassTesting_ClassWithBlankAttribute\r\n{\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060var attributes = dynamicType.CustomAttributes.ToList(); // WORKS\u0060\r\n\t\t\t\r\n\u0060Assert.AreEqual(1, attributes.Count); // WORKS\u0060\r\n\r\n\r\n\r\nThis does not work:\r\n\r\n\u0060\u0060\u0060\r\n[Custom1(\u0022Howdy\u0022, new []{ EnumTesting_BasicEnum_Int16 .One}, MyField1 = new[] { EnumTesting_BasicEnum_Int16.One }, MyField2 = typeof(Custom1Attribute), MyProperty1 =1)]\r\npublic class ClassTesting_ClassWithBlankAttribute\r\n{\r\n}\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "needs more info",
                "BackgroundColor": "eb6420"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30917",
            "CreatedAt": "2019-09-20T21:12:53+00:00",
            "CreatedBy": "AArnott",
            "IsClosed": false,
            "Title": "System.Reflection.DispatchProxy inconsistently fails for internal interfaces",
            "DescriptionMarkdown": "An undocumented limitation in \u0060DispatchProxy.Create\u0060 is that it *sometimes* throws for various configurations of visibility. This seems to be a broader issue than the more specific dotnet/runtime#25595.\r\n\r\nThese configurations work:\r\n\r\n1. public interface, public base class.\r\n1. internal interface, internal base class, within the same assembly. But only when this is the *first* proxy ever generated.\r\n\r\nThese configurations *don\u0027t* work:\r\n\r\n1. public interface, internal base class.\r\n1. internal interface, internal base class, if another assembly has already provided an internal interface to generate a proxy for.\r\n\r\nThere were other odd configurations that similarly failed.\r\n\r\nSince I\u0027ve done this kind of feature before, I have a suspicion that the generated \u0060ProxyBuilder\u0060 assembly includes an [\u0060System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute\u0060](https://github.com/microsoft/vs-mef/blob/21ca4f58145ae9e0e1560de287e112a608ed796f/src/Microsoft.VisualStudio.Composition/Reflection/SkipClrVisibilityChecks.cs#L159) for the assembly that defines the interface. \r\nThe way I solved this is that each time I need to generate a proxy, [I evaluate all the assemblies that visibility checks must be skipped for](https://github.com/microsoft/vs-mef/blob/21ca4f58145ae9e0e1560de287e112a608ed796f/src/Microsoft.VisualStudio.Composition/Configuration/MetadataViewGenerator.cs#L114) and create a new dynamic assembly for each unique set that I get. So multiple proxies are supported, and we reuse dynamic assemblies where possible but when the set of dynamic assemblies exceed any previously discovered set we have to start a new assembly.\r\n\r\nAdding more attributes to an existing dynamic assembly is ineffective because once you\u0027ve loaded the first type from the assembly, the CLR caches these attributes and doesn\u0027t notice when new ones are added.",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#28046",
            "CreatedAt": "2018-12-03T19:53:09+00:00",
            "CreatedBy": "MichalStrehovsky",
            "IsClosed": true,
            "Title": "Port CoreRT fix to System.Reflection.MetadataLoadContext",
            "DescriptionMarkdown": "Port this to MetadataLoadContext and add test coverage:\r\n\r\nhttps://github.com/dotnet/corert/pull/6638/commits/93364da1a71588650e1e4013bb481d4745dc5d9d",
            "Milestone": "Future",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "needs more info",
                "BackgroundColor": "eb6420"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#15704",
            "CreatedAt": "2015-11-13T06:21:41+00:00",
            "CreatedBy": "jonorossi",
            "IsClosed": false,
            "Title": "System.Reflection.Emit.AssemblyBuilder.Save",
            "DescriptionMarkdown": "\u0060AssemblyBuilder.Save\u0060 and \u0060AssemblyBuilderAccess.RunAndSave\u0060 isn\u0027t available in .NET Core, however coreclr seems to have the code to implement it but I looks conditionally compiled out.\n\nhttps://github.com/dotnet/coreclr/blob/bc146608854d1db9cdbcc0b08029a87754e12b49/src/mscorlib/src/System/Reflection/Emit/AssemblyBuilder.cs#L1690-L1711\n\nOur use case in Castle DynamicProxy is to write out dynamically created assemblies to disk so we can run peverify over the assembly in unit tests. It also greatly helps writing out the assembly and opening it in ildasm to manually verify IL.\n\nIs there any chance we can get this functionality that .NET Framework has introduced into .NET Core, or an alternative way of doing the same thing. This might not sound like a big deal if you aren\u0027t familiar with Castle DynamicProxy\u0027s internals, but it really is as it heavily reduces our confidence in both our code and the .NET runtime as well as reducing our ability to track down defects.\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-needs-work",
                "BackgroundColor": "207de5"
              },
              {
                "Name": "area-System.Reflection.Emit",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#29842",
            "CreatedAt": "2019-06-10T22:30:00+00:00",
            "CreatedBy": "sdmaclea",
            "IsClosed": false,
            "Title": "WIP API Proposal - AssemblyBuilder.DefineDynamicAssembly for AssemblyLoadContext",
            "DescriptionMarkdown": "https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder.definedynamicassembly?view=netcore-3.0\r\n\r\n\u0060AssemblyBuilder\u0060 is implemented as a type of \u0060RuntimeAssembly\u0060, but there seems to be no mechanism to create it directly in a specific \u0060AssemblyLoadContext\u0060.\r\n\r\nI assume we need at least one mechanism.\r\n\r\nThis issue is highly similar to that described in dotnet/runtime#29042\r\n\r\nIf we chose a similar solution, we would need 2 changes.\r\n1. Make existing APIs sensitive to AssemblyLoadContext.CurrentContextualReflectionContext \r\n2. Add new explicit APIs\r\n\r\nWe may be able to support 1 above in 3.0 as this may be a simple PR.\r\nIt would be nice to add the new APIs for 3.1, but this may not meet the shiproom approval process\r\n\r\n/cc @vitek-karas @jkotas @cablooshe @elinor-fung @jeffschwMSFT @sbomer \r\n\r\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection.Emit",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#31195",
            "CreatedAt": "2019-10-17T07:45:12+00:00",
            "CreatedBy": "JamesAshworth",
            "IsClosed": false,
            "Title": "CustomAttribute with Array Properties sets nulls incorrectly",
            "DescriptionMarkdown": "An attribute with two array properties does not behave as expected if the first array property is set to a value and the second array property is set to null. If the two arrays are of the same type, the second property is set to the same value as the first property. If the two types are incompatible, an exception is thrown when the attribute is constructed, stating that the second property cannot be found.\r\n\r\nAttached are two variations on a simple program that replicates each issue.\r\n\r\n[Same Type](https://github.com/dotnet/corefx/files/3737962/Program.txt)\r\n[Incompatible Types](https://github.com/dotnet/corefx/files/3737971/Program.2.txt)\r\n\r\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#31127",
            "CreatedAt": "2019-10-09T23:56:18+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": true,
            "Title": "Mark Assembly.CodeBase as obsolete",
            "DescriptionMarkdown": "\u0060Assembly.Location\u0060 and \u0060Assembly.CodeBase\u0060 are very similar, but not the same thing. To reduce confusion, we should mark it as obsolete.\r\n\r\n### Reason\r\n\r\nHaving two things that are similar, but not identical always causes confusion. Here is [an example](https://github.com/aspnet/AspNetCore/issues/14501#issuecomment-537286033).\r\n\r\nAs @jkotas [said](https://github.com/aspnet/AspNetCore/issues/14501#issuecomment-538606720):\r\n\r\n\u003E \u0060Assembly.Location\u0060 is strictly better than \u0060Assembly.CodeBase\u0060.\r\n\u003E \r\n\u003E \u0060Assembly.CodeBase\u0060 is an obsolete property. The only reason why it was included in .NET Core was .NET Framework compatibility. The original purpose of \u0060Assembly.CodeBase\u0060 was CAS (Code Access Security). It was meant to describe where the assembly was downloaded from for the Internet Zone security checks. It also explains some of its weird behaviors. For example, if the assembly is loaded as byte array, it returns the location of the caller of the \u0060Assembly.Load\u0060 method.\r\n\r\n### Proposed API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection\r\n{\r\n    public partial class Assembly\r\n    {\r\n        [Obsolete(\u0022Use Location instead.\u0022)]\r\n        public virtual string CodeBase { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "easy",
                "BackgroundColor": "90eeff"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#5987",
            "CreatedAt": "2016-06-01T14:21:48+00:00",
            "CreatedBy": "GSPP",
            "IsClosed": true,
            "Title": "parameterBuilder.SetConstant NullReferenceException",
            "DescriptionMarkdown": "\u0060\u0060\u0060\n        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\u0022x\u0022), AssemblyBuilderAccess.RunAndSave);\n        var moduleBuilder = assemblyBuilder.DefineDynamicModule(\u0022x\u0022);\n        var typeBuilder = moduleBuilder.DefineType(\u0022C\u0022, TypeAttributes.Class);\n        var methodBuilder = typeBuilder.DefineMethod(\u0022M\u0022, MethodAttributes.Static);\n        methodBuilder.SetParameters(typeof(void), typeof(TimeSpan));\n\n        var parameterBuilder = methodBuilder.DefineParameter(0, ParameterAttributes.HasDefault, \u0022p\u0022);\n        parameterBuilder.SetConstant(null); //NullReferenceException\n\u0060\u0060\u0060\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#18844",
            "CreatedAt": "2016-10-04T04:58:00+00:00",
            "CreatedBy": "epsitec",
            "IsClosed": true,
            "Title": "ParameterInfo.HasDefaultValue throws System.FormatException on optional DateTime parameter",
            "DescriptionMarkdown": "When accessing \u0060ParameterInfo.HasDefaultValue\u0060 for a parameter of type \u0060System.DateTime\u0060, I\nget an unexpected \u0060System.FormatException\u0060.\n\n\u0060ParameterInfo.Attributes\u0060 is correctly set to \u0060Optional | HasDefault\u0060.\n\nIf the parameter is of any other value type (e.g. \u0060decimal\u0060 or some custom _struct_) the\nproperty works as expected. There is something specific to \u0060DateTime\u0060 in the implementation\nof \u0060RuntimeParameterInfo.GetDefaultValueInternal()\u0060 which is broken.\n\nCode snippet to test:\n\n\u0060\u0060\u0060 c#\npublic void Usage()\n{\n    var type = typeof (Foo);\n    var ctor = type.GetConstructors ()[0];\n    var para = ctor.GetParameters ()[0];\n    // This throws an exception...\n    Assert.True (para.HasDefaultValue);\n}\n\nstatic class Foo\n{\n    public Foo(System.DateTime value = default (System.DateTime)) { }\n}\n\u0060\u0060\u0060\n\nException:\n\n![default-value](https://cloud.githubusercontent.com/assets/3872435/19062968/c8793004-89fe-11e6-9db3-b203f4c900d3.png)\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#28468",
            "CreatedAt": "2019-01-21T12:42:57+00:00",
            "CreatedBy": "MichalStrehovsky",
            "IsClosed": true,
            "Title": "DispatchProxy doesn\u0027t handle Span",
            "DescriptionMarkdown": "This fails with:\r\n\r\nSystem.InvalidProgramException: \u0027Cannot create boxed ByRef-like values.\u0027\r\n\r\nNot sure we can do anything with the existing structure, but this doesn\u0027t point to where the problem is.\r\n\r\n\u0060\u0060\u0060csharp\r\nusing System;\r\nusing System.Reflection;\r\n\r\nunsafe interface IFoo\r\n{\r\n    int Frob(Span\u003Cint\u003E x);\r\n}\r\n\r\nunsafe class Program : DispatchProxy\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        IFoo myProxy = DispatchProxy.Create\u003CIFoo, Program\u003E();\r\n        int result = myProxy.Frob(default);\r\n        Console.WriteLine($\u0022myProxy.Frob returned {(IntPtr)result}\u0022);\r\n    }\r\n\r\n    protected override object Invoke(MethodInfo targetMethod, object[] args)\r\n    {\r\n        Console.WriteLine($\u0022Invoked method {targetMethod.Name} with {args.Length} arguments\u0022);\r\n        return 42;\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#28467",
            "CreatedAt": "2019-01-21T12:41:10+00:00",
            "CreatedBy": "MichalStrehovsky",
            "IsClosed": true,
            "Title": "DispatchProxy doesn\u0027t handle ref returns",
            "DescriptionMarkdown": "Not sure if anything can be done with the existing structure to make this work, but this fails with:\r\n\r\nSystem.ArgumentException: \u0027Cannot get TypeToken for a ByRef type.\u0027\r\n\r\nThis doesn\u0027t really point to where the problem is.\r\n\r\n\u0060\u0060\u0060csharp\r\nusing System;\r\nusing System.Reflection;\r\n\r\nunsafe interface IFoo\r\n{\r\n    ref int Frob();\r\n}\r\n\r\nunsafe class Program : DispatchProxy\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        IFoo myProxy = DispatchProxy.Create\u003CIFoo, Program\u003E();\r\n        int result = myProxy.Frob();\r\n        Console.WriteLine($\u0022myProxy.Frob returned {(IntPtr)result}\u0022);\r\n    }\r\n\r\n    protected override object Invoke(MethodInfo targetMethod, object[] args)\r\n    {\r\n        Console.WriteLine($\u0022Invoked method {targetMethod.Name} with {args.Length} arguments\u0022);\r\n        return 42;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#27817",
            "CreatedAt": "2018-11-05T17:27:15+00:00",
            "CreatedBy": "weshaggard",
            "IsClosed": false,
            "Title": "Constructor_String_LoadVersionTest failing on Fedora runs",
            "DescriptionMarkdown": "\u0060\u0060\u0060\r\nAssert.Throws() Failure\r\nExpected: typeof(System.IO.FileNotFoundException)\r\nActual:   (No exception was thrown)\r\nStack Trace :\r\n   at System.Reflection.Tests.AssemblyNameTests.Constructor_String_LoadVersionTest() in /mnt/j/workspace/dotnet_corefx/master/linux-TGroup_netcoreapp\u002BCGroup_Release\u002BAGroup_x64\u002BTestOuter_false_prtest/src/System.Reflection/tests/AssemblyNameTests.cs:line 559\r\n\u0060\u0060\u0060\r\n\r\nA couple examples:\r\nhttps://mc.dot.net/#/user/weshaggard/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/84cf25a2c8d2bd2819584e57de87a5c1c0fa6efa/workItem/System.Reflection.Tests/analysis/xunit/System.Reflection.Tests.AssemblyNameTests~2FConstructor_String_LoadVersionTest\r\nhttps://mc.dot.net/#/user/stephentoub/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/b4be508ae9f11a42286a828728d537eca987d0bb/workItem/System.Reflection.Tests/analysis/xunit/System.Reflection.Tests.AssemblyNameTests~2FConstructor_String_LoadVersionTest",
            "Milestone": "Future",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "disabled-test",
                "BackgroundColor": "654321"
              },
              {
                "Name": "os-linux",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#19689",
            "CreatedAt": "2016-12-14T22:27:46+00:00",
            "CreatedBy": "JeremyKuhne",
            "IsClosed": true,
            "Title": "Reflection should check mscorlib for types",
            "DescriptionMarkdown": "In NetFX \u0060Type.GetType()\u0060 would find types that weren\u0027t fully qualified in mscorlib. Now that we\u0027re going to ship the mscorlib facade we should probably mimic that behavior.\r\n\r\nSee the following discussion: https://github.com/dotnet/corefx/pull/14498#discussion_r92474847\r\n\r\n@weshaggard, @ericstj \r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              },
              {
                "Name": "tenet-compatibility",
                "BackgroundColor": "c2e0c6"
              },
              {
                "Name": "untriaged",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#31372",
        "CreatedAt": "2019-11-01T23:57:24+00:00",
        "CreatedBy": "tarekgh",
        "IsClosed": true,
        "Title": "Distributed Context in ASP.NET and Open Telemetry",
        "DescriptionMarkdown": "This issue is tracking the work that needs to be done for supporting the distributed context scenarios for ASP.NET and [OpenTelemetry](https://github.com/open-telemetry/opentelemetry-specification).\r\n\r\nHere are the scenarios we need to support: \r\n\r\n## Distributed Context scenarios\r\nThese scenarios talking about ILogger and OpenTelemetry scenarios. OpenTelemetry has a goal to implement all these scenarios if you replace \u201CILogger\u201D with \u201COpenTelemetry Logging API\u201D. The goal of this document is to come up with scenarios that will not require OpenTelemetry to introduce new concepts and libraries. And out-of-the-box ASP.NET apps be more distributed apps friendly.\r\n\r\n### Out of the box ASP.NET application\r\n- Distributed trace identifiers are automatically propagated through the app. This enables the correlation of telemetry across multiple components even when only a subset of these components has monitoring enabled.\r\nNote: This is already implemented via DiagnosticsSource.Activity. \r\n\r\n- Log messages and exceptions are automatically associated with the distributed trace identifiers. This allows pinpointing the root cause of the problem faster by associating logs and exceptions with the downstream components that might have caused the problem or upstream - components providing incorrect data.\r\nNote: This is partially implemented - trace-id and span-id of a topmost request are added to the ILogger scope.\r\n\r\n- Users may output distributed trace identifiers as part of an error page for the app user reference. This allows improving application supportability by providing a fast lookup reference that will simplify customer communication with support personnel.\r\n\r\n### Scoping of distributed logs\r\n- The developer may add a name/value pairs to the scope of execution. This name/value pair will be associated with all logs captured in this scope\r\n\tNote: this is an existing ILogger feature\r\n\r\n- The developer may configure some of the name/value pairs in scope to be distributed. These scope values will be transmitted over the wire and associated with the logs reported by downstream services. This feature enables scenarios like clients sending client app versions as a context property and all logs across many layers of a distributed trace will be attributed to it.\r\n\r\n### ASP.NET app with OpenTelemetry enabled\r\n- When OpenTelemetry is enabled - all logs reported by ILogger must bye be attributed with the OpenTelemetry span identity. So telemetry reported by OpenTelemetry and ILogger can be cross-referenced.\r\n\r\n- Spans reported by OpenTelemetry can use the scope\u2019s name/value pairs configured by the customer for ILogger as dimensions for telemetry. This will ensure that OpenTelemetry benefits from app attribution made by the developer for better diagnostics experience. This includes both - local and distributed contexts.\r\n\r\n### Metrics and scopes\r\n- Metrics aggregation in OpenTelemetry may use the scope\u2019s name/value pairs as a dimension for aggregation based on configuration. This includes both - local and distributed contexts.\r\n\r\n- EventCounters may use the scope\u2019s name/value pairs as a dimension for aggregation. This includes both - local and distributed contexts.\r\n\r\n### Distributed \u201CHTTP context\u201D\r\n- The developer must be able to set up business-critical properties that can be used across the entire distributed trace.\r\n\r\n## Tracked work items:\r\n\r\n- [x] [Make Activity and Span the same.](https://github.com/dotnet/runtime/issues/31373) @tarekgh\r\n- [x] [Add Ids and Context to all logs.](https://github.com/dotnet/runtime/issues/34305) @tarekgh\r\n- [ ] [Distributed Context API (distributed http context)](https://github.com/dotnet/runtime/issues/31393). Should be in a separate library. @tarekgh\r\n    * string/string\r\n    * Scope-able\r\n    * Not attached to Activity\r\n\r\nRef: \r\n[OpenTelemetry .NET  implementation](https://github.com/open-telemetry/opentelemetry-dotnet)\r\n[Improvements in .NET Core 3.0 for troubleshooting and monitoring distributed apps blog](https://devblogs.microsoft.com/aspnet/improvements-in-net-core-3-0-for-troubleshooting-and-monitoring-distributed-apps/)\r\n\r\nCC @SergeyKanzhelev @pakrym",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-System.Diagnostics",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#31373",
            "CreatedAt": "2019-11-02T00:07:01+00:00",
            "CreatedBy": "tarekgh",
            "IsClosed": true,
            "Title": "Support OpenTelemetry concepts on Activity",
            "DescriptionMarkdown": "This issue tracking the work as the part of the issue https://github.com/dotnet/corefx/issues/42305\r\n\r\nPlease look at https://github.com/dotnet/designs/pull/98 for the detailed design.",
            "Milestone": "5.0.0",
            "Assignees": [
              "tarekgh"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Diagnostics",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#34305",
            "CreatedAt": "2019-11-02T00:13:58+00:00",
            "CreatedBy": "tarekgh",
            "IsClosed": true,
            "Title": "Add activity Ids and Context to all logs ",
            "DescriptionMarkdown": "This issue tracking the work as the part of the issue https://github.com/dotnet/runtime/issues/31372\r\n\r\n## Rationale and Use Cases\r\n\r\nCurrently, there is no automatic way to log the tracing context info with the logging scopes. Tracing context info is the trace Id, Span Id, Parent Id, Trace State, and Trace flags which included inside the Activity object stored in the current execution context. This issue is to support adding the tracing context info with the logging scopes.\r\n\r\nAdding Tracing context info to the logging scope will require some memory allocations and also will increase the produced text inside the logs, we are going to provide an opt-in option to enable the new behavior. Although the whole feature is about internal implementation details, we still need to expose some API for the opt-in option. ***All Proposed APIs here are only to provide the opt-in option for enabling the trace context info in logging and choose which parts of the trace context should be included***.\r\n\r\nHere is a code sample showing how to opt-in to include the trace context info in the logs.\r\n\r\n\u0060\u0060\u0060C#\r\nvar loggerFactory = LoggerFactory.Create(builder =\u003E\r\n{\r\n    // Enable logging trace context info in the logging scopes.\r\n    builder.Configure(factoryOptions =\u003E factoryOptions.ActivityTrackingOptions = ActivityTrackingOptions.Default);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nWhen enable trace context info logging, will get in the logging results like the following:\r\n\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.Extensions.Logging.Test.ConsoleLoggerTest[0]\r\n      =\u003E SpanId:|30de9810-4985f5593b3c7f14.1., TraceId:30de9810-4985f5593b3c7f14, ParentId:|30de9810-4985f5593b3c7f14. =\u003E { Scope1 = 1 } =\u003E { Scope2 = 2 }\r\n\u0060\u0060\u0060\r\n\r\n## Proposed API\r\n\r\n- ActiviyTrackingOptions is a flags enum has the values of which parts of the trace context can be included in the logs.\r\n- LoggerFactoryOptions is the new options type for the logger factory. Although it contains the only property ActivityTrackingOptions used to enable the trace context logging, this type can be extended in the future to include more options as needed. \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [Flags]\r\n    public enum ActivityTrackingOptions\r\n    {\r\n        None        = 0x0000,\r\n        SpanId      = 0x0001,\r\n        TraceId     = 0x0002,\r\n        ParentId    = 0x0004,\r\n        Default     = SpanId | TraceId | ParentId,\r\n        TraceState  = 0x0008,\r\n        TraceFlags  = 0x0010\r\n    }\r\n\r\n    public class LoggerFactoryOptions\r\n    {\r\n        public LoggerFactoryOptions() { }\r\n        public ActivityTrackingOptions ActivityTrackingOptions  { get {throw null; } set { throw null; } }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n- Adding more constructors to the existing LoggerFactory class. This addition mainly to have the Dependency Injection (DI) work nicely with the introduced LoggerFactoryOptions. \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    // LoggerFactory is existing type\r\n    public partial class LoggerFactory : ILoggerFactory, System.IDisposable\r\n    {\r\n        public LoggerFactory(IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers, IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers, LoggerFilterOptions filterOptions, IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers, IOptionsMonitor\u003CLoggerFilterOptions\u003E filterOption, IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n     }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n- Adding the extension method Configure to the logger builder\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    // LoggingBuilderExtensions is existing type\r\n    public static partial class LoggingBuilderExtensions\r\n    {\r\n        public static ILoggingBuilder Configure(this ILoggingBuilder builder, Action\u003CLoggerFactoryOptions\u003E action) {...}\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "tarekgh"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Extensions-Logging",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#31393",
            "CreatedAt": "2019-11-04T20:27:21+00:00",
            "CreatedBy": "tarekgh",
            "IsClosed": false,
            "Title": "Introduce Distributed Context API (distributed http context)",
            "DescriptionMarkdown": "This issue tracking the work as the part of the issue dotnet/runtime#31372\r\n\r\nDistributed context should support \r\n- string/string (key-value pairs)\r\n- Support scoping \r\n- Not attached to Activity",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Diagnostics",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#1568",
        "CreatedAt": "2019-09-27T16:27:42+00:00",
        "CreatedBy": "jkotas",
        "IsClosed": false,
        "Title": "Generate Json serializers at build time",
        "DescriptionMarkdown": "\u003Cdetails\u003E\r\n\u003Csummary\u003EOriginal proposal by @jkotas (click to view)\u003C/summary\u003E\r\n\u003C/br\u003E\r\nThe generation of Json serializers via reflection at runtime has non-trivial startup costs. This has been identified as a bottleneck during prototyping of fast small cloud-first micro-services: \r\n\r\nRepro: https://gist.github.com/jkotas/b0671e154791e287c38a627ca81d7197\r\n\r\nThe Json serializer generated using reflection at runtime has startup cost ~30ms. The manually written Json serializer has startup cost ~1ms.\r\n\u003C/details\u003E\r\n\r\n---\r\n\r\n_Edited by @kevinwkt:_\r\n\r\n## Background \r\n\r\nThere are comprehensive [documents](https://github.com/dotnet/designs/pull/113) detailing the [needs](https://github.com/dotnet/runtime/issues/1568) and benefits of generating JSON serializers at compile time. Some of these benefits are improved startup time, and reduction in private memory usage and faster throughput for serialization and deserialization. After discussing some approaches and pros/cons of some of them we decided to implement this feature using [Roslyn source generators](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/). Implementation details and code/usage examples can be seen in the [design document](https://github.com/dotnet/runtimelab/pull/16/files). This document will outline the roadmap for the initial experiment and highlight actionable items.  \r\n\r\nThis is an intern project and experimental which is why we will be using the [dotnet/runtimelab](https://github.com/dotnet/runtimelab/tree/JsonCodeGen) repository instead of [dotnet/runtime](https://github.com/dotnet/runtime). The main goal of this project is to get something up and running while changing implementation and iterating on public API without committing to dotnet/runtime master. We hope to share the project and get feedback for potential release on .NET 6.0. The project will be consumable through a prerelease package until then. Progress can be tracked through the [JSON Code Gen project board](https://github.com/dotnet/runtimelab/projects/1) in dotnet/runtimelab. \r\n\r\n## Approach \r\n\r\nThere are 3 main points in this project: type discovery, source code generation, generated source code integration (with user applications). \r\n\r\n### Type discovery \r\n\r\nType discovery can be thought of in two ways, an implicit model (where the user does not have to specify which types to generate code for) and an explicit model (user specifies through code  or configuration which types to generate code for). \r\n\r\nVarious implicit approaches have been discussed such as source generating for all partial classes or scanning for calls into the serializer using Roslyn tree syntax. These models can be revisited in the future as the value/feasibility of the approach becomes clearer based on user feedback. It is important to note that some downsides to such a model include missing types to generate source for or generating source for types when not needed due to a bug or edge cases we didn\u2019t consider. \r\n\r\nThe proposed approach for type discovery requires an explicit indication of serializable types by the user. This model supports indicating both owned and non-owned types. A new [\u0060JsonSerializableAttribute\u0060](https://github.com/dotnet/runtimelab/blob/JsonCodeGen/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Attributes/JsonSerializableAttribute.cs) will be used to detect these types. There are two patterns for \u0060JsonSerializiableAttribute\u0060. The first consists of applying the attribute on a type that the user owns, and the second consists of the user passing into the constructor of the attribute a non-owned serializable type. \r\n\r\nWe believe that an explicit model using attributes would be a simple first-approach to the problem. Within the Roslyn source generator, we parse the syntax tree to find usages of the \u0060JsonSerializableAttribute\u0060. The output of this phase would be a list of input types for the generator in order to code-gen recursively for each type in all the object graphs. \r\n\r\n### Source code generation \r\n\r\nThe design for the generated source focuses mainly on performance gains and extensibility to existing \u0060JsonSerializer\u0060 functionality. Performance is improved in two ways. The first is during the first-time/warm-up performance for both CPU and memory by avoiding costly reflection to build up a Type metadata cache during runtime and moving it to compile time. These type metadata are then represented as [\u0060JsonTypeInfo\u0060](https://github.com/steveharter/runtimelab/blob/ApiAdds/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonTypeInfoOfT.cs#L15) classes that can be used for (de)serialization at runtime. The second is throughput improvement by avoiding the initial metadata-dictionary lookup on calls to the serializer by generating an instance of the type\u2019s \u0060JsonTypeInfo\u0060 (metadata). These instances will be passed to [new (de)serialize overloads](https://github.com/dotnet/runtimelab/compare/JsonCodeGen...steveharter:ApiAdds#diff-e6bf8cabf53ffaaaaf77cf53a9db85fcR59). \r\n\r\nWe will use the types discovered in the type discovery phase and recurse through the type graph in order to source generate the functions mentioned above within each \u0060JsonTypeInfo\u0060 and register them inside the user-facing wrapper \u0060JsonSerializerContext\u0060. \r\n\r\n### Generated source code integration \r\n\r\nThere are [discussions](https://gist.github.com/steveharter/d71cdfc25df53a8f60f1a3563d13cf0f) regarding integration of generated metadata source code with user apps.  The proposed approach consists of the generator creating a context class ([\u0060JsonSerializerContext\u0060](https://github.com/steveharter/runtimelab/blob/ApiAdds/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerContext.cs#L10)) which takes an options instance and contains references to the generated \u0060JsonTypeInfos\u0060 for each type seen above. This relies on the creation of new overloads to the current serializer mentioned before that can be retrieved from the context. An example of the overload and usage can be seen [here](https://github.com/dotnet/runtimelab/compare/master...steveharter:ApiAdds), while examples and details of the end to end approach can be seen in the [design document](https://github.com/dotnet/runtimelab/pull/16/files). \r\n\r\n \r\n\r\n## Action items: \r\n\r\n- [x] Implement and expose public API needed by the source generator ([in progress](https://github.com/steveharter/runtimelab/tree/ApiAdds) by @steveharter) \r\n\r\n- [x] Create source generator project in \u0060System.Text.Json\u0060 dotnet/runtimelab directory\r\n\r\n- [x] Create source generator unit test project\r\n\r\n- [x] Create source generator end-to-end test project\r\n\r\n  - [ ] Create infrastructure for performance benchmarking within the project \r\n\r\n- [x] Implement initial mechanism for type discovery \r\n\r\n  - [x] Implement and expose new \u0060JsonSerializableAttribute\u0060 from \u0060System.Text.Json\u0060. This will allow callers to indicate which types to generate serializers for (both user owned and non-user owned)  \r\n\r\n  - [x] Implement Roslyn syntax receiver to receive list of types to generate serializers for. \r\n\r\n- [ ] Implement, test, and benchmark source generator for POCOS (classes and structs) \r\n\r\n  - [ ] Share progress with partner teams and community \r\n\r\n- [ ] Implement, test, and benchmark source generator for collections \r\n\r\n  - [ ] Share progress with partner teams and community \r\n\r\n- [ ] Receive and react to user feedback \r\n\r\n  - [ ] Revisit and reconsider approaches taken in the initial experiment \r\n\r\n- [ ] Review and document unsupported JsonSerializer features within source generation feature \r\n\r\n- [ ] Polish end to end experience \r\n \r\n\r\nIt is important to note that the approaches mentioned above are for the base prototype and that we will iterate with the community in order to receive feedback and change the approaches as needed. We believe that with the base prototype, most changes won\u2019t be difficult to implement at a later phase and won\u2019t regress too much in terms of work. Progress of this effort can be seen through the [JSON Code Gen project board](https://github.com/dotnet/runtimelab/projects/1) in dotnet/runtimelab.\r\n\r\ncc @jkotas @davidfowl @stephentoub @mjsabby @terrajobst @pranavkm @ericstj @layomia @steveharter @chsienki",
        "Milestone": "6.0.0",
        "Assignees": [
          "steveharter",
          "layomia"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-System.Text.Json",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "tenet-performance",
            "BackgroundColor": "c2e0c6"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3610",
        "CreatedAt": "2019-05-30T19:55:19+00:00",
        "CreatedBy": "dagood",
        "IsClosed": true,
        "Title": "VS insertion federation: insert Runtime into VS separately for SDK simplification",
        "DescriptionMarkdown": "To simplify SDK delivery, the Runtime needs to be able to service and insert into VS independently.\r\n\r\nAs of writing, the plan for 3.0 is for VS insertion tooling to be developed in Arcade with Core-SDK using it first, and then used in Core-Setup.\r\n\r\nMore info at https://github.com/dotnet/core-sdk/issues/2166.",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3419",
        "CreatedAt": "2019-01-22T18:28:16+00:00",
        "CreatedBy": "dagood",
        "IsClosed": true,
        "Title": "AppHost Pack: netcoreapp packaging",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3399",
        "CreatedAt": "2019-01-08T23:37:50+00:00",
        "CreatedBy": "dsplaisted",
        "IsClosed": true,
        "Title": "Create targeting pack for Microsoft.WindowsDesktop.App",
        "DescriptionMarkdown": "For .NET Core 3.0, we expect to separate targeting packs, which contain the assets needed at build time when targeting .NET Core 3.0 (for example, reference assemblies and intellisense documentation) from \u0022runtime packs\u0022, which will include the platform-specific runtime components for .NET Core 3.  See dotnet/cli#10006, and [dotnet/designs#50](https://github.com/dotnet/designs/pull/50/files?short_path=ebf265d#diff-ebf265d0476041dd8cab82fa24ab5b0e)\r\n\r\nWe will have targeting pack for each shared framework (.NET Core, ASP.NET Core, and WindowsDesktop), as well as for .NET Standard.  This issue tracks the work required for the WindowsDesktop shared framework.\r\n\r\nThe work required includes:\r\n\r\n- A new NuGet package including the targeting pack assets.  This should include the reference assemblies, intellisense documentation, and platform manifest file.  The current straw man proposal for the package ID is \u0060Microsoft.NETCore.App.Ref\u0060\r\n- Installers for each supported installer format (msi, deb, pkg, and rpm), which lay out the targeting pack files under \u0060\u003CDOTNET_ROOT\u003E/packs/\u003CPackageId\u003E/version\u0060.  These installers will be bundled or depended on by the corresponding .NET Core SDK installers.\r\n\r\nSome of the details (such as package layout, names, etc) are still [under design](https://github.com/dotnet/designs/pull/50/files?short_path=ebf265d#diff-ebf265d0476041dd8cab82fa24ab5b0e) and may change slightly.  ",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3362",
        "CreatedAt": "2018-11-19T21:06:42+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": false,
        "Title": "Implement a build system for Snaps",
        "DescriptionMarkdown": ".NET Core Snaps are currently shipping but the process is manual. We need to implement a build system (based on Arcade)",
        "Milestone": "6.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Snap",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3361",
        "CreatedAt": "2018-11-19T21:00:16+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Core-setup builds using Arcade",
        "DescriptionMarkdown": "",
        "Milestone": "3.1",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Infrastructure-installer",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3356",
        "CreatedAt": "2018-11-19T20:55:25+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Loc Support",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3353",
        "CreatedAt": "2018-11-19T20:52:27+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "ARM Runtime and Host packages and installers",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dleeapho"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3352",
        "CreatedAt": "2018-11-19T20:50:28+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Build installers, packages from upstream repos for host, hostfxr ",
        "DescriptionMarkdown": "With host and host fxr source moving to upstream repos (planned early 12/2018) we need to be able to continue to produce the installers and packages.",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3351",
        "CreatedAt": "2018-11-19T20:47:25+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": false,
        "Title": "Deployment and Servicing guidance for customers",
        "DescriptionMarkdown": "- Particularly for Windows desktop UI scenarios\n- How can enterprise customers deploy their apps to Windows clients?\n- How can enterprise customers service .NET Core to Windows clients?\n- How can customers author MSIX deployments via VS?",
        "Milestone": "6.0.0",
        "Assignees": [
          "dleeapho"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3350",
        "CreatedAt": "2018-11-19T20:40:01+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Runtime Pack netcoreapp packaging",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3347",
        "CreatedAt": "2018-11-19T20:36:57+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Targeting Pack: netcoreapp packaging",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3343",
        "CreatedAt": "2018-11-19T20:31:55+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Shared Framework installer and common infrastructure",
        "DescriptionMarkdown": "1. Identify, and report redundancy of  common assemblies carried in multiple Shared Frameworks.\n2. Drive discussions among Technology owners, team doesn\u0027t own the decision or its delivery.\n3. Define requirement and provide common tooling to produce Shared Framework and installers.",
        "Milestone": "5.0.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3342",
        "CreatedAt": "2018-11-19T20:24:39+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Customer-facing packages and installers have correct branding and naming",
        "DescriptionMarkdown": "- particularly new Windows desktop UI\n- also localized branding",
        "Milestone": "3.1",
        "Assignees": [
          "dleeapho"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#9385",
        "CreatedAt": "2017-12-05T18:45:43+00:00",
        "CreatedBy": "brianrob",
        "IsClosed": true,
        "Title": "Tracing Epic",
        "DescriptionMarkdown": "",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "c6415a"
          },
          {
            "Name": "area-Tracing-coreclr",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 1,
        "ProjectStatus": null
      },
      "Children": []
    }
  ],
  "Assignees": [
    null,
    "AaronRobinsonMSFT",
    "agocke",
    "alnikola",
    "anurse",
    "bradygaster",
    "cartermp",
    "cathysull",
    "dagood",
    "dleeapho",
    "elinor-fung",
    "geoffkizer",
    "glennc",
    "halter73",
    "jamshedd",
    "jeffhandley",
    "jeffschwMSFT",
    "jkoritzinsky",
    "jkotas",
    "karelz",
    "layomia",
    "ManickaP",
    "MihaZupan",
    "nkolev92",
    "richlander",
    "samsp-msft",
    "scalablecory",
    "sfoslund",
    "steveharter",
    "swaroop-sridhar",
    "tarekgh",
    "terrajobst",
    "thaystg",
    "tommcdon",
    "Tratcher",
    "vitek-karas",
    "VSadov",
    "zivkan",
    "zkat"
  ],
  "Milestones": [
    null,
    ".NET 5",
    "1.0.0-preview1",
    "1.0.0-preview2",
    "1.0.0-preview3",
    "1.0.0-preview4",
    "1.0.0-preview6",
    "3.0",
    "3.1",
    "5.0.0",
    "5.0.1xx",
    "6.0.0",
    "Backlog",
    "Future",
    "Sprint 174 - 2020.07.27",
    "Sprint 175 - 2020.08.17",
    "Sprint 177 - 2020.09.28",
    "Sprint 178 - 2020.10.19",
    "YARP 1.0.0",
    "YARP 1.0.0-preview7"
  ],
  "Releases": [
    null,
    ".NET 6.0"
  ],
  "States": [
    null,
    "In progress",
    "Proposed"
  ]
}
{
  "Roots": [
    {
      "Issue": {
        "Id": "dotnet/core#5397",
        "CreatedAt": "2020-10-20T00:01:50+00:00",
        "CreatedBy": "samsp-msft",
        "IsClosed": false,
        "Title": ".NET is recognized as a compelling framework for building cloud native apps",
        "DescriptionMarkdown": "(placeholder)\r\nToday, .NET is seen as a stack for enterprises building LOB applications. \u201C.NET is for people who work at banks\u201D is not uncommon feedback in our customer interviews. We plan to change that by building great fundamentals and investing in OSS ecosystems that give us a platform to reach new customer bases. At the same time our existing enterprise customers want to become more Cloud Native, and we need to flatten the learning curve and barriers to adoption.\r\n\r\n\r\nScenario Areas\r\n\r\n- [ ] Improve development experience for multi-app solutions\r\n- [ ] .NET Apps can depend on containers in Dev\r\n- [ ] Ship an extensible reverse proxy https://github.com/microsoft/reverse-proxy/issues/480\r\n- [ ] Simplified API experience for Web API apps\r\n- [ ] Optimizations for Constrained Environments \r\n- [ ] Libraries to interop with common cloud native components/services\r\n",
        "Milestone": null,
        "Assignees": [
          "glennc"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          }
        ],
        "Kind": 0,
        "ProjectStatus": {
          "ProjectName": ".NET 6.0",
          "Column": "Proposed"
        }
      },
      "Children": [
        {
          "Issue": {
            "Id": "microsoft/reverse-proxy#480",
            "CreatedAt": "2020-10-20T00:06:06+00:00",
            "CreatedBy": "samsp-msft",
            "IsClosed": false,
            "Title": "Ship an extensible reverse proxy",
            "DescriptionMarkdown": "(Planning item)\r\nAs a cloud native infrastructure/service developer (cohort 3), I want a reverse proxy solution that is customizable to my needs and performant enough for cloud scale workloads.\r\n\r\n\u003Ctodo: pull in items from project board\u003E\r\n",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "5454c9"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/core#5366",
        "CreatedAt": "2020-10-15T22:29:35+00:00",
        "CreatedBy": "bradygaster",
        "IsClosed": false,
        "Title": "Meeting Developer Expectations",
        "DescriptionMarkdown": ".NET 5 introduced more incremental improvements for applications to realize faster startup times and smaller exe sizes using single file and app trimming. As we look ahead on how we continue to make .NET a compelling platform for developers to build their modern apps on, we will continue to evolve the platform by building on top of what .NET 5 has brought to the ecosystem.\r\n\r\nExperiences under this epic:\r\n\r\n- [ ] Experience: Make .NET a good choice for environments that require single file and AOT https://github.com/dotnet/runtime/issues/43538\r\n- [ ] Experience: Deliver on the remaining .NET Core customer promises from .NET 5 #5395\r\n- [ ] Experience: Increase coverage of Machine Learning models for ML.NET\r\n- [ ] Enable APIs to be discoverable and integrated in the Power Platform\r\n  - [ ] Experience: Enabling Power Platform Scenarios with HTTP APIs #5367\r\n  - [ ] Experience: HTTP API Testing Tools #5368",
        "Milestone": null,
        "Assignees": [
          "cathysull"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          }
        ],
        "Kind": 0,
        "ProjectStatus": {
          "ProjectName": ".NET 6.0",
          "Column": "Proposed"
        }
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#43538",
            "CreatedAt": "2020-10-16T21:25:31+00:00",
            "CreatedBy": "samsp-msft",
            "IsClosed": false,
            "Title": "Make .NET a good choice for environments that require single file and AOT",
            "DescriptionMarkdown": "# Why\r\n.NET 5 introduced more incremental improvements for applications to realize faster startup times and smaller exe sizes using single file and app trimming. As we look ahead on how we continue to make .NET a compelling platform for developers to build their modern apps on, we need to continue to evolve the platform by building on top of what .NET 5 has brought to the ecosystem. AOT in particular, is an area where we need to start to make more investments, which will likely span across several upcoming releases of .NET. Many developers want a specific solution when they refer to \u201CAOT.\u201D They want a solution that has the following characteristics: extremely fast startup, no IL present (for size and obfuscation reasons), a JIT is (at most) optional, and binary size is as small as it can be. We use the term \u201Cnative AOT\u201D to describe that point on the AOT spectrum. The single file solution we have in .NET 5.0 doesn\u2019t satisfy this definition of AOT. It\u2019s a big step forward, but it isn\u2019t \u201Cnative AOT.\u201D\r\n\r\nA recent [Native AOT community survey](https://github.com/dotnet/runtime/issues/41522), showed us that there\u2019s more of a need to officially support native AOT in .NET. 52% of our survey respondents (n=1,344) told us that they would like to write more projects in .NET (but can\u2019t) or have written .NET projects in a different environment (Rust and Go) because of missing native AOT options.\r\n\r\n# Summary\r\nThis objective describes the continued investment and evolution in the features and integration of single file, trimming, and source generators (to name just a few). Many of these areas are complimentary to each other such that a characteristic of source generators for example is that it can help remove major barriers to linker-based and AOT (ahead-of-time) compilation optimizations.\r\n\r\nMany of these areas will require ecosystem and library authors to participate in as well (i.e. trimming) and we will need to build specific tooling to enable these features to be utilized in libraries and will need an outreach program for them as well. We\u2019ve also identified that many of the top NuGet packages people make heavy use of reflection to discover types at runtime. Incorporating these packages is essential for most .NET apps, so the \u201Clinkability\u201D and ability for your code to make use of AOT compiler optimizations is greatly affected. We\u2019re looking forward to working with our wonderful OSS community to see how these packages could use source generators and improve the overall .NET ecosystem.\r\n\r\n# User Stories\r\n\r\n- [ ] Start the journey to enable Native AOT in runtimelabs https://github.com/dotnet/runtimelab/issues/248\r\n- [ ] Developers can confidently generate single file apps that work for the supported target platforms #43540\r\n- [ ] Annotate more .NET libraries (trimming) and guidance for library authors #43543\r\n- [ ] Expand .NET WebAssembly Capabilities\r\n- [ ] Support assembly load context throughout the product #43544\r\n- [ ] Source generators continue to assist with runtime and framework features #43545",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              },
              {
                "Name": "area-Meta",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "untriaged",
                "BackgroundColor": "fbca04"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/runtimelab#248",
                "CreatedAt": "2020-10-19T17:54:42+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Start the journey to enable Native AOT in runtimelabs",
                "DescriptionMarkdown": "The demand for native AOT is growing, and not having a solution will drive customers to other platforms such as Rust \u0026 GoLang. A trend that we are seeing across the industry is that for security reasons hosting environments are setting requirements that code pages need to be read-only which prevent the JIT-ing model which is core to .NET code execution. \r\n\r\nWe cannot afford to ignore the native AOT scenario, nor can we go dark and wait for a complete implementation. We need to evolve this area in Runtime Labs, and grow the capabilities to support additional work loads, with the expectation that it will not be for everyone - .NET needs to have both JIT and AOT capabilities to enable the broadest cross-section of solutions. This high level section sets our intention to invest in native AOT scenarios and more definition from the teams will be needed to define our phased approach over the next few .NET releases.\r\n\r\n# Work Items\r\n\r\n- [ ] Developer experience\r\n  - [ ] Developers have a way to tell IDE that they are targeting Native AOT \r\n  - [ ] Developers should be shown errors/warnings for AOT incompatible code during development\r\n  - [ ] Inner loop experience for AOT projects\r\n- [ ] Framework annotations - shared with Trimming\r\n  - [ ] Additional annotations for Native AOT specific problem areas\r\n- [ ] Blazor Experience\r\n",
                "Milestone": null,
                "Assignees": [
                  "richlander",
                  "jkotas",
                  "jeffschwMSFT",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-NativeAOT",
                    "BackgroundColor": "d4c5f9"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43540",
                "CreatedAt": "2020-10-16T21:41:41+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Developers can confidently generate single file apps that work for the supported target platforms",
                "DescriptionMarkdown": "Single file apps are a journey, we progressed from a self-extract approach in 3.x to a superhost in 5.0, but there is more to be done to complete the story. Single file apps need to work for every .NET workload and app framework where the target platform allows for it (to reduce developer perceived complexity of seeing several output files vs one output file), including:\r\n* Winforms\r\n* WPF\r\n* MAUI\r\n* ASP.NET including MVC, Razor Pages, Server-side Blazor, WebAPI, gRPC etc.\r\n\r\nGoals:\r\n* Predictability: Developers should be aware of what will and won\u0027t work in a single file experience\r\n   * Ensuring that referenced libraries are also not going to produce issues\r\n* Completeness for specific workloads\r\n\r\n# Work Items\r\n- [ ] Flush out testing for each of the scenarios\r\n- [ ] Extend superhost beyond Linux #43071\r\n  - [ ] Create superhost for Windows\r\n  - [ ] Create superhost for MacOS\r\n- [ ] Enable debugging of superhost apps with Visual Studio\r\n- [ ] Tooling \u0026 Experience\r\n  - [ ] Add analyzers for common issues that occur with single file apps, such as file path resolution from the assembly\r\n  - [ ] Integrate the analyzers into Visual Studio\r\n  - [ ] Add attribute to decorate places which are incompatible with single file\r\n",
                "Milestone": null,
                "Assignees": [
                  "agocke",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": [
                {
                  "Issue": {
                    "Id": "dotnet/runtime#43071",
                    "CreatedAt": "2020-10-06T01:17:26+00:00",
                    "CreatedBy": "agocke",
                    "IsClosed": false,
                    "Title": "Superhost for Windows \u0026 Mac",
                    "DescriptionMarkdown": "All native runtime libraries should be statically linked into a single file host for Windows \u0026 Mac.\r\n\r\n- [ ] Link \u0060clrjit\u0060 and \u0060coreclr\u0060 #43072 \r\n- [ ] Debugging support",
                    "Milestone": "6.0.0",
                    "Assignees": [],
                    "Labels": [
                      {
                        "Name": "Team Epic",
                        "BackgroundColor": "754fff"
                      },
                      {
                        "Name": "area-Single-File",
                        "BackgroundColor": "d4c5f9"
                      }
                    ],
                    "Kind": 3,
                    "ProjectStatus": null
                  },
                  "Children": [
                    {
                      "Issue": {
                        "Id": "dotnet/runtime#43072",
                        "CreatedAt": "2020-10-06T01:19:33+00:00",
                        "CreatedBy": "agocke",
                        "IsClosed": false,
                        "Title": "Link \u0060clrjit.dll\u0060 and \u0060coreclr.dll\u0060 into Windows/Mac host",
                        "DescriptionMarkdown": "Part of the process of getting a superhost on Windows\u002BMac",
                        "Milestone": "6.0.0",
                        "Assignees": [
                          "VSadov"
                        ],
                        "Labels": [
                          {
                            "Name": "area-Single-File",
                            "BackgroundColor": "d4c5f9"
                          }
                        ],
                        "Kind": 3,
                        "ProjectStatus": null
                      },
                      "Children": []
                    }
                  ]
                }
              ]
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43543",
                "CreatedAt": "2020-10-16T22:27:17+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Annotate more .NET libraries (trimming) and guidance for library authors",
                "DescriptionMarkdown": "The trimming story is a journey where we are improving the capabilities release to release. With .NET 5, we have added the linker capability for trimming and started the annotation effort for the framework.\r\n\r\nFor an application to be correctly fully trimmable, we need to know all the places where dynamic code patterns such as reflection and reflection emit are used. Along with that we will provide annotations for the linker so that it knows how to find the required types so that they are not trimmed, provide a source generator equivalent, or if the functionality is inherently supportable in conjunction with trimming then to provide an error to the app developer.\r\n\r\n# Goals\r\n\r\n* Developers should have clarity on whether the application will be trimmable\r\n* Trimming should be possible for all mainline scenarios. Work with owners for each of the workloads to:\r\n  * define the mainline scenarios\r\n  * remove / mitigate issues in libraries for the mainline scenarios\r\n  * supply representative apps for validation\r\n* Linker should produce an error for every case where trimming will fail\r\n* Remove \u0022Preview\u0022 tag from the trimmer\r\n* Enable trimming for the following app types:\r\n  * Blazor\r\n  * Mobile apps\r\n  * ASP.NET\r\n  * Console apps\r\n  * Ideally an additional UI framework (e.g. WinForms or WPF)\r\n\r\n## Annotating the framework\r\n\r\nThis is a recursive initiative as each layer of the onion will potentially increase the surface area that can be trimmable and uncover additional APIs that need to be annotated. Decisions on which APIs should be focused on should be driven by usage stats (if we have them).\r\n\r\n## Annotating Libraries\r\n\r\nMost customer applications make use of libraries from third parties, commonly via NuGet, those also need to be annotated for trimming. We need to provide tooling to assist the developers in determining which of their APIs need to be annotated, and how to annotate them. The current library analysis uses hidden command line switches and needed to be augmented with custom tools created by the engineer currently working on annotations. The experience needs to be exposed in Visual Studio for both library consumers and library authors, with the ability to drill into the specifics of which API dependencies are causing issues.\r\n\r\nWe will need an outreach program for library authors, and probably have a way to filter out packages that are not trimmable from NuGet searches.\r\n\r\n## AOT annotations\r\n\r\nAll the annotations for trimming also assist in native AOT scenarios, as that has the same problem with not being able to determine dependencies when reflection is used. There are some additional limitations of native AOT that needs similar annotations to the attributes used for trimming. This should be added early so that the annotation exercise can consider both scenarios.\r\n\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "jeffschwMSFT",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43544",
                "CreatedAt": "2020-10-16T22:41:22+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Support assembly load context throughout the product",
                "DescriptionMarkdown": "The assembly load context has been rather successful in solving a large set of customer problems. The most prominent one is the so called \u201Cplugin\u201D model where the application (host) loads other components to augment its functionality in some way. Such components are typically loaded into separate load contexts to avoid dependency collisions. Additionally, in some apps it\u2019s also desirable to be able to eventually unload such components either to free resources or to enable update of the component.\r\n\r\nProducing such applications has proven rather challenging in the current state of .NET Core because there are certain parts of the frameworks produces by us which are not compatible with multiple load contexts and/or unload ability.\r\nWe should drive the frameworks we own to fix these issues so that customer\u2019s code doesn\u2019t have to handle issues in frameworks they rely on. We should focus this effort on certain application types first to prioritize the work. We\u2019ve seen feedback on mainly ASP.NET and WPF applications. There might be overlap with the \u201Cfaster inner loop\u201D effort which would affect the prioritization as well.\r\n\r\nThe work can be split into two parts (and prioritized differently):\r\n* Given feature works correctly in presence of secondary load context \u2013 for example XamlParser has problems when used with assemblies in non-default load context. Similarly, ASP.NET\u2019s hosting code also doesn\u2019t work well in such a scenario. It might be possible to use static analyzers to detect some of the problems in this area.\r\n* Usage of a given feature doesn\u2019t prevent secondary load context from unloading correctly \u2013 for example TypeConverter holds onto all types which were used with it, and thus prevents unloading of such types. Static analyzers are probably not going to help in this area.\r\n\r\nIn both cases an important part of the work should be a general approach to testing \u2013 for example reuse existing test assets but run them under different conditions and providing customer guidance for first \u0026 third parties.\r\n\r\n# Work Items\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "vitek-karas",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43545",
                "CreatedAt": "2020-10-16T22:43:05+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Improve framework trimming using source generators",
                "DescriptionMarkdown": "Source Generators are a new technology that was added to Roslyn in the .NET 5 timeframe, but we have not yet utilized them by creating generators to assist with runtime and framework features. We will work to define customer scenarios in more detail here with customer development, but one apparent area is in ASP.NET reveal where there are limitations that can be solved by source generators.\r\n\r\nGenerators should be investigated/added for the following prioritized scenarios:\r\n\r\n- [ ] Trimming / Blazor / Native \u0026 Mono AOT \u2013 source generators can be used to convert code that does reflection.emit at runtime to source generators which will create code at build time rather than runtime. The generated code can then be analyzed by the illinker or native AOT enabling those scenarios.\r\n- [ ] Dependency Injection \u2013 is an important part of ASP.NET startup that could be replaceable with code generation at build time.\r\n- [ ] System.Text.Json serialization \u2013 code generators can work around the need for runtime reflection, and generate serializers for specific classes.\r\n- [ ] EventSource \u2013 event source uses reflection.emit to simplify creation of classes (manifests) for custom event sources \u2013 this can be changed to a build-time activity using source generators.\r\n- [ ] Regular Expressions \u2013 can be converted from using reflection.emit to build-time source generation, improving the startup time, making them fast in AOT, and possible in native AOT (Bing recently requested this \u2013 fast startup and fast regex).\r\n- [ ] Marshaling interop\r\n",
                "Milestone": null,
                "Assignees": [
                  "vitek-karas",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/core#5395",
            "CreatedAt": "2020-10-19T22:54:17+00:00",
            "CreatedBy": "cathysull",
            "IsClosed": false,
            "Title": "Deliver on the remaining .NET Core customer promises from .NET 5",
            "DescriptionMarkdown": "# Why\r\nIn .NET 5, many factors contributed to the fact that some features were developed in one area, and were not always supported across the entire stack or for all workloads. While many of these features are dialable, investing in finishing these promises will both help .NET developers to better adopt these platform features as we continue to evolve the .NET platform. \r\n\r\n# Summary\r\nFinishing the remaining promises from .NET 5 includes features that support cross-cutting platform enablement and ensure that we have a more complete end-to-end experience in the .NET platform. Many of these features will require more definition and scoping during .NET 6 planning beyond what is described in the User Stories below.\r\n\r\n# User Stories\r\n\r\n- [ ] Expand platform compat annotations to cover more configurations https://github.com/dotnet/runtime/issues/43616\r\n- [ ] Support more Analyzers \u0026 Code Fixers https://github.com/dotnet/runtime/issues/43617\r\n- [ ] Complete Nullable annotations for more of the framework https://github.com/dotnet/runtime/issues/43619\r\n- [ ] Expanding Linker tooling in VS\r\n- [ ] Finish System.Text.Json https://github.com/dotnet/runtime/issues/43620\r\n- [ ] Support HTTP3 in .NET 6 https://github.com/dotnet/runtime/issues/43546",
            "Milestone": null,
            "Assignees": [
              "cathysull"
            ],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/runtime#43616",
                "CreatedAt": "2020-10-19T23:05:25+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Expand platform compat annotations to cover more configurations",
                "DescriptionMarkdown": "In .NET 5 we started with annotations for features and APIs which are not universally available everywhere. We picked Windows and browsers as the initial targets for the experience. To make the experience complete we need to continue annotating remaining platforms we support (e.g. Linux-specific APIs that we expect to add). It goes beyond this as well.  It\u0027s certainly a \u0022last mile\u0022 experience, but for example today you won\u0027t get any warnings if you try to use MemoryMappedFile.CreateNew(string, ...) with a non-null string path, even though only a null string path is supported on Linux and macOS. The current platform analyzer doesn\u0027t account for such possibilities, with annotations done to just say \u0022if any usage of this API works on a platform, then consider it supported on that platform\u0022. We should look at what APIs fall into those partially-supported buckets and consider ways of improving the experience around them. This might be the next issue developers porting to .NET 5 get hung up on from a cross-platform perspective.\r\n\r\nWe also realized that the platform vertical is not the only limiting factor for APIs availability. There are others based primarily on workload limitations which should offer developers the same experience. We will expand compatibility annotations to cover configurations such as AOT, self-contained bundles and single file.\r\n\r\nThe projects which benefits most from the annotations are large scale solutions with many dependencies which are usually not available as a source code implementation. Exploring how to run the analysis on the final output would further improve the impact of tooling.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43617",
                "CreatedAt": "2020-10-19T23:09:52+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Support more Analyzers \u0026 Code Fixers",
                "DescriptionMarkdown": "In .NET 5, we shipped approximately 250 analyzers with the .NET SDK. Many of them already existed but were shipped out-of-band as NuGet packages. Now, .NET comes with an in-depth code analysis and code fixer experiences. This means developers don\u0027t have to purely rely on their choices based on reading code completion; .NET can help them pro-actively identify when their code has issues, right from the start. However, many of the code analyzers created don\u2019t come with code fixers yet. We will look at telemetry and customer feedback to prioritize (around a TBD set of principles) which code analyzers would most benefit from code fixers along with which are most popular and consider adding fixers for those. Also, there is a sizable backlog of code analyzers that didn\u0027t get included in .NET 5, which will need to prioritized and considered. Furthermore, our goal for .NET 6 is that new features in .NET 6 should come with analyzers.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43619",
                "CreatedAt": "2020-10-19T23:14:51+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Complete Nullable annotations for more of the framework",
                "DescriptionMarkdown": "In .NET 5, 94% of Microsoft.NetCore.App has been completed, which is the lowest layer in the shared framework and represents the set of APIs that are referenced by default by all applications types. We\u2019ll work to get this number to 100% and we intend to maintain 100% coverage into the future.\r\n\r\nWhat\u2019s still missing are the higher layers (WPF, WinForms, ASP.NET Core) as well as the out-of-band packages (such as EFCore and several out-of-band packages from dotnet/runtime, as well as assemblies that aren\u0027t in netcoreapp but are included with aspnetcoreapp). While each is likely to be too big to be completed in .NET 6, we will start planning and making inroads for the rest of the stack and decide if we are comfortable introducing new libraries which may have no nullable annotations (e.g. mobile SDKs/Forms for .NET 6). An MVP (minimum viable product) for this, we believe (and will test) that any new libraries are annotated, moving forward nullable reference types are just part of the language, and when you decide the data type of some method parameter or return value, it\u0027s just one of the things you need to factor in, just as we need to factor in new types added in the libraries, new language features around optional parameters or params arguments and such things.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43620",
                "CreatedAt": "2020-10-19T23:17:17+00:00",
                "CreatedBy": "cathysull",
                "IsClosed": false,
                "Title": "Finish System.Text.Json",
                "DescriptionMarkdown": "There are about 200 open issues for JSON and community engagement continues to be high along with direct asks from authors like NSwag. There are still have some missing features that prevents System.Text.Json to be successful as the standard JSON stack for .NET. Two major areas of investment are beefing up the serialization support (~20 features) and providing a source generator for JSON serialization to make it friendly for trimming.\r\n\r\n# Work Items\r\n\r\n- [ ] TBD",
                "Milestone": null,
                "Assignees": [
                  "terrajobst"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-System.Text.Json",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            },
            {
              "Issue": {
                "Id": "dotnet/runtime#43546",
                "CreatedAt": "2020-10-16T23:36:49+00:00",
                "CreatedBy": "samsp-msft",
                "IsClosed": false,
                "Title": "Support HTTP3 in .NET 6",
                "DescriptionMarkdown": "HTTP3 is the next major version of HTTP and the successor to HTTP2. It is in the final stages of standardization in the IETF. Some browsers (notably Chrome) already support draft versions of HTTP3. HTTP3 runs over QUIC, which replaces TCP as the underlying transport. QUIC is also in the final stages of standardization in the IETF. It provides secure, multiplexed streams over UDP. QUIC is a general-purpose, extensible transport protocol and we expect it to be used by other application protocols aside from HTTP3.\r\n\r\nFor .NET 6.0, we plan to deliver the following capabilities:\r\n- [ ] A set of public classes for using the QUIC protocol on either client or server. This is System.Net.Quic. It is the equivalent of System.Net.Sockets for the QUIC protocol.\r\n - [ ] HTTP3 client support in HttpClient/SocketsHttpHandler.\r\n- [ ] HTTP3 server support in Kestrel/ASP.NET.\r\n\r\nWe have already made some progress on this in .NET 5.0 and are delivering HTTP3 support in a \u201Cpreview\u201D, unsupported capacity. There is no public API for QUIC in .NET 5.0.\r\n\r\nWe intend to share as much HTTP3 code as is reasonably possible between the client and server implementation.",
                "Milestone": null,
                "Assignees": [
                  "geoffkizer",
                  "samsp-msft"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  },
                  {
                    "Name": "area-Meta",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "untriaged",
                    "BackgroundColor": "fbca04"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "In progress"
                }
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/core#5367",
            "CreatedAt": "2020-10-15T22:53:09+00:00",
            "CreatedBy": "bradygaster",
            "IsClosed": false,
            "Title": "Enable Power Platform Scenarios with HTTP APIs",
            "DescriptionMarkdown": "Since November 2019, we\u2019ve done significant work to improve the overall end-to-end experience for developers who need to extend PowerApps (or any other Power Platform resource). The goals of this multi-organization partnership spanning DevDiv, Azure, and Power Platform, have been to enable the following application development scenario: \r\n\r\n1. A citizen developer needs to build a business app using PowerApps. \r\n2. The PowerApp needs to use existing application infrastructure, so the citizen dev works with a .NET developer who is either building or who has already built and deployed an existing HTTP API. \r\n3. The API developer creates a PowerApps Custom Connector to give the citizen developer a connection to the HTTP API. \r\n4. The citizen developer uses the connection to the HTTP API to build their PowerApp. \r\n5. The citizen developer makes the PowerApp available to users in their enterprise via Teams. \r\n\r\nSince the partnership began in November, we\u2019ve accomplished significant strides across all partner teams, and now ASP.NET Core Web API customers have a clear path to getting HTTP APIs published into Azure API Management, which makes them easy to ingest into PowerApps.  \r\n\r\nUser Stories under this Experience:",
            "Milestone": null,
            "Assignees": [
              "bradygaster"
            ],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/core#5368",
            "CreatedAt": "2020-10-15T23:02:48+00:00",
            "CreatedBy": "bradygaster",
            "IsClosed": false,
            "Title": "HTTP API Testing Tools",
            "DescriptionMarkdown": "As the investments we make into building out HTTP APIs for use in the Power Platform take shape, an interesting by-product is that we\u2019re hearing from more developers that they need a way to call their APIs from clients hosted somewhere else. Consider the following scenarios in which developers are building HTTP APIs for use by either Azure or Power Platform clients: \r\n\r\n1. A developer needs to create an Azure Function that, given an ID, gets an order from a database and sends an adaptive card to a Teams channel representing the products in the order. The Function will be called within a Logic App.  \r\n2. A citizen developer is building a mobile app to replace an internal supply chain implemented using an intranet site. The product database page will be replicated as an HTTP API that will be called from a PowerApp. \r\n\r\nIn both scenarios a developer needs to build a \u201Cclient\u201D for an API on which they\u2019re also developing. In the Logic App scenario, a developer needs to be able to debug an HTTP API running on localhost but call that HTTP API from a Logic App running in Azure. In the PowerApp scenario, a citizen dev using the PowerApps maker experience \u2013 a web-based IDE \u2013 will be building and testing a app in a web browser.  \r\n\r\nIn both scenarios, the \u201Cclient\u201D will need to call the API, and the API developer will need a way to receive those calls and to step through their code using the rich debugging tools present in the Visual Studio family of products. But in both scenarios, the \u201Cclient\u201D will need a tunnel to localhost, as both are running on the open internet.  \r\n\r\nDevelopers need an \u201CF5 to Localhost Tunnel\u201D experience to answer this problem. \r\nUser Stories under this Experience:",
            "Milestone": null,
            "Assignees": [
              "bradygaster"
            ],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/core#5238",
        "CreatedAt": "2020-09-22T01:51:59+00:00",
        "CreatedBy": "jamshedd",
        "IsClosed": false,
        "Title": "Enterprise and LTS",
        "DescriptionMarkdown": ".NET 6.0 will be a Long-Term Support (LTS) release. We see many enterprises prefer our LTS releases over Current releases for their longer support (relative to Current releases), they pick an LTS version so they don\u2019t have to move forward every year. This is not very different from what we see with OS LTS versions \u2013 enterprise customers go from one LTS to the next and skip the in-between SAC releases. Since .NET 6.0 will be the successor to 3.1 LTS we expect customers presently using 3.1 LTS and wanting to target the next LTS will pick 6.0 LTS. We will support 3.1 through December 2022, so once .NET 6.0 ships, customers will have 1 year to plan for, rebuild and test their apps and complete their deployment. Customers that cannot migrate their apps to 6.0 in this timeframe will probably ask us to provide longer support.  \r\n\r\nIf customers can successfully complete their migration forward in this 1-year period everyone benefits. So, it is in everyone\u2019s interest that we do everything we can to enable customers to come forward to 6.0 as easily, smoothly and quickly as possible. \r\n\r\nExperiences under this Epic:\r\n\r\n- [ ] [Enterprises have a first class experience acquiring and deploying .NET 6.0](https://github.com/dotnet/core/issues/5240).\r\n- [ ] [Enterprises get first-class support when using .NET 6.0 on Linux](https://github.com/dotnet/core/issues/5333).\r\n- [ ] [Path to migrate an app from Framework to .NET 6.0 is well understood and streamlined](https://github.com/dotnet/core/issues/5396)",
        "Milestone": null,
        "Assignees": [
          "jamshedd"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          }
        ],
        "Kind": 0,
        "ProjectStatus": {
          "ProjectName": ".NET 6.0",
          "Column": "Proposed"
        }
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/core#5240",
            "CreatedAt": "2020-09-22T02:05:57+00:00",
            "CreatedBy": "jamshedd",
            "IsClosed": false,
            "Title": "Enterprises have a first class experience acquiring and deploying .NET 6.0",
            "DescriptionMarkdown": "User Stories under this Experience:\r\n\r\n- [ ] [As an IT Pro I have easy access to .NET Core installer release information and scripts in my air gapped environment so I can use this to determine which updates need to be deployed](https://github.com/dotnet/core/issues/5241).\r\n",
            "Milestone": null,
            "Assignees": [
              "jamshedd"
            ],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/core#5241",
                "CreatedAt": "2020-09-22T02:12:28+00:00",
                "CreatedBy": "jamshedd",
                "IsClosed": false,
                "Title": "As an IT Pro I have easy access to .NET Core installer release information and scripts in my air gapped environment so I can use this to determine which updates need to be deployed. ",
                "DescriptionMarkdown": "Multiple customers need a way to deploy their app along with the dependent Core runtime to private clouds. This is difficult for them today because the installers/bits are only available on the public CDN and public Azure blob storage. Also the tools, scripts and release metadata we offer today is designed to work with these public end points.  Each customer is working around this in a different way, for e.g. one customer is packaging our installer with their source build in order to piggy-back with the build to get it over to the air-gapped cloud. Another is copying over bits from our public blob storage to their private blob storage and maintains its own version of install scripts that go to the private blob. We have work to do here to make it easier for customers that need to use Core in air-gapped scenarios. \r\n\r\nA key question is which distributions types (zips, MSIs, debs, containers) are the most critical to participate in air-gapped flows. Also, Azure- air-gapped versus on-prem air-gapped. \r\n \r\nThis area needs further customer development.  ",
                "Milestone": null,
                "Assignees": [
                  "jamshedd"
                ],
                "Labels": [
                  {
                    "Name": "User Story",
                    "BackgroundColor": "FFA500"
                  }
                ],
                "Kind": 2,
                "ProjectStatus": {
                  "ProjectName": ".NET 6.0",
                  "Column": "Proposed"
                }
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/core#5333",
            "CreatedAt": "2020-10-12T02:20:11+00:00",
            "CreatedBy": "jamshedd",
            "IsClosed": false,
            "Title": "Enterprises get first-class support when using .NET 6.0 on Linux",
            "DescriptionMarkdown": "\r\n\r\nUser Stories under this Experience:\r\n\r\n- [ ] [Title of the linked User Story](hyperlink to the User Story issue).\r\n",
            "Milestone": null,
            "Assignees": [
              "jamshedd"
            ],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/core#5396",
            "CreatedAt": "2020-10-19T23:26:10+00:00",
            "CreatedBy": "cathysull",
            "IsClosed": false,
            "Title": "Path to migrate an app from Framework to .NET 6.0 is well understood and streamlined",
            "DescriptionMarkdown": "\r\n# User Stories\r\n\r\n- [ ] TBD",
            "Milestone": null,
            "Assignees": [
              "cathysull"
            ],
            "Labels": [
              {
                "Name": "Experience",
                "BackgroundColor": "3BB9FF"
              }
            ],
            "Kind": 1,
            "ProjectStatus": {
              "ProjectName": ".NET 6.0",
              "Column": "Proposed"
            }
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#43313",
        "CreatedAt": "2020-10-12T17:15:15+00:00",
        "CreatedBy": "sdmaclea",
        "IsClosed": false,
        "Title": "Support Apple Silicon",
        "DescriptionMarkdown": "Apple has [announced plans to transition its Mac hardware line]( https://www.apple.com/newsroom/2020/06/apple-announces-mac-transition-to-apple-silicon/) to a new Arm64-based chip that they refer to as \u201CApple Silicon\u201D. This epic tracks the high level status of the milestones required to ship this feature in .NET 6.\r\n\r\n.NET 6 will include new runtime id -- \u0060osx-arm64\u0060 -- for targeting this hardware. It refers to the macOS operating system running on Apple Silicon devices.\r\n\r\n### .NET 6 - CoreCLR\r\n\r\n**Functionality**\r\n- [x] Support compilation targeting osx-arm64\r\n- [x] Modify code generation to support osx-arm64 security features\r\n- [ ] Modify code generation to support osx-arm64 interop with native libraries\r\n\r\n**Testing**\r\n- [x] Apple Silicon Prototype hardware available \r\n- [x] Manual testing of basic inner and outer loop tests \r\n- [ ] Apple commercially shipping arm64 macos devices\r\n- [ ] CI/CD Testing enabled\r\n- [ ] CI/CD Stress testing enabled\r\n\r\n**Stability**\r\n- [x] Basic tests passing rate \u003E 99%\r\n- [ ] Stress tests passing rate \u003E 99%\r\n- [ ] All tests passing rate \u003E 99.9%\r\n\r\n**Availability**\r\n- [x] .NET Core runtime nightly builds available\r\n- [ ] ASP.NET Core runtime nightly builds available\r\n- [ ] .NET Core SDK nightly builds available\r\n- [ ] .NET 6 preview available\r\n- [ ] .NET 6 release available\r\n\r\n**Details**\r\n\r\nSee [Enable .NET Core on Apple Silicon](https://github.com/orgs/dotnet/projects/18) for the full set of related PRs and issues.\r\n\r\n### .NET 6 - Mono\r\n**Functionality**\r\n- [ ] Support compilation targeting osx-arm64\r\n- [x] Modify code generation to support osx-arm64 security features\r\n- [ ] Modify code generation to support osx-arm64 interop with native libraries\r\n\r\n**Testing**\r\n- [x] Apple Silicon Prototype hardware available \r\n- [ ] Manual testing of basic inner and outer loop tests \r\n- [ ] Apple commercially shipping arm64 macos devices\r\n- [ ] CI/CD Testing enabled\r\n- [ ] CI/CD Stress testing enabled\r\n\r\n**Stability**\r\n- [ ] Basic tests passing rate \u003E 99%\r\n- [ ] Stress tests passing rate \u003E 99%\r\n- [ ] All tests passing rate \u003E 99.9%\r\n\r\n**Availability**\r\n- [ ] Runtime nightly builds available\r\n- [ ] .NET 6 preview available\r\n- [ ] .NET 6 release available\r\n\r\n/cc @richlander @mangod9 @janvorli @JulieLeeMSFT @sandreenko @tommcdon @steveisok @directhex @akoeplinger @jeffschwMSFT ",
        "Milestone": "6.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "arch-arm64",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "os-mac-os-x-big-sur",
            "BackgroundColor": "fef2c0"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#41478",
        "CreatedAt": "2020-08-27T21:54:53+00:00",
        "CreatedBy": "HongGit",
        "IsClosed": true,
        "Title": "WCF Team Issues",
        "DescriptionMarkdown": "Group of issues include the following areas:\n- System.Serialization\n- System.Runtime.Caching\n- System.Syndication\n- System.Distribution",
        "Milestone": null,
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-System.ServiceModel.Syndication",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#41313",
        "CreatedAt": "2020-08-25T03:03:59+00:00",
        "CreatedBy": "layomia",
        "IsClosed": false,
        "Title": "JsonSerializer improvements in .NET 5",
        "DescriptionMarkdown": "In 5.0, we have added new features to \u0060JsonSerializer\u0060, improved performance and reliability, and made the serializer work on more platforms. This list goes over the most user-facing improvements.\r\n\r\n| Issue  | Description                                                                   | Category               |\r\n|--------|-------------------------------------------------------------------------------|------------------------|\r\n| #30820 | Add mechanism to preserve object references when (de)serializing              | Feature                |\r\n| #32937 | Add extension methods for HttpClient that allow (de)serializing JSON          | Feature                |\r\n| #30255 | Support (de)serializing quoted numbers                                        | Feature                |\r\n| #29895 | Support deserializing objects using parameterized constructors                | Feature                |\r\n| #876   | Support (de)serializing fields                                                | Feature                |\r\n| #779   | Support ignoring value-type defaults | Feature |\r\n| #30687 | Support conditionally ignoring properties (always, never, when null/default)  | Feature                |\r\n| #30524 | Support non-string dictionary keys                                            | Feature                |\r\n| #29743 | Allow using non-public property accessors for (de)serialization               | Feature                |\r\n| #34439 | Provide opt-in for custom converters to handle null                           | Feature                |\r\n| #38539 | Support new C# record types | Feature |\r\n| #30445 | Add a copy constructor to JsonSerializerOptions                               | Feature                |\r\n| #34626 | Add constructor to JsonSerializerOptions that takes serialization defaults    | Feature                |\r\n| #2259  | Improve (de)serialization performance for collections             | Performance            |\r\n| #36635 | Improve serialization performance for small or value-type POCOS (TechEmpower) | Performance            |\r\n| #35848 | Improve deserialization perf for case-insensitive and missing-property cases  | Performance            |\r\n| https://github.com/dotnet/corefx/pull/41845 | Improve perf for deserializing long JSON strings              | Performance            |\r\n| #31326 | Enable JsonSerializer to work on Xamarin iOS/Android                          | Platform support       |\r\n\r\nCheck out demos for the new features: https://github.com/layomia/NET5JsonDemos.",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-System.Text.Json",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#40359",
        "CreatedAt": "2020-08-05T02:21:38+00:00",
        "CreatedBy": "benaadams",
        "IsClosed": false,
        "Title": "FileStream\u0027s performance is disappointing and buggy",
        "DescriptionMarkdown": "(Note \u0060.CopyToAsync\u0060 is pretty good; for certain combinations of flags)\r\n\r\n\r\n\r\nIssues:\r\n\r\n* Read{Async} and Write{Async} etc call \u0060SeekCore\u0060 which on Windows calls the blocking api \u0060SetFilePointerEx\u0060 which the \u0022Windows Server Performance Team Blog: Designing Applications for High Performance \u2013 Part III\u0022 (June 25, 2008) says about\r\n  \u003E The old DOS SetFilePointer API is an anachronism. One should specify the file offset in the overlapped structure even for synchronous I/O.\r\n\r\n* Avoid unnecessary allocations when using FileStream #15088\r\n* Win32 FileStream turns async reads into sync reads #16341\r\n* Win32 FileStream will issue a seek on every ReadAsync call #16354\r\n* FileStream.SetLength doesn\u0027t return file pointer to original value on failure #8307\r\n* FileStream.FlushAsync ends up doing synchronous writes #27643\r\n* Asynchronous random file access with FileStream Read vs ReadAsync in a loop / parallel (ReadAsync is slow) #27047\r\n* FileStream.Windows useAsync WriteAsync calls blocking apis #25905\r\n* File.ReadAllTextAsync not behaving asynchronously when called on inaccessible network files #25314\r\n* Use PreallocatedOverlapped when internal FileStream buffer isn\u0027t being used on Windows #25074\r\n* File.WriteAllTextAsync performance issues #23196\r\n* Asynchronous FileStream I/O can throw in the completion port callback thread #13658\r\n* FileStream.Lock(Int64, Int64) failure on Linux - always uses \u0027F_WRLCK\u0027. #29173\r\n* FileStream.Flush(true) doesn\u0027t flush device buffer on macOS, while it does so on Windows #28444\r\n\r\nRosyln has [their own workarounds](https://github.com/dotnet/roslyn/blob/cb7bdffa1b17b2684083f5201153a976c04dd580/src/Workspaces/Core/Portable/Workspace/FileTextLoader.cs#L108-L173) for FileStream issues; and NuGet recently moved to mmap for better performance https://github.com/NuGet/NuGet.Client/pull/3524",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-System.IO",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "tenet-performance",
            "BackgroundColor": "c2e0c6"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#38367",
        "CreatedAt": "2020-06-25T01:17:36+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": "Support WebAssembly (Mono Runtime)",
        "DescriptionMarkdown": "# Support WebAssembly (Mono Runtime)\r\n\r\n[WebAssembly](https://webassembly.org/) is a relatively new virtual machine execution environment that can run any program that can be described in and target the web assembly [binary instruction format](https://webassembly.github.io/spec/core/binary/index.html). It is supported by all major browsers, although isn\u2019t browser-specific. We expect more general uses of WebAssembly to become commonplace in the coming years. It is important that .NET developers can publish apps to environments that support WebAssembly.\r\n\r\nWe released a first version of support for WebAssembly with [Bazor WebAssembly 3.2](https://devblogs.microsoft.com/aspnet/blazor-webassembly-3-2-0-now-available/). It was based on the Mono runtime and libraries. [Uno Platform](https://platform.uno/uno-platform-for-web-webassembly/) also relies on Mono for its WebAssembly support.\r\n\r\nIn .NET 5.0, we will continue to use the Mono runtime, and will switch to using the .NET 5.0 libraries. There are two major benefits to this change: better throughput performance, and higher compatibility with .NET 5.0 non-WebAssembly code. The compatbility isn\u2019t perfect, since we\u2019re using two different runtimes (Mono for WebAssembly and CoreCLR for everything else), and the WebAssembly environment imposes restrictions on what .NET code can do.\r\n\r\nThe following work items describe the work items required for the project. These bullets will be changed to links as we create new issues for them.\r\n\r\nMono Runtime Performance\r\n\r\n-\tInterpreter performance improvements\r\n-\tV8 performance improvement reports\r\n- Add browser wasm support for BenchmarkDotNet\r\n\r\nAdopt .NET Runtime Libraries\r\n\r\n-\tAdd support for browser based networking\r\n-\tEnable globalization with ICU\r\n-\tSupport async/tasks in an environment without explicit threads\r\n-\tAdd new library decorations and IL linker capabilities to reduce final application sizes and improve trimming reliability\r\n\r\nSDK\r\n\r\n- Create browser wasm runtime pack for net5.0 tfm\r\n- Add a reference to the runtime pack in SDK for building and publishing Blazor wasm projects",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "arch-wasm",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "runtime-mono",
            "BackgroundColor": "005e5e"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#38349",
        "CreatedAt": "2020-06-24T18:36:34+00:00",
        "CreatedBy": "richlander",
        "IsClosed": false,
        "Title": "Improving credit for community contributions",
        "DescriptionMarkdown": "# Improving credit for community contributions\r\n\r\nWe\u0027re nearly five years into [.NET Core as an open source project](https://devblogs.microsoft.com/dotnet/net-core-is-open-source/). As a .NET team member and Microsoft rep, I want to share a big thanks to everyone in the community that has taken the time and interest to participate in the project. I would like to start a conversation about community credit and attribution. Right now, we don\u2019t have a consistent model in place that everyone can point to for giving credit for community contributions. That doesn\u0027t seem right, and I propose we fix it. What do you think?\r\n\r\nThe thesis of this document is that credit will be given more (both quantity and frequency) if everyone is empowered to give it, and that enabling more people to participate in credit giving will increase not diminish its meaningfulness.\r\n\r\n## What is credit?\r\n\r\n\u003E Dictionary: Public acknowledgment or praise, typically that given or received when a person\u0027s responsibility for an action or idea becomes or is made apparent\r\n\r\nLet\u0027s start with why credit is an important topic. \r\n\r\nOn the one hand, it\u0027s not necessary to give credit. Let\u0027s take one of the most well known contributors, [Ben Adams](https://github.com/benaadams). Anyone can query for  [Ben\u0027s commits](https://github.com/search?o=desc\u0026q=org%3Adotnet\u002Bis%3Apr\u002Bauthor%3Abenaadams\u0026s=committer-date\u0026type=Commits). It\u0027s all open, right? And, if you look at some of his merged PRs, you\u0027ll see people saying [thank you](https://github.com/dotnet/runtime/pull/35765#issuecomment-623204929) or [approving Ben\u0027s work without any fanfare](https://github.com/dotnet/runtime/pull/32296) (an implicit validation of high-quality work). Sure, sure. I think we all know that this isn\u0027t credit, but basic personal interaction. \r\n\r\nSide-bar: Are we doing a good enough job on personal interaction, or are .NET team members too terse and business-like? Do you see and recieve enough appreciation in PRs and issues in the dotnet org? Tell us.\r\n\r\nBack to the main topic. Credit is something significantly beyond saying \u0022thank you.\u0022 Credit is given when a contribution is elevated so that everyone can see it. It\u0027s the higher level of visibility that\u0027s important. Here\u0027s an example from the [.NET 5.0 Preview 2 post](https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-2/) where one of Ben\u0027s contributions is given a high level of visibility. FYI: This example of credit is only given to community members.\r\n\r\n\u003Cimg width=\u0022779\u0022 alt=\u0022Screen Shot 2020-06-06 at 9 54 59 PM\u0022 src=\u0022https://user-images.githubusercontent.com/2608468/83960687-9175a100-a840-11ea-8062-7be9547f09a0.png\u0022\u003E\r\n\r\nThere are similar examples in the [Preview 3](https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-3/), [Preview 4](https://devblogs.microsoft.com/dotnet/announcing-net-5-preview-4-and-our-journey-to-one-net/) and [Preview 5](https://devblogs.microsoft.com/dotnet/announcing-net-5-0-preview-5/) posts. Visual Studio Code gives credit with their [Thank You section in their release notes](https://code.visualstudio.com/updates/v1_45#_thank-you). The Xamarin team has a similar model in their [release notes](https://docs.microsoft.com/en-us/xamarin/xamarin-forms/release-notes/4.6/4.6.0-sr2#thank-you).\r\n\r\nOther projects focus on contributors of the month, like [Galaxy Project](https://galaxyproject.org/blog/2018-09-cotm-carrie-ganote/) and [Netdata](https://github.com/netdata/netdata/issues/7133). Note: These examples were found through searches. I have no idea what these projects do or what their history is.\r\n\r\n## Developing a better model for credit\r\n\r\n\u003E People appreciate and are motivated by credit for their contributions, ideas, and hard work. We need to find more and better ways to give people the credit they deserve and need.\r\n\r\nWe can develop and adopt a better and multi-faceted model. Here are some thoughts on what that might look like:\r\n\r\n* Clearly defined and regularly applied.\r\n* Managed as a joint project between the .NET Team and the community.\r\n* Broad definition of contributions (PRs and issues, code and docs, blog posts and videos, ...)\r\n\r\nIn a lot of ways, credit is just another project, that requires up-front thought, broad agreement on the value, and  features that need to be developed. While the goal of credit is admirable, we need to consider the regular care and feeding of a project focused on credit in order to satisfy the stated need. I propose we start with a good MVP (minimum viable product) in the dotnet/runtime repo, and watch how it is received. We can then extend or adjust (more repos, more ways of giving credit) from there.\r\n\r\nThe following is a proposal. It is a layered model that is intended to give 100% of contributors credit, enable both the community and Microsoft to play key roles, and start us down the path of more innovative models for credit giving.\r\n\r\n- Publish contributor lists for each release (for the whole product, not just the runtime repo)\r\n  - We did this [up until .NET Core 2.1](https://github.com/dotnet/core/blob/master/release-notes/2.1/2.1.0-contributor.md). Producing this list was unintentionally dropped as a release activity.\r\n  - Many projects product contributor lists in various forms. Mozilla\u0027s [evergreen list of contributors](https://www.mozilla.org/credits/) is a good example.\r\n  - Question: Do you like [this format](https://github.com/dotnet/core/blob/master/release-notes/2.1/2.1.0-contributor.md), or should we adopt a new one? Should it include GitHub avatars? Is it important to split contributors by repo? Should Microsoft and community contributions be mixed or separated (FYI: they have been mixed to date, and it is a technically simpler approach)? Should we look at an existing tool/model like [All Contributors](https://allcontributors.org/)?\r\n- Create a community-maintained contribution epic linked to from the [release epic](https://github.com/dotnet/runtime/issues/37269).\r\n  - The epic would be called \u0022Community contributions\u0022.\r\n  - The comunity would decide the bar for adding PRs/issues to its epic, and also the categorization within the epic.\r\n  - GitHub permissions are a challenge, so the community would need to pick an editor and then have that person create and maintain the issue.\r\n- Consider creating monthly issues that give credit more frequently for contributions (this would be a closer analogue to the VS Code \u0022thanks\u0022 approach, which is monthly)\r\n  - These contributor lists need to be significantly curated or adopt some other unique approach in order to provide value beyond the release-specific contributor lists.\r\n  - There are a many different (non-mututally-exclusive) approaches we could adopt/highlight: largest and most valuable contributions, first time contributors, multi-month contributors (\u003E6 months, \u003E12 months, ...), contribution with most reactions ([example](https://github.com/dotnet/runtime/pull/34393)), most interesting closed-not-merged contribution ([example](https://github.com/dotnet/runtime/pull/33152)), stale/closed community issue/PR that merits reconsideration ...\r\n  - This idea would require an ongoing and significant time investment. It would need a lot of community engagement (if not managed exclusively by the community) to keep alive.\r\n  - (re)Tweet these monthly issues from [@dotnet](https://twitter.com/dotnet) twitter account when they are published.\r\n- Continue to use the same approach to offering credit in the Microsoft blog posts for previews and releases.\r\n  - Link to the \u0022community contributions\u0022 epic and to monthly contributions issues.\r\n  - [For the .NET blog writer] Use those contribution issues for inspiration, to expand the offering of credit in the blog posts.\r\n- Consider an end-of-release blog post dedicated to community contributions\r\n  - This post might be written by the same people managing the community-contribution issues described earlier.\r\n- Ensure that Microsoft PRs that borrow from the community give credit\r\n   - A good example of giving credit: https://github.com/dotnet/runtime/pull/36405\r\n   - A not-yet-credited example ... we\u0027ve been working with @damageboy on his [this goes to 11](https://bits.houmus.org/2020-01-28/this-goes-to-eleven-pt1) project. Credit needs to be paid to [@damageboy](https://github.com/damageboy) as part of the 5.0 project.\r\n   - These type of contributions need to be elevated beyond contributor lists, including in the final 5.0 release blog post.\r\n\r\nIs this a good MVP? What else should we do or consider?\r\n\r\n## Diversity and inclusion (D\u0026I)\r\n\r\nThe credit topic is focused on raising people and their contributions up. This is an objectively noble goal, however, it\u0027s only truly noble if we also use it as an opportunity for change. It is widely known that women, people of color, LBTGQ\u002B folks, people with disabilities (visible and invisible), and other groups, are [under-represented in tech](https://en.wikipedia.org/wiki/Underrepresented_group#Underrepresented_groups_in_STEM). We need to find ways to increase, motivate and celebrate contributions from people under-represented in tech. Equally important, we should also motivate and celebrate people who step up, as allies, to mentor underrepresented people to participate in tech. Please help us explore other ways to help connect people with barriers to contribution with help.\r\n\r\nIs it necessary to bring D\u0026I into a topic as simple and straightforward as credit? Yes. This is a perfect opportunity for raising people up that have well-established barriers to participation. Putting aside the moral reasons to do this, these are large groups of people that do not have the same ability to participate (as established groups that participate), and may be forward-looking sources of great contributors.\r\n\r\n## Next Steps\r\n\r\nThis .NET project started with Microsoft, but lives with the community. We need a set of community editors and curators to step forward to make much of this credit proposal real, and for the community to organize in some way to accept them as good stewards of community-generated credit giving.\r\n\r\nA better credit system is an overdue addition for ensuring that everyone in the community feels that their participation is appreciated and acknowledged. I\u0027ve offered some pretty obvious changes (like re-starting publishing contributor lists) and some more novel ones (like the \u0022community contributions\u0022 epic ). We can simply start with those if you want. We would like to start a dialog. Please share your thoughts.\r\n",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#37534",
        "CreatedAt": "2020-06-06T01:21:09+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": "Improving P95\u002B latency",
        "DescriptionMarkdown": "## Improving P95\u002B latency\r\n\r\nWe see an increasing number of large internet-facing sites and services being hosted on .NET. While there is a lot of legitimate focus on the [requests per second (RPS) metric](https://twitter.com/ben_a_adams/status/1260792649625280513), we find that very few big site owners ask us about that or even need to satisfy throughput approaching 1000 RPS (1000 RPS == 86M requests per day). We hear a lot more about latency, specifically about improving [P95 or P99 latency](https://docs.microsoft.com/en-us/azure/internet-analyzer/internet-analyzer-scorecard). Often, the number of machines or cores that are provisioned for (and biggest cost driver of) a site are chosen based on achieving a specific P95 metric (for example, 200ms), as opposed to a lower P50 metric (for example, 50ms). We think of latency as being the true \u201Cmoney metric\u201D.\r\n\r\nWe want .NET to be a platform that makes it cheaper to host your applications with each new release. In order to achieve that, it\u0027s important that latency is both good (low) but also predictable. That\u0027s the whole point of measuring P95\u002B latency. We have increased our focus on predictably consistent performance, reducing performance cliffs and outliers, with an emphasis on P95\u002B latency.\r\n\r\nAn equally important theme is predictable performance. Some of these epics are more related to that, then specifically targeting P95 latency. We\u0027re going to be a bit lazy here, and mix the two topics.\r\n\r\n## GC\r\n\r\n* [Card mark stealing for better work balance in Server GC](https://github.com/dotnet/coreclr/pull/25986)\r\n* [Optimize decommitting GC heap memory pages](https://github.com/dotnet/runtime/pull/35896)\r\n * [Pinned object heap](https://github.com/dotnet/runtime/pull/32283) to reduce heap fragmentation caused by pinning\r\nReduce GC pause times in specific situations, like [Array.Copy](https://github.com/dotnet/coreclr/pull/27776), [Array.Sort](https://github.com/dotnet/runtime/pull/35297) or [object unboxing](https://github.com/dotnet/runtime/pull/32353#issuecomment-586642480)\r\n\r\n## Runtime\r\n\r\n* [Improve call counting mechanism](https://github.com/dotnet/runtime/pull/32250) used by tiered JIT compilation to smooth out performance during startup\r\n* [Casting in a loop may cause long GC pause times](https://github.com/dotnet/runtime/issues/13821)\r\n* [Dynamic expansion of internal generic dictionary](https://github.com/dotnet/runtime/pull/32270) that eliminate performance cliffs hit by generic code\r\n* [Fix for solving lock contention issue in GC statics scanning](https://github.com/dotnet/runtime/pull/32795)\r\n* [GC polling in unboxing JIT helpers](https://github.com/dotnet/runtime/pull/32353#issuecomment-586642480)\r\n* [Buffer::BlockCopy may spend too long without GC polling](https://github.com/dotnet/runtime/issues/13554)\r\n* [Calling System.Math floating point operations in a loop causes long GC pause times ](https://github.com/dotnet/runtime/issues/13820)\r\n* [Inlined GC poll for methods marked with SuppressGCTransitionAttribute](https://github.com/dotnet/runtime/issues/13582)\r\n\r\n## Libraries\r\n\r\n* [Very high latency for GC when using (lots of) ThreadLocal](https://github.com/dotnet/runtime/issues/2382)",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "tenet-performance",
            "BackgroundColor": "c2e0c6"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#37269",
        "CreatedAt": "2020-06-01T20:42:52+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": ".NET 5.0 Runtime Epics",
        "DescriptionMarkdown": "# .NET 5.0 Runtime Epics\r\n\r\nThe .NET 5.0 release is composed of many improvements and features. This issue lists the \u0022epics\u0022 that are part of the release (for dotnet/runtime). Beyond these epics are many \u0022features\u0022 in this release that are not listed here, because they are not truly epics. An epic is a collection of features that together form a step-function level improvement in .NET, and typically requires the epic owner (a single developer or a small team) to go on a [journey to satisfy the epic goals](https://en.wikipedia.org/wiki/Epic_poetry). Such a journey can require taking great personal risk or fighting dragons, but it\u0027s all worth it to make .NET better.\r\n\r\nThis list will be filled out over the course of the release. Team members working on epics are encouraged to edit this issue directly to add their epic. The order of the epics is arbitrary (like epics should be grouped together). A small set of these 5.0 epics may be enabling early (but partial) support for .NET 6.0 scenarios.\r\n\r\n## Libraries\r\n\r\n* [Optimize library code using arm64 intrinsics](https://github.com/dotnet/runtime/issues/33308)\r\n* [Enable \u0060net5.0\u0060 TFM](https://github.com/dotnet/runtime/issues/34173)\r\n* [Enabling libraries support for iOS, Android, and Xamarin.Mac](https://github.com/dotnet/runtime/issues/35410) (6.0)\r\n* [Improving JsonSerializer functionality and performance](https://github.com/dotnet/runtime/issues/41313)\r\n\r\n## Runtime\r\n\r\n* [Improving P95\u002B latency](https://github.com/dotnet/runtime/issues/37534)\r\n* [Improving ARM64 Performance in .NET 5.0 \u2013 Closing the gap with x64](https://github.com/dotnet/runtime/issues/35853)\r\n* [Support Windows ARM64](https://github.com/dotnet/runtime/issues/36699)\r\n* [Support Single-File Apps](https://github.com/dotnet/runtime/issues/36590)\r\n* [Support WinRT APIs in .NET 5](https://github.com/dotnet/runtime/issues/35318)\r\n* [Support WebAssembly (Mono Runtime)](https://github.com/dotnet/runtime/issues/38367)\r\n\r\n## Tools\r\n\r\n* [Roslyn code analyzers for interop](https://github.com/dotnet/runtime/issues/37039)\r\n\r\n## Experiments\r\n\r\n* [Implement simple version of On Stack Replacement (OSR)](https://github.com/dotnet/runtime/pull/32969)\r\n\r\n## Other\r\n\r\n* [New Roslyn analyzers for library authors](https://github.com/dotnet/runtime/projects/46)\r\n* [Detect platform-specific API using analyzers](https://github.com/dotnet/runtime/issues/37359)",
        "Milestone": "5.0.0",
        "Assignees": [
          "richlander"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#37039",
        "CreatedAt": "2020-05-27T02:58:52+00:00",
        "CreatedBy": "elinor-fung",
        "IsClosed": false,
        "Title": "Roslyn Code analyzers for interop",
        "DescriptionMarkdown": "This tracking issue for a small backlog of rules around interop to add to the officially recommended set of analyzers. The rules are grouped around runtime functionality/features, but would represent separate analyzers in implementation. Since many issues concerning interop are rooted in a discrepancy between the user\u0027s intent and implementation, it is expected that only a small number of rules would be useful and applicable to all users. Official documentation will remain the main source of guidance for more nuanced behaviour that requires clear understanding of intent.\r\n\r\nThe upcoming plan to provide source generators for p/invokes should not directly affect the rules here, as that functionality would be using a different attribute for declaring p/invokes. However, there is the opportunity to provide an analyzer to help users migrate to the source generator approach. Once a source generator exists, the rules here could also be updated to consider p/invokes which use that generator or, depending on their severity, warnings within the generator itself.\r\n\r\nThe intent is that as the runtime interop team works through a backlog of analyzers around existing features and functionality, the concept of considering and adding analyzers for any new features will become natural and simply be part of that feature work. The [P/Invokes](#p/invokes) and [Marshalling](#marshalling) rules are expected to be the starting points for working through this backlog.\r\n\r\n## P/Invokes\r\n\r\nThese rules inspect the actual declaration and invocation of p/invokes.\r\n\r\n- [x] Do not use \u0060[Out]\u0060 string for P/Invokes: #35692\r\n- [x] Avoid \u0060StringBuilder\u0060 parameters for P/Invokes: #35693\r\n- [ ] Prefer \u0060ExactSpelling=true\u0060 in \u0060[DllImport]\u0060 for known APIs: #35695\r\n- [ ] Remove redundant configuration from \u0060[DllImport]\u0060 declaration #33808\r\n- [ ] CA1404 port: dotnet/roslyn-analyzers#420\r\n- [ ] Prefer \u0060SafeHandle\u0060 over \u0060IntPtr\u0060 for known APIs: #42404\r\n- [ ] Get the last error after calls to P/Invokes with \u0060SetLastError=true\u0060\r\n  - Category: Interoperability\r\n  - Default: Enabled\r\n  - After calling a p/invoke that sets the last error, \u0060Marshal.GetLastWin32Error\u0060 should be called to retrieve the last error.\r\n    \u0060\u0060\u0060C#\r\n    [DllImport(\u0022MyLibrary\u0022, SetLastError = true)]\r\n    private static extern void Foo();\r\n\r\n    public static void Bar()\r\n    {\r\n        Foo(); // Flag last error not retrieved\r\n    }\r\n\r\n    public static void Baz()\r\n    {\r\n        Foo(); // OK\r\n        if (Marshal.GetLastWin32Error() == 0) { ... }\r\n    }\r\n    \u0060\u0060\u0060\r\n- [ ] Specify \u0060SetLastError=true\u0060 in \u0060[DllImport]\u0060 for known APIs\r\n  - Category: Interoperability\r\n  - Default: Enabled\r\n  - For APIs that are known to set last error, \u0060SetLastError=true\u0060 should be specified. This would require having/building a database of APIs to compare against.\r\n    \u0060\u0060\u0060C#\r\n    // Flag SetLastError=false for known API\r\n    [DllImport(\u0022kernel32\u0022)]\r\n    public static extern bool CloseHandle(IntPtr hObject);\r\n\r\n    // OK - known API does not set last error\r\n    [DllImport(\u0022kernel32\u0022)]\r\n    public static extern int GetCurrentProcessId();\r\n    \u0060\u0060\u0060\r\n  - Recommend:\r\n    \u0060\u0060\u0060C#\r\n    [DllImport(\u0022kernel32.dll\u0022, SetLastError = true)]\r\n    public static extern bool CloseHandle(IntPtr hObject);\r\n    \u0060\u0060\u0060\r\n  - If the user does not intend to check the error, this can be skipped, but the general guidance is to both define the p/invoke to set last error (for APIs that do so) and check the error.\r\n\r\n## Marshalling\r\n\r\nThese rules inspect how data is marshalled. They would apply to the parameters on p/invokes and any types (e.g. marshalled structs, delegates) used by p/invokes.\r\n\r\n- [ ] Specify \u0060SizeConst\u0060 when marshalling as ByValArray: #36134\r\n- [ ] CA1414 port: dotnet/roslyn-analyzers#430\r\n- [ ] Avoid \u0060Delegate\u0060 or \u0060MulticastDelegate\u0060 fields in marshalled structs\r\n  - Category: Interoperability\r\n  - Default: Enabled\r\n  - \u0060Delegate\u0060 and \u0060MulticastDelegate\u0060 do not have a required signature, so they do not guarantee that the delegate passed in will match the signature the native code expects. Marshalling a struct containing a \u0060Delegate\u0060 or \u0060MulticastDelegate\u0060 from its native representation to a managed object can destabilize the runtime if the value of the field in the native representation is not a function pointer that wraps a managed delegate. Use a specific delegate type instead of \u0060Delegate\u0060 or \u0060MulticastDelegate\u0060.\r\n    \u0060\u0060\u0060C#\r\n    [DllImport(\u0022MyLibrary\u0022)]\r\n    private static extern void Foo(MyStruct s);\r\n\r\n    struct MyStruct\r\n    {\r\n        Delegate Bar; // Flag Delegate in marshalled struct\r\n    }\r\n    \u0060\u0060\u0060\r\n\r\n## COM\r\n\r\nThese rules inspect COM-related functionality. Many of the [existing rules](#existing-rules) that have not yet been ported are around COM.\r\n\r\n- [ ] Types should not be both \u0060[ComImport]\u0060 and \u0060[ComVisible(true)]\u0060\r\n  - Types should not be marked as both imported from COM and made visible to COM.\r\n- [ ] COM-visible types should be accessible and creatable\r\n  - Types marked \u0060ComVisible(true)\u0060 should be public, non-abstract, and have a public parameterless constructor.\r\n  - [CA1409](https://docs.microsoft.com/visualstudio/code-quality/ca1409) looks to have the same intent, but only specifically flagged the public parameterless constructor.\r\n\r\n## Low-level interop APIs\r\n\r\nThese rules are related to APIs that provide low-level interaction/integration with the runtime\u0027s interop system.\r\n\r\n- [ ] Interfaces marked with \u0060DynamicInterfaceCastableImplementationAttribute\u0060 should provide a default implementation of all inherited interface methods: #41529\r\n\r\n## Cross-platform\r\n\r\nThere is an [existing proposal](https://github.com/dotnet/designs/pull/110/files) for an analyzer that detects the use of platform-specific APIs where the API might not be available. Many interop-related APIs are platform-specific and would be given the appropriate attribute such that the proposed analyzer would flag their use.\r\n\r\nThe logic that will be used by the proposed analyzer for platform-specific APIs could be leveraged for platform-specifc interop behaviour that is not tied to a specifid API. There are some types or \u0060MarshalAs\u0060 values for which marshalling is not supported on all platforms. In these cases, it is not a known API that is platform-specific, but a user-defined p/invoke that is platform-specific due to the way it is defined. An analyzer would detect those p/invokes and treat those as platform-specific calls, following the same logic as that for the platform-specific APIs for determining the platform context and checking for platform guards around the call site.\r\n\r\nRules:\r\n- Marshalling of \u0060\u003CType\u003E\u0060 requires \u0060\u003COS\u003E\u0060\r\n- Marshalling as \u0060\u003CUnmanagedType.*\u003E\u0060 requires \u0060\u003COS\u003E\u0060\r\n\r\n## Existing rules\r\n\r\nThere are a number of [rules](https://docs.microsoft.com/visualstudio/code-quality/interoperability-warnings) around interop and marshalling that go through legacy (static) analysis. They have all previously been deprecated or slated to be ported as time allows. See [FxCop rule port status](https://docs.microsoft.com/visualstudio/code-quality/fxcop-rule-port-status) for a list of all ported, tracked, and deprecated rules.",
        "Milestone": "6.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Interop-coreclr",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#35692",
            "CreatedAt": "2020-05-01T02:19:55+00:00",
            "CreatedBy": "elinor-fung",
            "IsClosed": true,
            "Title": "Do not use [Out] string for P/Invokes",
            "DescriptionMarkdown": "Add a rule to flag P/Invoke declarations passing \u0060string\u0060 parameters by value with the \u0060[Out]\u0060 attribute, which can destabilize the runtime if the string is an interned string.\r\n\u0060\u0060\u0060C#\r\n // Flag [Out] string\r\n[DllImport(\u0022MyLibrary\u0022)]\r\nprivate static extern void Foo([Out] string s);\r\n\r\n// OK\r\n[DllImport(\u0022MyLibrary\u0022)]\r\nprivate static extern void Bar(out string s1, [Out] ref string s2);\r\n\u0060\u0060\u0060\r\n\r\n**Category:** Interoperability\r\n**Default:** Enabled\r\n\r\ncc @terrajobst @stephentoub @AaronRobinsonMSFT @jkoritzinsky ",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35693",
            "CreatedAt": "2020-05-01T02:21:25+00:00",
            "CreatedBy": "elinor-fung",
            "IsClosed": true,
            "Title": "Avoid StringBuilder parameters for P/Invokes",
            "DescriptionMarkdown": "Marshalling for \u0060StringBuilder\u0060 always creates a native buffer copy and can thus be very inefficient. Consider using a \u0060char\u0060 buffer from \u0060ArrayPool\u0060 instead.\r\n\u0060\u0060\u0060C#\r\n// Flag StringBuilder parameter\r\n[DllImport(\u0022MyLibrary\u0022)]\r\nprivate static extern void Foo(StringBuilder buffer);\r\n\u0060\u0060\u0060\r\n\r\n**Category:** Performance\r\n**Default:** Disabled\r\n\r\nSince each instance of this violation would require user intervention to determine if it makes sense to address and how to address it, this would be off-by-default and up to the user to enable for code where perf is a concern.\r\n\r\ncc @terrajobst @stephentoub @AaronRobinsonMSFT @jkoritzinsky ",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35695",
            "CreatedAt": "2020-05-01T02:29:39+00:00",
            "CreatedBy": "elinor-fung",
            "IsClosed": false,
            "Title": "Prefer ExactSpelling=true on [DllImport] for known APIs",
            "DescriptionMarkdown": "On Windows, setting \u0060ExactSpelling=true\u0060 on the \u0060DllImport\u0060 attribute prevents the runtime from looking for alternate function names (suffix based on \u0060CharSet\u0060), giving a slight performance benefit by avoiding this search.\r\n\r\nThere is a fair amount of nuance associated with the behaviour of \u0060ExactSpelling\u0060 and under which scenarios there would actually be a performance benefit. In order to avoid noise, this rule can be scoped to check for a database of Win32 APIs that use the suffixes and provide a warning and fix for those cases where it matters.\r\n\r\n\u0060\u0060\u0060C#\r\n// Flag ExactSpelling=false\r\n[DllImport(\u0022kernel32.dll\u0022, CharSet=CharSet.Unicode)]\r\nprivate static extern bool SetEnvironmentVariableW(string name, string? value);\r\n\r\n// OK - not in database of APIs\r\n[DllImport(\u0022MyLibrary.dll\u0022, CharSet=CharSet.Unicode)]\r\nprivate static extern void Foo();\r\n\u0060\u0060\u0060\r\n\r\nRecommend:\r\n\u0060\u0060\u0060C#\r\n[DllImport(\u0022kernel32.dll\u0022, CharSet=CharSet.Unicode, ExactSpelling = true)]\r\nprivate static extern bool SetEnvironmentVariableW(string name, string? value);\r\n\u0060\u0060\u0060\r\n\r\n**Category:** Performance\r\n**Default:** Enabled\r\n\r\ncc @terrajobst @stephentoub @AaronRobinsonMSFT @jkoritzinsky",
            "Milestone": "6.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#33808",
            "CreatedAt": "2020-03-19T16:43:13+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": false,
            "Title": "Remove redundant configuration from [DllImport] declaration",
            "DescriptionMarkdown": "Flag places where an attribute is set on a DllImport that\u0027s already the default value.\n\n**Category**: Style",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-suggestion",
                "BackgroundColor": "1d76db"
              },
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              },
              {
                "Name": "code-fixer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#420",
            "CreatedAt": "2019-12-01T15:51:25+00:00",
            "CreatedBy": "NextTurn",
            "IsClosed": true,
            "Title": "createdump can read memory with process_vm_readv on Linux",
            "DescriptionMarkdown": "See benchmark results in microsoft/clrmd#351",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Diagnostics-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#42404",
            "CreatedAt": "2020-09-17T20:13:36+00:00",
            "CreatedBy": "Mrnikbobjeff",
            "IsClosed": false,
            "Title": "Analyzer suggestion: Prefer SafeHandle over IntPtr",
            "DescriptionMarkdown": "After working on some Interop analyzers I thought about SafeHandle and how known api\u0027s could suggest using the corresponding safehandle, such as SafeFileHandle or SafeWaitHandle. This could also more broadly be applied based on the method name, e.g. methods contains alloc/free could offer a warning when an IntPtr is used instead of a custom safehandle.",
            "Milestone": "6.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#36134",
            "CreatedAt": "2020-05-08T18:42:15+00:00",
            "CreatedBy": "elinor-fung",
            "IsClosed": false,
            "Title": "Specify SizeConst when marshalling field as ByValArray",
            "DescriptionMarkdown": "When marshalling using \u0060UnmanagedType.ByValArray\u0060, the \u0060SizeConst\u0060 field should be specified.\r\n\r\n\u0060\u0060\u0060C#\r\nstruct MyStruct\r\n{\r\n    [MarshalAs(UnmanagedType.ByValArray)]\r\n    int[] Foo;\r\n}\r\n\u0060\u0060\u0060\r\n\r\n**Category:** Interoperability\r\n**Default:** Enabled\r\n\r\ncc @terrajobst @stephentoub @AaronRobinsonMSFT @jkoritzinsky",
            "Milestone": "6.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-suggestion",
                "BackgroundColor": "1d76db"
              },
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#430",
            "CreatedAt": "2019-12-02T10:31:34+00:00",
            "CreatedBy": "damageboy",
            "IsClosed": false,
            "Title": "Superfluous mov(s) opcodes around left shifting/vmovmskps",
            "DescriptionMarkdown": "## Repro Repo:\r\nhttps://github.com/damageboy/coreclr-jit-why-mov-now\r\n\r\n## Relevant piece of code:\r\n\r\nhttps://github.com/damageboy/coreclr-jit-why-mov-now/blob/09e990e4d87190e33ca9ea1a794ec045a6651f97/Program.cs#L37-L44\r\n\r\n\u0060\u0060\u0060csharp\r\n            maskyMcMaskFace  = (ulong) (uint) MoveMask(CompareGreaterThan(L0, P).AsSingle()) \u003C\u003C 00;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L1, P).AsSingle()) \u003C\u003C 08;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L2, P).AsSingle()) \u003C\u003C 16;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L3, P).AsSingle()) \u003C\u003C 24;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L4, P).AsSingle()) \u003C\u003C 32;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L5, P).AsSingle()) \u003C\u003C 40;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L6, P).AsSingle()) \u003C\u003C 48;\r\n            maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L7, P).AsSingle()) \u003C\u003C 56;\r\n\u0060\u0060\u0060\r\n\r\n## Generated asm:\r\n\r\nhttps://github.com/damageboy/coreclr-jit-why-mov-now/blob/09e990e4d87190e33ca9ea1a794ec045a6651f97/listing.asm#L57-L115\r\n\r\n\u0060\u0060\u0060nasm\r\n;             maskyMcMaskFace  = (ulong) (uint) MoveMask(CompareGreaterThan(L0, P).AsSingle()) \u003C\u003C 00;\r\n00007F05AE6B097A C5F566C8             vpcmpgtd ymm1,ymm1,ymm0\r\n00007F05AE6B097E C5FC50F9             vmovmskps edi,ymm1\r\n00007F05AE6B0982 8BFF                 mov     edi,edi\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L1, P).AsSingle()) \u003C\u003C 08;\r\n00007F05AE6B0984 C5ED66C8             vpcmpgtd ymm1,ymm2,ymm0\r\n00007F05AE6B0988 C5FC50C1             vmovmskps eax,ymm1\r\n00007F05AE6B098C 8BC0                 mov     eax,eax\r\n00007F05AE6B098E 48C1E008             shl     rax,8\r\n00007F05AE6B0992 480BF8               or      rdi,rax\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L2, P).AsSingle()) \u003C\u003C 16;\r\n00007F05AE6B0995 C5E566C8             vpcmpgtd ymm1,ymm3,ymm0\r\n00007F05AE6B0999 C5FC50C1             vmovmskps eax,ymm1\r\n00007F05AE6B099D 8BC0                 mov     eax,eax\r\n00007F05AE6B099F 48C1E010             shl     rax,10h\r\n00007F05AE6B09A3 480BC7               or      rax,rdi\r\n00007F05AE6B09A6 488BF8               mov     rdi,rax\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L3, P).AsSingle()) \u003C\u003C 24;\r\n00007F05AE6B09A9 C5DD66C8             vpcmpgtd ymm1,ymm4,ymm0\r\n00007F05AE6B09AD C5FC50C1             vmovmskps eax,ymm1\r\n00007F05AE6B09B1 8BC0                 mov     eax,eax\r\n00007F05AE6B09B3 48C1E018             shl     rax,18h\r\n00007F05AE6B09B7 480BC7               or      rax,rdi\r\n00007F05AE6B09BA 488BF8               mov     rdi,rax\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L4, P).AsSingle()) \u003C\u003C 32;\r\n00007F05AE6B09BD C5D566C8             vpcmpgtd ymm1,ymm5,ymm0\r\n00007F05AE6B09C1 C5FC50C1             vmovmskps eax,ymm1\r\n00007F05AE6B09C5 8BC0                 mov     eax,eax\r\n00007F05AE6B09C7 48C1E020             shl     rax,20h\r\n00007F05AE6B09CB 480BC7               or      rax,rdi\r\n00007F05AE6B09CE 488BF8               mov     rdi,rax\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L5, P).AsSingle()) \u003C\u003C 40;\r\n00007F05AE6B09D1 C5CD66C8             vpcmpgtd ymm1,ymm6,ymm0\r\n00007F05AE6B09D5 C5FC50C1             vmovmskps eax,ymm1\r\n00007F05AE6B09D9 8BC0                 mov     eax,eax\r\n00007F05AE6B09DB 48C1E028             shl     rax,28h\r\n00007F05AE6B09DF 480BC7               or      rax,rdi\r\n00007F05AE6B09E2 488BF8               mov     rdi,rax\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L6, P).AsSingle()) \u003C\u003C 48;\r\n00007F05AE6B09E5 C5C566C8             vpcmpgtd ymm1,ymm7,ymm0\r\n00007F05AE6B09E9 C5FC50C1             vmovmskps eax,ymm1\r\n00007F05AE6B09ED 8BC0                 mov     eax,eax\r\n00007F05AE6B09EF 48C1E030             shl     rax,30h\r\n00007F05AE6B09F3 480BC7               or      rax,rdi\r\n00007F05AE6B09F6 488BF8               mov     rdi,rax\r\n\r\n\r\n;             maskyMcMaskFace |= (ulong) (uint) MoveMask(CompareGreaterThan(L7, P).AsSingle()) \u003C\u003C 56;\r\n00007F05AE6B09F9 C5BD66C0             vpcmpgtd ymm0,ymm8,ymm0\r\n00007F05AE6B09FD C5FC50C0             vmovmskps eax,ymm0\r\n00007F05AE6B0A01 8BC0                 mov     eax,eax\r\n00007F05AE6B0A03 48C1E038             shl     rax,38h\r\n00007F05AE6B0A07 480BC7               or      rax,rdi\r\n00007F05AE6B0A0A 488BF8               mov     rdi,rax\r\n\u0060\u0060\u0060\r\n\r\n## Issue\r\nIn the asm listing, you can see that the first left shift by 0 has no effect, which is great!\r\nThe second one generates proper code.\r\n\r\nBut the 3rd and onwards (\u003C\u003C16..\u003C\u003C56) all generate an additional \u0060mov\u0060 instruction:\r\n\u0060\u0060\u0060nasm\r\nor      rax,rdi\r\nmov     rdi,rax\r\n\u0060\u0060\u0060\r\n\r\nWhere it could simple do a single:\r\n\u0060\u0060\u0060nasm\r\nor rdi,rax\r\n\u0060\u0060\u0060\r\n\r\nWhich it did for the first shift only...?\r\n\r\nI do realize these opcodes are the most expensive to execute, but this is completely erratic and does impact decoding and to some extent the execution speed of the code.\r\n\r\nIt is perhaps indicative of a more fundamental issue as well?\r\n\r\n\r\ncategory:cq\r\ntheme:register-allocator\r\nskill-level:intermediate\r\ncost:medium",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-CodeGen-coreclr",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "optimization",
                "BackgroundColor": "0052cc"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#41529",
            "CreatedAt": "2020-08-28T19:06:29+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": false,
            "Title": "All inherited interface members should be implemented on an interface marked with DynamicInterfaceCastableImplementationAttribute",
            "DescriptionMarkdown": "An interface marked with a \u0060System.Runtime.InteropServices.DynamicInterfaceCastableImplementationAttribute\u0060 attribute should provide a default interface implementation of all inherited interface methods.\r\n\r\n\u0060\u0060\u0060csharp\r\ninterface Foo\r\n{\r\n      void Frob();\r\n}\r\n\r\n[DynamicInterfaceCastableImplementation]\r\ninterface Bar : Foo\r\n{\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\r\n**Category:** Usage\r\n**Default:** Enabled\r\n\r\ncc @terrajobst @stephentoub @AaronRobinsonMSFT @elinor-fung ",
            "Milestone": "6.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-suggestion",
                "BackgroundColor": "1d76db"
              },
              {
                "Name": "area-System.Runtime.InteropServices",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "code-analyzer",
                "BackgroundColor": "0f46ad"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#36699",
        "CreatedAt": "2020-05-19T14:15:52+00:00",
        "CreatedBy": "richlander",
        "IsClosed": true,
        "Title": "Support Windows ARM64",
        "DescriptionMarkdown": "# Support Windows ARM64\r\n\r\nWe are in the process of adding support for [Windows ARM64](https://docs.microsoft.com/en-us/windows/arm/) as part of the .NET 5.0 project. As a result, you will be able to run Windows Forms, WPF and ASP.NET Core apps on Windows ARM64 devices, such as the [Surface Pro X](https://www.microsoft.com/en-us/p/surface-pro-x/8VDNRP2M6HHC).\r\n\r\nWe intend to support the same .NET capabilities on ARM64 as on x64. Related: https://github.com/dotnet/runtime/issues/35853\r\n\r\nThis project follows a similar effort to add Console and ASP.NET Core support for [Linux ARM64](https://github.com/dotnet/announcements/issues/82).\r\n\r\nThe [.NET 5.0 Preview 4 SDK](https://dotnet.microsoft.com/download/dotnet/5.0) supports building and running ASP.NET Core and Console apps.\r\n\r\nYou can install [\u0060master\u0060 branch builds](https://github.com/dotnet/installer#installers-and-binaries) if you would like want to test Windows Forms on ARM64. \u0060master\u0060 branch builds do not yet include WPF support for ARM64.\r\n\r\n## Remaining .NET 5 Work\r\n\r\n- [x] Windows ARM64 ASP.NET Core MSI (necessary for the SDK install): https://github.com/dotnet/aspnetcore/pull/25579\r\n- [ ] Windows ARM64 SDK MSI: https://github.com/dotnet/installer/pull/8470\r\n\r\n## Post .NET 5 Work\r\n\r\n* [ ] Produce and publish Windows Desktop Runtime Pack for ARM64\r\n  * [x] Add Windows Forms to the Windows Desktop Runtime Pack\r\n  * [ ] Add WPF to the Windows Desktop Runtime Pack\r\n* [ ] Add Windows Desktop framework to the SDK\r\n  * [x] Add Windows Forms to the Windows Desktop framework in the SDK\r\n  * [ ] Add WPF to the Windows Desktop framework in the SDK\r\n  * [x] Crossgen Windows Desktop Pack for ARM64\r\n* [ ] Test PowerShell on Windows ARM64 (PowerShell team will do this, but it is an important signoff criteria)\r\n\r\n## Timeline\r\n\r\nThe following timeline is for .NET 5.0 and Windows ARM64:\r\n*\t.NET 5.0 Preview 4 -- Ship the .NET SDK, without Windows Desktop\r\n*\t.NET 5.0 Preview 5 -- Add Windows Desktop to SDK, with Windows Forms\r\n*\t.NET 5.0 Preview 6 -- Add ARM64 MSI installer for .NET Runtime \r\n* \t.NET 5.0 RC2 -- Add ARM64 MSI installer for SDK\r\n* TBD -- Add WPF to Windows Desktop\r\n\r\nAfter this project is complete, the Windows ARM64 SDK will have functional parity with x64.\r\n\r\n## Examples\r\n\r\nThe following image demonstrate the [Conway\u0027s Game of life](https://github.com/dotnet/samples/tree/master/windowsforms/Conway\u0027s-Game-of-Life/VB) VB sample running on Windows ARM64.\r\n\r\n\u003Cimg width=\u0022398\u0022 alt=\u00222020-05-15\u0022 src=\u0022https://user-images.githubusercontent.com/2608468/82086979-20f5bd00-96a4-11ea-8d73-abed8f2505fb.png\u0022\u003E\r\n\r\nThe following demonstrates displaying [version information in a Windows Forms app](https://github.com/richlander/testapps/tree/master/versioninfo-windowsforms) on ARM64.\r\n\r\n![image](https://user-images.githubusercontent.com/2608468/87205382-2cd4b880-c2bc-11ea-9c3f-a9d6f02b3af2.png)\r\n\r\nThe following image demonstrates 32-bit x86 Windows PowerShell 5.1 running emulated (on .NET Framework 4.8), and 64-bit ARM64 PowerShell 7.1 running natively (on .NET 5.0) on Windows ARM64.\r\n\r\n\u003Cimg width=\u0022375\u0022 alt=\u00222020-05-15 (5)\u0022 src=\u0022https://user-images.githubusercontent.com/2608468/82128604-3dabf680-9771-11ea-9847-ca977549b21d.png\u0022\u003E\r\n\r\nSee [PowerShell/PowerShell](https://github.com/powershell/powershell) to download the Windows ARM64 version. You can also install the [PowerShell .NET tool](https://www.nuget.org/packages/PowerShell/) on Windows ARM64.\r\n\r\nSee [versioninfo](https://github.com/richlander/testapps/blob/master/versioninfo/Program.cs) for APIs that you can use to get version and architecture information.",
        "Milestone": "5.0.0",
        "Assignees": [
          "richlander",
          "tommcdon"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "arch-arm64",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "blocking-release",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#36590",
        "CreatedAt": "2020-05-16T00:22:58+00:00",
        "CreatedBy": "swaroop-sridhar",
        "IsClosed": true,
        "Title": "Support Single-File Apps in .NET 5",
        "DescriptionMarkdown": "The goal of this effort is enable .Net-Core apps to be published and distributed as a single executable. \r\n\r\n## Goals\r\n\r\nThe .Net 5.0 single file solution should be:\r\n\r\n* Widely compatible: Apps containing IL assemblies, ready-to-run assemblies, composite assemblies, native binaries, configuration files, etc. can be packaged into one executable.\r\n* Can run managed components of the app directly from bundle, without need for extraction to disk. \r\n* Usable with debuggers and tools.\r\n\r\n## User Experience\r\n\r\nHere\u0027s the overall experience for publishing a HelloWorld single-file app in .net 5: \r\n\r\n* Framework-dependent \r\n    * Publish command: \u0060dotnet publish -r win-x64 --self-contained=false /p:PublishSingleFile=true\u0060\r\n    * Published files: \u0060HelloWorld.exe\u0060, \u0060HelloWorld.pdb\u0060\r\n\r\n* Self-contained (Linux)\r\n    * Publish command: \u0060dotnet publish -r linux-x64 /p:PublishSingleFile=true\u0060\r\n    * Published files: \u0060HelloWorld\u0060, \u0060HelloWorld.pdb\u0060\r\n\r\n* Self-contained (Windows): \r\n    * Publish command: \u0060dotnet publish -r win-x64 /p:PublishSingleFile=true\u0060\r\n    * Published files: \u0060HelloWorld.exe\u0060, \u0060HelloWorld.pdb\u0060, \u0060coreclr.dll\u0060, \u0060clrjit.dll\u0060, \u0060clrcompression.dll\u0060,  \u0060mscordaccore.dll\u0060\r\n\r\n* Self-contained (Windows) with bundled native components:\r\n    * Publish command: \u0060dotnet publish -r win-x64 /p:PublishSingleFile=true /p:IncludeNativeLibrariesInSingleFile=true\u0060 \r\n    * Published files: \u0060HelloWorld.exe\u0060, \u0060HelloWorld.pdb\u0060\r\n\r\n## Design Document\r\n\r\nA detailed discussion of the goals, non-goals, related-work, options, design decisions, and implementation details of supporting single-file apps is available in this [design document](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md)\r\n\r\n## Tracking Progress\r\n\r\n- [x] Initial proposal and poll for customer response: \r\n    - [x] Poll on GitHub: #11201\r\n    - [x] Enterprise customer poll \r\n- [x] Propose [staged implementation](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/staging.md) of the feature.\r\n- [x] Support single-file apps through extraction (.net core 3)\r\n    - [x] Self-Extractor [Design](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design_3_0.md).\r\n    - [x] SDK support for publishing apps as a single-file. https://github.com/dotnet/sdk/pull/3132\r\n    - [x] AppHost support for extracting contents of a single-file bundle at startup. https://github.com/dotnet/core-setup/pull/5742\r\n- [x] Support single-file apps running from bundle (.net 5)\r\n   - [x] HostModel library\r\n       - [x] Implement bundle format [version 2](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/bundler.md#bundle-layout). https://github.com/dotnet/core-setup/pull/5742\r\n   - [x] SDK\r\n       - [x] Implement support for publishing [a few files](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#user-experience) when necessary for \u0060PublishSingleFile\u0060.  https://github.com/dotnet/sdk/pull/11586\r\n       - [x] Implement [optional settings](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#optional-settings) for single-file publishing. https://github.com/dotnet/sdk/pull/11797\r\n       - [x] Use [SingleFileHost](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#host-builds) when publishing self-contained single-file apps. https://github.com/dotnet/sdk/issues/11567 https://github.com/dotnet/sdk/pull/11797\r\n       - [x] Trim the set of native dependencies used for single-file publish. https://github.com/dotnet/runtime/pull/36578 https://github.com/dotnet/sdk/pull/11797\r\n    - [x] Host\r\n        - [x] Move bundle-processing from the host to the [framework](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#the-host) . https://github.com/dotnet/runtime/pull/34274\r\n       - [x] Process \u0060deps.json\u0060 and \u0060runtimeconfig.json\u0060 files directly from bundle. https://github.com/dotnet/runtime/pull/34274\r\n       - [x] Implement a callback for the runtime to probe the contents of the bundle. https://github.com/dotnet/runtime/pull/34845\r\n     - [x] Host Builds\r\n        - [x] Windows: Implement \u0060SingleFileHost\u0060 with \u0060AppHost\u0060, \u0060HostFxr\u0060, and \u0060HostPolicy\u0060 statically linked. #32823 #36230\r\n       - [x] Linux: Implement \u0060SingleFileHost\u0060 with host and runtime components statically linked. \r\n           - [x] Statically link \u0060CoreCLR\u0060 and \u0060ClrJIT\u0060 with \u0060SingleFileHost\u0060 #37119 #36847\r\n           - [x] Statically link core native libraries with \u0060SingleFileHost\u0060 #38304\r\n     - [x] Runtime\r\n         - [x] Load assemblies [directly from bundle](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#peimage-loader). #32822 #36052 \r\n         - [x] Dependency resolution: [Resolve assemblies from bundle](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#dependency-resolution). #36052\r\n    - [x] APIs\r\n         - [x] \u0060AppContext.BaseDirectory\u0060 should return the [location of the single-file executable](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#appcontextbasedirectory) https://github.com/dotnet/runtime/pull/34274\r\n ",
        "Milestone": "5.0.0",
        "Assignees": [
          "VSadov",
          "swaroop-sridhar"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Single-File",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#11201",
            "CreatedAt": "2018-10-05T21:48:53+00:00",
            "CreatedBy": "morganbr",
            "IsClosed": true,
            "Title": "Support single-file distribution",
            "DescriptionMarkdown": "This issue tracks progress on the .NET Core 3.0 single-file distribution feature. \r\nHere\u0027s the [design doc](https://github.com/dotnet/designs/blob/master/accepted/single-file/design.md) and [staging plan](https://github.com/dotnet/designs/blob/master/accepted/single-file/staging.md) for the feature.",
            "Milestone": "Future",
            "Assignees": [
              "swaroop-sridhar"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11567",
            "CreatedAt": "2020-05-05T21:35:09+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Use SingleFileHost for self-contained single-file apps",
            "DescriptionMarkdown": "There are two main tasks that need to be done for self-contained single-file publish scenario:\r\n\r\n## Use \u0060singlefilehost\u0060\r\n* @VSadov\u0027s [PR](https://github.com/dotnet/runtime/pull/35368)  adds \u0060singlefilehost\u0060 to the \u0060microsoft.netcore.app.host.*\u0060 packages.\r\n* [ResolveAppHosts](https://github.com/dotnet/sdk/blob/611fcdd2ce0b29abae9967ca8e425db1a4def176/src/Tasks/Microsoft.NET.Build.Tasks/ResolveAppHosts.cs#L58-L64) will resolve \u0060singlefilehost\u0060 to the same package as \u0060apphost\u0060, \u0060ijwhost\u0060, and \u0060comhost\u0060.\r\n* When publishing for self-contained single-file apps, the [CreateAppHost task]( https://github.com/dotnet/sdk/blob/36ef8b2aa8e5d579c921704bdab69a7407936889/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Sdk.targets#L427) will be invoked with the singlefilehost path as its \u0060AppHostSourcePath\u0060. This will generate an app using \u0060singlefilehost\u0060.\r\n* This may not work very well for a sequence such below. However, I think fixing this case is not crucial, because the \u0060--no-build\u0060 already has [similar concerns](https://github.com/dotnet/sdk/issues/10608) for self-contained vs framework-dependent publish.\r\n\r\n\u0060\u0060\u0060\r\n    dotnet build -r win-x64 \r\n    dotnet publish --no-build -r win-x64 /p:PublishSingleFile=true.\r\n\u0060\u0060\u0060\r\n\r\n## Trim the native components of the runtime:\r\n* Certain files in \u0060microsoft.netcore.app.runtime.*\u0060 package are no longer necessary to be published for single-file apps.\r\n* For example, \u0060hostfxr\u0060 and \u0060hostpolicy\u0060 are not necessary since they are statically linked with \u0060singlefilehost\u0060. Later \u0060coreclr\u0060, \u0060clrjit\u0060 will also be linked with the \u0060singlefilehost\u0060, and they are also not necessary. Certain other files such as \u0060createdump\u0060 are excluded from the publish as a matter of policy decision. \r\n* This exclusion is different from \u0060ExcludeFromSingleFile\u0060\r\n    * In this case, the files, the excluded files are not published at all (neither in the bundle nor in the publish directory beside the single-file bundle).\r\n    * Files marked \u0060ExcludeFromSingleFile\u0060 are copied to publish directory alongside the single-file app.\r\n* The plan to realize this exclusion of runtime components is:\r\n    * The \u0060RuntimeList.xml\u0060 in \u0060microsoft.netcore.app.runtime.*\u0060 package will contain special meta-data identifying that the file is not necessary for single-file scenario\r\n\u0060\u003CFile FileVersion=\u00220.0.0.0\u0022 Path=\u0022runtimes/linux-x64/native/createdump\u0022 Type=\u0022Native\u0022 DropFromSingleFile=\u0022true\u0022/\u003E\u0060\r\n    * The  [\u0060ResolveRuntimePackAssets\u0060 task](https://github.com/dotnet/sdk/blame/611fcdd2ce0b29abae9967ca8e425db1a4def176/src/Tasks/Microsoft.NET.Build.Tasks/ResolveRuntimePackAssets.cs#L92) will transfer this annotation as (\u0060DropFromSingleFile\u0060) meta-data on the asset.\r\n  * The Single-file [publish targets](https://github.com/dotnet/sdk/blob/611fcdd2ce0b29abae9967ca8e425db1a4def176/src/Tasks/Microsoft.NET.Build.Tasks/targets/Microsoft.NET.Publish.targets#L938-L941) will use this meta-data to drop these files, and not publish them in the single-file app.\r\n",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "swaroop-sridhar"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#32823",
            "CreatedAt": "2020-02-25T21:29:05+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Implement statically linked apphost",
            "DescriptionMarkdown": "In order to support single-file apps, implement the \u0022static-host\u0022 host-builds as described [here](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#host-builds), publish them to be consumed by the SDK.\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "VSadov"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#37119",
            "CreatedAt": "2020-05-28T06:57:20+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Implement Linux SingleFileHost with statically linked runtime",
            "DescriptionMarkdown": "In order to support single-file apps, implement the \u0060singlefilehost\u0060 with runtime linked in.\r\nThis host is codenamed \u0022super-host\u0022 in the [design-doc](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#host-builds).\r\n\r\nIn .net 5, this host will be implemented only for Linux X64.\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "VSadov"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-linux",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#38304",
            "CreatedAt": "2020-06-23T22:29:34+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "SingleFile: Statically link core native libraries to Linux SingleFileHost",
            "DescriptionMarkdown": "Statically link System.Native, System.IO.Compression.Native, System.IO.Ports.Native, System.Net.Http.Native, System.Net.Security.Native and System.Security.Cryptography.Native.OpenSsl native libraries with singlefilehost.\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "VSadov"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-linux",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#32822",
            "CreatedAt": "2020-02-25T21:26:39+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Implement loading assemblies from bundle",
            "DescriptionMarkdown": "Implement runtime changes necessary to load assemblies directly from the bundle, as described here:\r\nhttps://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#peimage-loader",
            "Milestone": "5.0.0",
            "Assignees": [
              "swaroop-sridhar"
            ],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#36052",
            "CreatedAt": "2020-05-07T22:32:12+00:00",
            "CreatedBy": "swaroop-sridhar",
            "IsClosed": true,
            "Title": "Single-File: Run from Bundle",
            "DescriptionMarkdown": "This change implements:\r\n\r\n* Runtime changes necessary to load assemblies directly from the bundle:\r\n    * Design notes about [Load from Bundle](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#peimage-loader)\r\n    * Most of these changes are directly from https://github.com/dotnet/coreclr/pull/26504 and https://github.com/dotnet/coreclr/pull/26904\r\n\r\n* Hostpolicy change to not add bundled assemblies to TPA list:\r\n    * Design notes about [Dependency Resolution](https://github.com/dotnet/designs/blob/master/accepted/2020/single-file/design.md#dependency-resolution)\r\n    * TBD (separately) items: Fix for hammer servicing #36031\r\n\r\nFixes #32822",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Single-File",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#36449",
        "CreatedAt": "2020-05-14T14:14:05+00:00",
        "CreatedBy": "lambdageek",
        "IsClosed": true,
        "Title": "[Mono] Add QCalls to the runtime",
        "DescriptionMarkdown": "In CoreCLR QCalls ([documented in botr](https://github.com/dotnet/runtime/blob/master/docs/design/coreclr/botr/corelib.md#calling-from-managed-to-native-code)) are one way to call back into the runtime from managed code.  They are basically P/Invokes, but with a lookup that goes through a runtime table.\r\n\r\nSupporting QCalls in Mono will have a couple of benefits:\r\n1. Less churn on the managed side of S.P.C when it makes sense we can just share managed declarations instead of having to mark them with \u0060[MethodImpl (MethodImplOptions.InternalCall)]\u0060 for Mono and as a QCall for CoreCLR.\r\n2. We won\u0027t need to make the native symbols visible - right now for \u0060DllImport (__Internal)\u0060 - which we\u0027ve used for the ICU shims and some System.Native methods that we link into the MonoVM, we rely on \u0060dlsym\u0060 which means the symbol needs to be visible.  And also we have to do hacks for \u0060RTLD_LOCAL\u0060 in order for lookups to work both in the runtime and in the embedding host on Android, OSX, etc.  With QCalls the lookup logic doesn\u0027t depend on dlsym - we just build a table at runtime.\r\n3. Ability to share more native code - since QCalls are just PInvokes they will run in GC Safe mode and will need to switch to GC Unsafe when they call into the runtime APIs.  This is similar to how these methods behave in CoreCLR, so for projects like the EventPipe C implementation we can have uniform logic around thread GC state transitions.\r\n\r\nDownsides:\r\n1. Transitions from GC Unsafe (which managed code uses) to GC Safe (when going to a P/Invoke) aren\u0027t free.  Which is why CoreCLR has a \u0060SuppressGCTransitionAttribute\u0060 https://github.com/dotnet/runtime/issues/30741 attribute which we should also implement.\r\n2. A table in the runtime means we\u0027ll need to do \u0060#ifdef\u0060 stuff to remove definitions for methods that shouldn\u0027t be in a particular runtime configuration.  Can\u0027t just rely on not linking the functions into the final binary.\r\n3. There will still be differences in how the native code is implemented. For passing object references to native code, CLR uses a [\u0060REF\u003CT\u003E\u0060](https://github.com/dotnet/runtime/blob/master/src/coreclr/src/vm/vars.hpp#L228)  C\u002B\u002B template (or rather specific the base class \u0060OBJECTREF\u0060 or instances like \u0060SAFEHANDLEREF\u0060) and we won\u0027t be able to make use of it in Mono directly.  Which means that sharing will only be possible in native code like the EventPipe C impl that already takes great care to abstract over the differences between CoreCLR and MonoVM\r\n\r\nTasks:\r\n- [x] Add support for registering and looking up QCalls\r\n- [x] Add support for \u0060SuppressGCTransitionAttribute\u0060\r\n- [x] Share the \u0060QCallHandles\u0060 structs https://github.com/dotnet/runtime/blob/master/src/coreclr/src/System.Private.CoreLib/src/System/Runtime/CompilerServices/QCallHandles.cs\r\n   - ~Add special marshalling support for these (or do they just work - unclear)~ these should just work\r\n   - we will need some implementations of \u0060GetUnderlyingNativeHandle\u0060 for \u0060Module\u0060 and \u0060Assembly\u0060 in our System.Reflection implementation.\r\n- [ ] Design and implement some analog of the \u0060REF\u003CT\u003E\u0060 template that we can use to pass object references to the C code in a relatively painless way.  ideally something that works with our \u0060object-internals.h\u0060 and \u0060handles.h\u0060 types.  Although the ideal with QCalls is to pass only a very limited number of object references to native code if it can be at all avoided.",
        "Milestone": "5.0.0",
        "Assignees": [
          "thaystg"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Interop-mono",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "runtime-mono",
            "BackgroundColor": "005e5e"
          },
          {
            "Name": "tracking",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#35853",
        "CreatedAt": "2020-05-05T19:42:39+00:00",
        "CreatedBy": "kunalspathak",
        "IsClosed": false,
        "Title": "Improving ARM64 Performance in .NET 5.0 \u2013 Closing the gap with x64",
        "DescriptionMarkdown": ".NET 3.0 was the first release to add support for [ARM64](https://docs.microsoft.com/en-us/dotnet/core/whats-new/dotnet-core-3-0#linux-improvements), starting with Linux (see [ARM64 tracking issue](https://github.com/dotnet/runtime/issues/11042)). As part of .NET 5.0, we are adding support for Windows. At this point, we believe that the .NET ARM64 implementation has functional parity with x64 (please report functional bugs!). We\u2019ve since shifted our focus toward performance parity with x64, for Windows and Linux. This issue tracks our progress to achieve that goal. Some of the issues we have identified may broader than ARM64, but still critical performance for our ARM64 performance goals.\r\n\r\n\r\n| Issues  | Description                                                               | Category               |\r\n|---------|---------------------------------------------------------------------------|------------------------|\r\n| #33308  | Optimize library APIs to use ARM64 hardware intrinsics                    | Libraries              |\r\n| #35108  | Indirect call produces redundant address load for R2R                     | Function call          |\r\n| #36700 | Virtual stub call produces redundant address load for R2R / JIT        | Function call          |\r\n| #35274  | [arm/arm64] Leaf frames, saving LR, and return address hijacking       | Function call        |\r\n| #38890 |   Cache the target of indirect cell address to optimize redundant target loading     | Function call        |\r\n| #36663 | Dead stores generated from arguments to the dead helper call  | Function call        |\r\n| #35631  | Unused HFA arguments still get written to stack                           | Function call          |\r\n| #35635  | HFA register arguments pushed to stack                                    | Function call          |\r\n| #35268  | Constant pool should share values                                         | General                |\r\n| #34937  | Optimize a % b operation for ARM64                                        | General                |\r\n| #35618  | Code inefficiencies in loop array indexing                                | General                |\r\n| #35257  | Double constants usage in a loop can be CSEed                             | General                |\r\n| #35976  | Vector64\u003CT\u003E is converted to HVA TYP_DOUBLE                             | General                | \r\n| #35622  | Addressing mode inefficiencies in Guid:op_Equality(Guid,Guid):bool        | Addressing mode        |\r\n| #34810  | ARM64: Post index addressing mode                                         | Addressing mode        |\r\n| #35141  | Optimize redundant memory loads with mov                                  | Peep-hole optimization |\r\n| #35071  | Redundant load/stores for methods that operates/returns structs           | Peep-hole optimization |\r\n| #35136  | Optimize pair of \u0022str wzr, [reg]\u0022 to \u0022str xzr\u0022                               | Peep-hole optimization |\r\n| #35134  | Optimize pair of \u0022str reg, [fp]\u0022 to stp                                   | Peep-hole optimization |\r\n| #35133  | Optimize pair of \u0022str reg, [reg]\u0022 to stp                                  | Peep-hole optimization |\r\n| #35132  | Optimize pair of \u0022ldr reg, [reg]\u0022 to ldp                                  | Peep-hole optimization |\r\n| #35130  | Optimize pair of \u0022ldr reg, [fp]\u0022 to ldp                                   | Peep-hole optimization |\r\n| #35252  | Redundant movs can be eliminiated                                         | Peep-hole optimization |\r\n| #35254  | Redundant movs done for zero extend the register                          | Peep-hole optimization |\r\n| #35614  | Remove redundant store that is immediately after the load in same src/dst | Peep-hole optimization |\r\n| #35613  | Remove redundant load that is immediately after the store in same src/dst | Peep-hole optimization |\r\n\r\ncategory:cq\r\ntheme:meta\r\nskill-level:expert\r\ncost:large",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "arch-arm64",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-CodeGen-coreclr",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "tenet-performance",
            "BackgroundColor": "c2e0c6"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#35410",
        "CreatedAt": "2020-04-24T15:10:53+00:00",
        "CreatedBy": "steveisok",
        "IsClosed": false,
        "Title": "Track fully enabling libraries tests and enabling missing features for iOS, Android, and Xam.Mac",
        "DescriptionMarkdown": "This epic serves as a libraries POV as we work towards full test coverage and add missing features for mobile in .NET 5.  \r\n\r\n## iOS\r\n\r\n### Testing\r\n- [ ] Fully integrate the test runner into the libraries build https://github.com/dotnet/runtime/issues/35123 (Steve)\r\n- [ ] Integrate with helix (Steve)\r\n- [ ] Analyze test results, identify issues to fix (Steve / Eric)\r\n\r\n### ICU\r\n- [ ] Build ICU for iOS/tvOS https://github.com/dotnet/runtime/issues/33654 \r\n- [ ] Do not package w/ Invariant mode enabled https://github.com/dotnet/runtime/issues/35090\r\n\r\n### Networking\r\n- [ ] iOS/tvOS specific define to create \u0060Foundation.NSUrlSessionHandler\u0060\r\n\r\n## Android\r\n\r\n### Testing\r\n- [ ] Fully integrate the test runner into the libraries build https://github.com/dotnet/runtime/issues/35262 (Steve)\r\n- [ ] Piggyback on iOS helix integration (Steve)\r\n- [ ] Analyze test results, identify issues to fix (Steve / Eric)\r\n\r\n### Security\r\n- [ ] Establish a process surrounding how we will manage the OpenSSL dependency (Jeff)\r\n- [ ] When the android runner is available, run existing tests w/ OpenSSL.  Identify missing features (Steve)\r\n\r\n### Networking\r\n- [ ] Android specific define to create \u0060AndroidClientHandler\u0060\r\n\r\n## Xam.Mac\r\n\r\n### Testing\r\n- [x] Enable in-tree runtime pack for desktop mono https://github.com/dotnet/runtime/issues/35247\r\n- [ ] **Blocked**  Ensure SDK can find the mono runtime pack ",
        "Milestone": "6.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#33654",
            "CreatedAt": "2020-03-16T22:46:23+00:00",
            "CreatedBy": "steveisok",
            "IsClosed": false,
            "Title": "Build icu for iOS/tvOS",
            "DescriptionMarkdown": "In order to support globalization on iOS, we would like a custom build version so that we know / can control the binary size and have more flexibility.  ",
            "Milestone": "6.0.0",
            "Assignees": [
              "akoeplinger"
            ],
            "Labels": [
              {
                "Name": "area-System.Globalization",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-ios",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "os-tvos",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35090",
            "CreatedAt": "2020-04-17T02:25:53+00:00",
            "CreatedBy": "steveisok",
            "IsClosed": false,
            "Title": "Ensure ICU is not packaged when Invariant mode is enabled",
            "DescriptionMarkdown": "When Invariant mode is enabled and we are publishing for iOS / tvOS, we must ensure that no ICU artifacts are produced.\r\n\r\nExample:\r\n\u0060dotnet publish \u003Crequired-args\u003E /p:InvariantGlobalization=true\u0060\r\n\r\nNo ICU binaries should be in the publish folder.",
            "Milestone": "6.0.0",
            "Assignees": [
              "akoeplinger"
            ],
            "Labels": [
              {
                "Name": "area-Infrastructure-mono",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-ios",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "os-tvos",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35262",
            "CreatedAt": "2020-04-21T22:04:03+00:00",
            "CreatedBy": "steveisok",
            "IsClosed": true,
            "Title": "Enable the test runner for Android",
            "DescriptionMarkdown": "In order to run tests against Android, we must:\r\n\r\n**Base Docker Image**\r\n- [x] Install the android sdk on the base docker image\r\n- [x] Ensure all the platform tools (API level 21) are installed (and any other tools we need)\r\n\r\n**Build**\r\n- [x] Create targets / props that support building the test runner app (Use / expand upon https://github.com/dotnet/runtime/issues/35123)\r\n- [x] Port the test host (may be able to trim the iOS host)\r\n- [x] Compile / link with mono-runtime \r\n- [x] Run a successful test ",
            "Milestone": "6.0.0",
            "Assignees": [
              "EgorBo"
            ],
            "Labels": [
              {
                "Name": "area-Infrastructure-mono",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-android",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": [
            {
              "Issue": {
                "Id": "dotnet/runtime#35123",
                "CreatedAt": "2020-04-17T18:58:54+00:00",
                "CreatedBy": "steveisok",
                "IsClosed": true,
                "Title": "Integrate the iOS test runner into the build",
                "DescriptionMarkdown": "We want to make the mobile testing experience as similar as possible, so the end goal should be:\r\n\r\n\u0060build.sh/cmd -os iOS -arch \u003Cx86/arm/arm64\u003E -Subset mono\u002Blibs\u002Blibs.test -test -c Release\u0060\r\n\r\nWithin that, we need to accomplish (feel free to add others):\r\n\r\n- [x] Migrate existing props and targets into the libraries test build flow \r\n- [x] If not already there, add target to redirect publish to use the in tree runtime pack folder\r\n- [x] Modify build to use \u0060dotnet publish\u0060 for each test suite.  If 1 app per suite is not appropriate locally, adjust to something more acceptable.\r\n- [x] Enable property to specify a provisioning profile (device test runs)",
                "Milestone": "5.0.0",
                "Assignees": [
                  "mdh1418"
                ],
                "Labels": [
                  {
                    "Name": "area-Infrastructure-libraries",
                    "BackgroundColor": "d4c5f9"
                  },
                  {
                    "Name": "area-Infrastructure-mono",
                    "BackgroundColor": "d4c5f9"
                  }
                ],
                "Kind": 3,
                "ProjectStatus": null
              },
              "Children": []
            }
          ]
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35247",
            "CreatedAt": "2020-04-21T16:35:32+00:00",
            "CreatedBy": "steveisok",
            "IsClosed": true,
            "Title": "Enable in tree runtime pack for all of mono",
            "DescriptionMarkdown": "After working with this in a mobile context, I can see it providing benefits to all of mono.  Most notably as a replacement for our \u0027patch-dotnet\u0027 target.  \r\n\r\n- [ ] Relax the check for \u0060BinPlaceTestRuntimePack\u0060 to be \u0060RuntimeFlavor = \u0027mono\u0027\u0060 \r\n- [ ] For desktop, the test host needs to be generated, so ensure that\u0027s still working right (basically, you should successfully run libraries tests)\r\n- [ ] Validate \u0060lib-runtime-packs\u0060 folder is created w/ the right contents",
            "Milestone": null,
            "Assignees": [
              "mdh1418"
            ],
            "Labels": [
              {
                "Name": "area-Infrastructure-mono",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#35318",
        "CreatedAt": "2020-04-23T00:12:07+00:00",
        "CreatedBy": "AaronRobinsonMSFT",
        "IsClosed": true,
        "Title": "Support WinRT APIs in .NET 5",
        "DescriptionMarkdown": "We are moving to a new model for supporting WinRT APIs as part of .NET 5.0. This includes calling APIs (in either direction; CLR \u003C==\u003E WinRT), marshaling of data between the two type systems, and unification of types that are intended to be single instance (i.e. \u0022projected types\u0022). We will be removing the existing WinRT interop system from the .NET runtime (and any other associated components) as part of .NET 5.0.\r\n\r\nWe will rely on a new set of tools provided by the WinRT team in Windows that will generate C#-based WinRT interop assemblies. We are currently working closely with that team. The tools will be delivered for .NET 5.0.\r\n\r\nThere are several benefits to the new system:\r\n* Can be developed and improved separate from the .NET runtime.\r\n* Symmetrical with interop systems provided for other OSes, like iOS and Android.\r\n* Can take advantage of many other .NET features (AOT, C# features, IL linking).\r\n* Simplifies the .NET runtime codebase.\r\n\r\n### Goals\r\n* Allow the WinRT ecosystem to move independently of the .NET runtime with respect to WinRT projections.\r\n* Migration of existing applications and libraries to this new model should require minimal code changes. Creating a new project and recompilation is considered acceptable.\r\n* Provide a WinRT solution that is AOT and [ILLinker](https://github.com/mono/linker) friendly.\r\n* Permit the ability to remove built-in .NET Runtime support of WinRT. \r\n* Provide similar performance to what is available with .NET Core 3.1.\r\n\r\n### Non-Goals\r\n* Support existing WinMD-based managed WinRT assemblies.\r\n* Replace the MCG tool used by .NET Native.\r\n\r\n## .NET Runtime/SDK work\r\n- [x] Creation and management of [COM wrappers](https://github.com/dotnet/runtime/issues/1845).\r\n  - [x] Support [\u0060ICustomQueryInterface\u0060](https://github.com/dotnet/runtime/issues/34717).\r\n  - [x] Provide [a mechanism to determine if \u0060ComWrappers\u0060 are being called from legacy APIs](https://github.com/dotnet/runtime/issues/35530).\r\n  - [x] Ensure [\u0060IWeakReference\u0060](https://docs.microsoft.com/windows/win32/api/weakreference/nn-weakreference-iweakreference) continues to interact with the .NET types: [\u0060WeakReference\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference) and [\u0060WeakReference\u003CT\u003E\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference-1). See https://github.com/dotnet/runtime/issues/35745.\r\n  - [x] [Support an \u0060ICastable\u0060-esque solution](https://github.com/dotnet/runtime/issues/36654).\r\n- [C# function pointers](https://github.com/dotnet/roslyn/issues/39865) to achieve performance goals.\r\n  - This work was already in flight with the [C# function pointers proposal](https://github.com/dotnet/csharplang/blob/master/proposals/function-pointers.md).\r\n  - [x] Expose ~~[\u0060NativeCallableAttribute\u0060](https://github.com/dotnet/runtime/issues/32462)~~ [\u0060UnmanagedCallersOnlyAttribute\u0060](https://github.com/dotnet/runtime/issues/35433).\r\n  \r\n## [CsWinRT](https://github.com/microsoft/CsWinRT) work\r\n\r\n- [x] Consume the new [\u0060ComWrappers\u0060](https://github.com/dotnet/runtime/issues/1845) API.\r\n- [x] Help generate C# source for interop code.\r\n  - [x] Support correct managed object wrapper lifetime management. https://github.com/microsoft/CsWinRT/issues/37\r\n  - [x] Support default implemented interfaces. https://github.com/microsoft/CsWinRT/issues/49\r\n  - [x] Marshaling of arrays of interfaces. https://github.com/microsoft/CsWinRT/issues/61\r\n  - [x] Support [\u0060IRestrictedErrorInfo\u0060](https://docs.microsoft.com/windows/win32/api/restrictederrorinfo/nn-restrictederrorinfo-irestrictederrorinfo). https://github.com/microsoft/CsWinRT/issues/76\r\n  - [x] Support [\u0060ICustomPropertyProvider\u0060](https://docs.microsoft.com/uwp/api/windows.ui.xaml.data.icustompropertyprovider). https://github.com/microsoft/CsWinRT/issues/102\r\n\r\n## Breaking changes\r\n\r\nRemoval of built-in WinRT support. See https://github.com/dotnet/runtime/issues/37672.\r\n - https://github.com/dotnet/runtime/pull/36715\r\n\r\n/cc @richlander @jeffschwMSFT @jkoritzinsky @elinor-fung ",
        "Milestone": "5.0.0",
        "Assignees": [
          "jkoritzinsky",
          "AaronRobinsonMSFT"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Interop-coreclr",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "breaking-change",
            "BackgroundColor": "ffa500"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#1845",
            "CreatedAt": "2020-01-17T02:01:47+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "Low level API support for RCW and CCW management",
            "DescriptionMarkdown": "Work has begun to provide support for [WinUI 3.0](https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md#winui-3). This support is expected to manifest in a way similar to the [CppWinRT](https://github.com/microsoft/cppwinrt) tool by way of a new source generation tool (e.g. CsWinRT). In order to support this new tool, APIs for integrating and coordinating with the runtime object lifetime are necessary.\r\n\r\n# Rationale and Usage\r\n\r\nThe below API surface provides a way for a third party tool to generate what are colloquially known as [Runtime Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/runtime-callable-wrapper) (RCW) and [COM Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/com-callable-wrapper) (CCW) in a way that allows safe interaction with managed object lifetime and identity.\r\n\r\nA specific example of the need for lifetime coordination is in WinRT scenarios involving UI (e.g.  WinUI 3.0) via the [\u0060IReferenceTrackerManager\u0060](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackermanager) interface.\r\n\r\n## Goals:\r\n* Enable source generation of interop code in WinRT/WinUI scenarios.\r\n* An API that generally aligns with how existing 3rd party source generators work (e.g. [SharpGenTools](https://github.com/SharpGenTools/SharpGenTools)).\r\n* Limit exposing APIs that manage lifetime in a micro way (e.g. avoid GC hooks at dangerous times).\r\n* Semantics in .NET Framework/.NET Core for WinRT scenarios should be able to be replicated.\r\n* Provide a mechanism for 3rd parties to be able to support [Reference Tracker scenarios](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/).\r\n* Ensure AOT scenarios are considered.\r\n\r\n## Non-Goals:\r\n* Replace the existing built-in RCW/CCW infrastructure.\r\n* Change anything related to P/Invoke Interop.\r\n* Hide WinRT and/or COM concepts.\r\n\r\n## Outstanding questions:\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385491739\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385498872\r\n\r\n# Proposed API\r\n\r\n\u0060\u0060\u0060 CSharp\r\nnamespace System.Runtime\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Allocate memory that is associated with the \u003Cparamref name=\u0022type\u0022/\u003E and\r\n        /// will be freed if and when the \u003Csee cref=\u0022System.Type\u0022/\u003E is unloaded.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022type\u0022\u003EType associated with the allocated memory.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022size\u0022\u003EAmount of memory in bytes to allocate.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe allocated memory\u003C/returns\u003E\r\n        public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateComInterfaceFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The caller will provide an IUnknown Vtable.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is useful in scenarios when the caller has no need to rely on an IUnknown instance\r\n        /// that is used when running managed code is not possible (i.e. during a GC). In traditional\r\n        /// COM scenarios this is common, but scenarios involving \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EReference Tracker hosting\u003C/see\u003E\r\n        /// calling of the IUnknown API during a GC is possible.\r\n        /// \u003C/remarks\u003E\r\n        CallerDefinedIUnknown = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Flag used to indicate the COM interface should implement \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EIReferenceTrackerTarget\u003C/see\u003E.\r\n        /// When this flag is passed, the resulting COM interface will have an internal implementation of IUnknown\r\n        /// and as such none should be supplied by the caller.\r\n        /// \u003C/summary\u003E\r\n        TrackerSupport = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateObjectFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicate if the supplied external COM object implements the \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetracker\u0022\u003EIReferenceTracker\u003C/see\u003E.\r\n        /// \u003C/summary\u003E\r\n        TrackerObject = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Ignore any internal caching and always create a unique instance.\r\n        /// \u003C/summary\u003E\r\n        UniqueInstance = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Class for managing wrappers of COM IUnknown types.\r\n    /// \u003C/summary\u003E\r\n    [CLSCompliant(false)]\r\n    public abstract partial class ComWrappers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Interface type and pointer to targeted VTable.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceEntry\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Interface IID.\r\n            /// \u003C/summary\u003E\r\n            public Guid IID;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Memory must have the same lifetime as the memory returned from the call to \u003Csee cref=\u0022ComputeVtables(object, CreateComInterfaceFlags, out int)\u0022/\u003E.\r\n            /// \u003C/summary\u003E\r\n            public IntPtr Vtable;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// ABI for function dispatch of a COM interface.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceDispatch\r\n        {\r\n            public IntPtr vftbl;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Given a \u003Csee cref=\u0022System.IntPtr\u0022/\u003E from a generated VTable, convert to the target type.\r\n            /// \u003C/summary\u003E\r\n            /// \u003Ctypeparam name=\u0022T\u0022\u003EDesired type.\u003C/typeparam\u003E\r\n            /// \u003Cparam name=\u0022dispatchPtr\u0022\u003EPointer supplied to VTable function entry.\u003C/param\u003E\r\n            /// \u003Creturns\u003EInstance of type associated with dispatched function call.\u003C/returns\u003E\r\n            public static unsafe T GetInstance\u003CT\u003E(ComInterfaceDispatch* dispatchPtr) where T : class;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create an COM representation of the supplied object that can be passed to an non-managed environment.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022instance\u0022\u003EA GC Handle to the managed object to expose outside the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to configure the generated interface.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe generated COM interface that can be passed outside the .NET runtime.\u003C/returns\u003E\r\n        public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Compute the desired VTables for \u003Cparamref name=\u0022obj\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003ETarget of the returned VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to compute VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022count\u0022\u003EThe number of elements contained in the returned memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003E\u003Csee cref=\u0022ComInterfaceEntry\u0022 /\u003E pointer containing memory for all COM interface entries.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All memory returned from this function must either be unmanaged memory, pinned managed memory, or have been\r\n        /// allocated with the \u003Csee cref=\u0022System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(Type, int)\u0022/\u003E API.\r\n        ///\r\n        /// If the interface entries cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected unsafe abstract ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the currently registered managed object or creates a new managed object and registers it.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022wrapper\u0022\u003EAn optional \u003Csee cref=\u0022object\u0022/\u003E to be used as the wrapper for the external object\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing a \u003Cparamref name=\u0022wrapper\u0022/\u003E instance means \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E\r\n        /// will not be called.\r\n        ///\r\n        /// If the \u003Cparamref name=\u0022wrapper\u0022/\u003E instance already has an associated external object a \u003Csee cref=\u0022System.NotSupportedException\u0022/\u003E will be thrown.\r\n        /// \u003C/remarks\u003E\r\n        public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object? wrapper = null);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create a managed object for the object pointed at by \u003Cparamref name=\u0022externalComObject\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the object cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected abstract object? CreateObject(IntPtr externalComObject, CreateObjectFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Called when a request is made for a collection of objects to be released.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022objects\u0022\u003ECollection of objects to release.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// The default implementation of this function throws \u003Csee cref=\u0022System.NotImplementedException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected virtual void ReleaseObjects(IEnumerable objects);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Register this class\u0027s implementation to be used as the single global instance.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This function can only be called a single time. Subsequent calls to this function will result\r\n        /// in a \u003Csee cref=\u0022System.InvalidOperationException\u0022/\u003E being thrown.\r\n        ///\r\n        /// Scenarios where the global instance may be used are:\r\n        ///  * Object tracking via the \u003Csee cref=\u0022CreateComInterfaceFlags.TrackerSupport\u0022 /\u003E and \u003Csee cref=\u0022CreateObjectFlags.TrackerObject\u0022 /\u003E flags.\r\n        ///  * Usage of COM related Marshal APIs.\r\n        /// \u003C/remarks\u003E\r\n        public void RegisterAsGlobalInstance();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the runtime provided IUnknown implementation.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022fpQueryInterface\u0022\u003EFunction pointer to QueryInterface.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpAddRef\u0022\u003EFunction pointer to AddRef.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpRelease\u0022\u003EFunction pointer to Release.\u003C/param\u003E\r\n        protected static void GetIUnknownImpl(out IntPtr fpQueryInterface, out IntPtr fpAddRef, out IntPtr fpRelease);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n# Example usage\r\n\r\nThe below example is merely for illustrative purposes. In a production ready consumption of the API many of the \u0060Marshal\u0060 APIs would not be used and the VTable layouts should be done in a static manner for optimal efficiency.\r\n\r\n\u0060\u0060\u0060CSharp\r\n[Guid(\u0022197BC142-7A71-4637-B504-894DE79C4A22\u0022)]\r\ninterface IPrint\r\n{\r\n    public void PrintInt(int i);\r\n}\r\n\r\nclass Print : IPrint\r\n{\r\n    public void PrintInt(int i)\r\n    {\r\n        Console.WriteLine($\u0022{nameof(IPrint.PrintInt)} - 0x{i:x}\u0022);\r\n    }\r\n}\r\n\r\nstruct IUnknownVftbl\r\n{\r\n    public IntPtr QueryInterface;\r\n    public IntPtr AddRef;\r\n    public IntPtr Release;\r\n}\r\n\r\nstruct IPrintVftbl\r\n{\r\n    public IUnknownVftbl IUnknownImpl;\r\n    public IntPtr PrintInt;\r\n\r\n    public delegate int _PrintInt(IntPtr thisPtr, int i);\r\n    public static _PrintInt pPrintInt = new _PrintInt(PrintIntInternal);\r\n\r\n    public static int PrintIntInternal(IntPtr dispatchPtr, int i)\r\n    {\r\n        unsafe\r\n        {\r\n            try\r\n            {\r\n                ComWrappers.ComInterfaceDispatch.GetInstance\u003CIPrint\u003E((ComWrappers.ComInterfaceDispatch*)dispatchPtr).PrintInt(i);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n            return e.HResult;\r\n            }\r\n        }\r\n\r\n        return 0; // S_OK;\r\n    }\r\n}\r\n\r\nstruct VtblPtr\r\n{\r\n    public IntPtr Vtbl;\r\n}\r\n\r\nclass IExternalObject\r\n{\r\n    private struct IExternalObjectVftbl\r\n    {\r\n        public IntPtr QueryInterface;\r\n        public _AddRef AddRef;\r\n        public _Release Release;\r\n        public _AddObjectRef AddObjectRef;\r\n        public _RemoveObjectRef DropObjectRef;\r\n    }\r\n\r\n    private delegate int _AddRef(IntPtr This);\r\n    private delegate int _Release(IntPtr This);\r\n    private delegate int _AddObjectRef(IntPtr This, IntPtr o);\r\n    private delegate int _RemoveObjectRef(IntPtr This, IntPtr o);\r\n\r\n    private readonly IntPtr instance;\r\n    private readonly IExternalObjectVftbl vtable;\r\n\r\n    public IExternalObject(IntPtr instance)\r\n    {\r\n        var inst = Marshal.PtrToStructure\u003CVtblPtr\u003E(instance);\r\n        this.vtable = Marshal.PtrToStructure\u003CIExternalObjectVftbl\u003E(inst.Vtbl);\r\n        this.instance = instance;\r\n    }\r\n\r\n    ~IExternalObject()\r\n    {\r\n        if (this.instance != IntPtr.Zero)\r\n        {\r\n            this.vtable.Release(this.instance);\r\n        }\r\n    }\r\n\r\n    public void AddObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n\r\n    public void DropObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n}\r\n\r\nclass MyComWrappers : ComWrappers\r\n{\r\n    protected unsafe override ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count)\r\n    {\r\n        IntPtr fpQueryInteface = default;\r\n        IntPtr fpAddRef = default;\r\n        IntPtr fpRelease = default;\r\n        ComWrappers.GetIUnknownImpl(out fpQueryInteface, out fpAddRef, out fpRelease);\r\n\r\n        var tables = new List\u003CComInterfaceEntry\u003E();\r\n\r\n        var vtbl1 = new IPrintVftbl()\r\n        {\r\n            IUnknownImpl = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            },\r\n            PrintInt = Marshal.GetFunctionPointerForDelegate(IPrintVftbl.pPrintInt)\r\n        };\r\n        var vtblRaw1 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IPrintVftbl), sizeof(IPrintVftbl));\r\n        Marshal.StructureToPtr(vtbl1, vtblRaw1, false);\r\n        tables.Add(new ComInterfaceEntry { IID = IID_IPrint, Vtable = vtblRaw1 });\r\n\r\n        if (flags.HasFlag(CreateComInterfaceFlags.CallerDefinedIUnknown))\r\n        {\r\n            var vtbl2 = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            };\r\n            var vtblRaw2 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IUnknownVftbl), sizeof(IUnknownVftbl));\r\n            Marshal.StructureToPtr(vtbl2, vtblRaw2, false);\r\n            tables.Add(new ComInterfaceEntry { IID = IID_IUnknown, Vtable = vtblRaw2 });\r\n        }\r\n\r\n        // Return pointer to memory containing ComInterfaceEntry collection\r\n    }\r\n\r\n    protected override object CreateObject(IntPtr externalComObject, CreateObjectFlags flags)\r\n    {\r\n        return new IExternalObject(externalComObject);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n/cc @jkotas @Scottj1s @dunhor @jkoritzinsky @davidwrighton @terrajobst @tannergooding @jeffschwMSFT ",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-windows",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#34717",
            "CreatedAt": "2020-04-08T22:07:34+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "ComWrappers should support ICustomQueryInterface for Managed Object Wrappers",
            "DescriptionMarkdown": "The ComWrappers API should support falling back to [\u0060ICustomQueryInterface\u0060](https://docs.microsoft.com/dotnet/api/system.runtime.interopservices.icustomqueryinterface) if the managed object wrapper didn\u0027t supply a VTable for the requested IID.\r\n\r\n/cc @jkoritzinsky @scottj1s",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35530",
            "CreatedAt": "2020-04-27T18:38:50+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "ComWrappers API does not provide a mechanism to identify when it is called from old-style APIs",
            "DescriptionMarkdown": "In #33485, we wired up the ComWrappers API to be called first-chance from the Marshal APIs and from the IL stub marshalers. This has started to prove a problem for CsWinRT, since there\u0027s no way to determine when to use the ComWrappers\u0027 implementation and when to use the runtime\u0027s built-in APIs.\r\n\r\nIn particular, the CsWinRT ComWrappers implementation of \u0060ComputeVtables\u0060 has to be able to handle all types, including types that do not implement any WinRT APIs, to correctly implement WinRT semantics for WinUI. Additionally, since WinUI depends on the reference tracking support from ComWrappers, the CsWinRT ComWrappers implementation has to be registered as the global implementation. As a result, if someone such as WPF calls \u0060Marshal.GetIUnknownForObject\u0060, this call will go down the ComWrappers route first if the Windows SDK is also being used. WPF is expecting to get the built-in runtime-implemented CCWs, but by default CsWinRT would provide one instead.\r\n\r\nThis proves to be a problem when the user (either WPF or someone else directly using the Marshal APIs or using COM objects in P/Invoke signatures) is trying to pass a managed implementations of COM APIs to native. CsWinRT\u0027s ComWrappers only support the WinRT model (as it should be, they shouldn\u0027t have to completely re-implement the runtime\u0027s CCW/RCW implementation), so they would create a WinRT CCW of the managed object.\r\n\r\nWe could attempt to use a heuristic in the CsWinRT ComWrappers implementation to determine whether to use the ComWrappers or just return null and fall back, but that heuristic may be tricky or downright impossible to get exactly right. I\u0027ve included an example below where the heuristic is extremely difficult if not impossible:\r\n\r\nLet\u0027s take a class \u0060class Foo : System.Collections.IEnumerable { ... }\u0060 and a P/Invoke signature \u0060void Bar(System.Collections.IEnumerable ienum)\u0060. In the WinRT world, we would want to treat this as a \u0060Microsoft.UI.Xaml.Interop.IBindableIterable\u0060. However, the built-in CCW system would generate an \u0060IDispatch\u0060 implementation that exposes the \u0060GetEnumerator\u0060 method as \u0060DISPID_NEWENUM\u0060.\r\n\r\nSince there is no way to determine from within a \u0060ComWrappers\u0060 implementation if it is being called from the \u0060Marshal\u0060 APIs or a P/Invoke marshaler (without attempting to just look up the call stack), the CsWinRT ComWrappers would never be able to know if it should marshal an instance of \u0060Foo\u0060 itself or if it should let the runtime marshal it.\r\n\r\nThere is a corresponding problem for the RCW direction, but using a heuristic of \u0022does this object implement IInspectable\u0022 works well as a heuristic for ComWrappers.\r\n\r\nThere are a few possible solutions here:\r\n- Provide an additional flag on the \u0060CreateObjectFlags\u0060 and \u0060CreateComInterfaceFlags\u0060 enumeration to denote when the ComWrappers methods are being called from the \u0060Marshal\u0060 APIs or from an IL stub.\r\n- Remove the support wiring up a ComWrappers instance as a first-chance handler for the Marshal APIs or from an IL stub.\r\n\r\nI\u0027m also open to additional ideas.\r\n\r\ncc: @AaronRobinsonMSFT @elinor-fung @jkotas ",
            "Milestone": "5.0.0",
            "Assignees": [
              "elinor-fung"
            ],
            "Labels": [
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#35745",
            "CreatedAt": "2020-05-02T06:48:24+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "WeakReference and WeakReference\u003CT\u003E should continue to support IWeakReference",
            "DescriptionMarkdown": "The work implied in https://github.com/dotnet/runtime/issues/33330 indicates much of the WinRT sub-system will be removed. One area that should be retained is the support between [\u0060IWeakReference\u0060](https://docs.microsoft.com/windows/win32/api/weakreference/nn-weakreference-iweakreference) and the .NET types [\u0060WeakReference\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference) and [\u0060WeakReference\u003CT\u003E\u0060](https://docs.microsoft.com/dotnet/api/system.weakreference-1).\r\n\r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#36654",
            "CreatedAt": "2020-05-18T15:33:50+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "IDynamicInterfaceCastable interface",
            "DescriptionMarkdown": "## Background and Motivation\r\n\r\nIn the .NET Native runtime support existed for a .NET class to participate in a C-style cast when that class didn\u0027t support the cast-to type. The COM [\u0060QueryInterface()\u0060](https://docs.microsoft.com/windows/win32/com/queryinterface--navigating-in-an-object) is an example where this kind of scenario exists. In COM, the instance is represented by an opaque \u0060IUnknown\u0060 pointer and the only way to discover what is supported by the instance is to call \u0060QueryInterface()\u0060 with a \u0060GUID\u0060 representing the question of \u0022Does this instance support this type?\u0022. The answer is typically a simple \u0022yes\u0022 (\u0060S_OK\u0060) or \u0022no\u0022 (\u0060E_NOINTERFACE\u0060). If the answer is \u0022yes\u0022, a casted to instance of the type is returned, otherwise \u0060null\u0060. There are scenarios where the current instance may not have implemented this type but can provide an instance that does - this is called a tear-off.\r\n\r\nIn .NET, the metadata for a type is static and therefore if a type can\u0027t be cast to another type because it isn\u0027t in metadata that is correct. This means that a type has no reason to participate in the casting question. However, when implementing support for a COM scenario this rigidity isn\u0027t as beneficial since it may not be possible to know all the supported types on an instance. This proposal provides a way to let types provide an answer and an \u0060object\u0060 instance that does satisfy the requested type eventhough the original instance does not and still adhere to the static metadata constraints of .NET.\r\n\r\nIn .NET Native there are two mechanisms to address this problem. The first, \u0060ICastable\u0060 interface, proved to have usability issues. Usage of the \u0060ICastable\u0060 API was error prone and had a potentially catastrophic consequence if used incorrectly - silent success or an unstable runtime. The [\u0060ICastable\u0060 API][icastable_link] exists in the CoreCLR runtime but is not publicly exposed and exists only to support MCG scenarios.\r\n\r\nThe second approach was \u0060CastableObject\u0060. This approach didn\u0027t return a type but instead returned an actual \u0060object\u0060 instance to dispatch on. The \u0060CastableObject\u0060 type is an \u0060abstract\u0060 type that contained some minor state for caching purposes. This approach did require inserting a new type into the user\u0027s type hierarchy. Updating the type hierarchy and the stored state of the \u0060abstract\u0060 type made this solution more reliable, but less performant than \u0060ICastable\u0060.\r\n\r\nFor CoreCLR, the following proposal is based on lessons learned from .NET Native along with a recent C# language feature, [default interfaces](https://devblogs.microsoft.com/dotnet/default-implementations-in-interfaces/), that make a modified version of the \u0060ICastable\u0060 approach easier to implement with confidence. The proposed interface followed by a usage example are described below.\r\n\r\n**Goals**\r\n\r\n- Support the [\u0060ComWrappers\u0060 API]((https://github.com/dotnet/runtime/issues/1845)) in creating C# friendly wrappers for external \u0060IUnknown\u0060 based objects.\r\n- Avoid having to call \u0060QueryInterface()\u0060 for all possible supported types when an external \u0060IUnknown\u0060 based object enters the runtime.\r\n- Support IL Linker scenarios.\r\n\r\n**Non-Goals**\r\n\r\n- Remove or alter current \u0060ICastable\u0060 scenarios.\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060CSharp\r\nnamespace System.Runtime.CompilerServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Interface used to participate in a type cast failure.\r\n    /// \u003C/summary\u003E\r\n    public interface ICastableObject\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Called when an implementing class instance is cast to an interface type that\r\n        /// is not contained in the class\u0027s metadata.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022interfaceType\u0022\u003EThe interface type.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022throwIfNotFound\u0022\u003EIndicates if the function should throw an exception rather than default(RuntimeTypeHandle).\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe type that should be used to dispatch for \u003Cparamref name=\u0022interfaceType\u0022/\u003E on the current object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is called if casting this object to the given interface type would\r\n        /// otherwise fail. Casting here means the IL isinst and castclass instructions\r\n        /// in the case where they are given an interface type as the target type. This\r\n        /// function may also be called during interface dispatch.\r\n        ///\r\n        /// The returned type must be an interface type marked with the \u003Csee cref=\u0022CastableObjectImplementationAttribute\u0022/\u003E, otherwise \u003Csee cref=\u0022System. InvalidOperationException\u0022 /\u003E\r\n        /// will be thrown. When the \u003Cparamref name=\u0022throwIfNotFound\u0022 /\u003E is set to false,\r\n        /// a return value of default(RuntimeTypeHandle) is permitted. If \u003Cparamref name=\u0022throwIfNotFound\u0022 /\u003E\r\n        /// is true and default(RuntimeTypeHandle) is returned then \u003Csee cref=\u0022System.InvalidCastException\u0022 /\u003E\r\n        /// will be thrown unless an exception is thrown by the implementation.\r\n        /// \u003C/remarks\u003E\r\n        RuntimeTypeHandle GetInterfaceImplementation(RuntimeTypeHandle interfaceType, bool throwIfNotFound);\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Attribute required by any type that is returned by \u003Csee cref=\u0022ICastableObject.GetInterfaceImplementation(RuntimeTypeHandle, bool)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// This attribute is used to enforce policy in the runtime and make\r\n    /// \u003Csee cref=\u0022ICastableObject\u0022 /\u003E scenarios linker friendly.\r\n    /// \u003C/remarks\u003E\r\n    [AttributeUsage(AttributeTargets.Interface, AllowMultiple = false, Inherited = false)]\r\n    public sealed class CastableObjectImplementationAttribute : Attribute\r\n    {\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n### Design notes\r\n\r\n- The default interface method itself will be called with a \u0060this\u0060 pointer that by definition should implement the enclosing type (e.g. \u0060IFooImpl\u0060) as well as any implementing types (e.g. \u0060IFoo\u0060). We will need to define the exact semantics and requirements here.\r\n- Virtual Stub Dispatch (VSD) caching.\r\n    - \u0060ICastableObject\u0060 could control casting on a per object basis, as we can easily call \u0060GetInterfaceImplementation()\u0060 at each cast opportunity.\r\n    - \u0060ICastableObject\u0060 would control the result of a dispatching on an interface at a per TYPE level. So, a given type could not use different default interface type (e.g. \u0060IFooImpl\u0060) for different instances. This would be sufficient for any plausible use of this feature for interop, but it might impact useablility for aspect oriented programming, etc. \r\n    - The end result is that a given object may or may not implement the interface, but if it does, all implementations must be the same.\r\n- By throwing an exception from the interface impl the debugger will report the exception as coming from that type. We should suggest to users of this API to utilize some debugger attributes to make everything look normal. \r\n\r\n## Usage Examples\r\n\r\nConsider the following interface and class.\r\n\r\n\u0060\u0060\u0060 CSharp\r\n\r\ninterface IFoo\r\n{\r\n    int CallMe(int i);\r\n}\r\n\r\nclass Baz\r\n{\r\n    ...\r\n}\r\n\r\nclass Bar : ICastableObject\r\n{\r\n    ...\r\n\r\n    // Call when cast is performed on an instance of Bar but the type isn\u0027t in Bar\u0027s metadata.\r\n    RuntimeTypeHandle ICastableObject.GetInterfaceImplementation(RuntimeTypeHandle interfaceType, bool throwIfNotFound)\r\n    {\r\n        Debug.Assert(interfaceType.Value != IntPtr.Zero);\r\n\r\n        if (interfaceType == typeof(IFoo).TypeHandle)\r\n            return typeof(IFooImpl).TypeHandle;\r\n        \r\n        if (throwIfNotFound)\r\n        {\r\n            var typeName = Type.GetTypeFromHandle(interfaceType).FullName;\r\n            throw new InvalidCastException($\u0022Don\u0027t support {typeName}\u0022);\r\n        }\r\n\r\n        return default;\r\n    }\r\n\r\n    // An \u0022implemented\u0022 interface instance that will handle \u0022this\u0022 of type \u0022Bar\u0022.\r\n    // Note that when this default interface implementation is called, the \u0022this\u0022 will\r\n    // be typed as a \u0022IFooImpl\u0022.\r\n    [CastableObjectImplementation]\r\n    public interface IFooImpl : IFoo\r\n    {\r\n        int IFoo.CallMe(int i)\r\n        {\r\n            // Perform desired action on the \u0022this\u0022 pointer which will be of type Bar.\r\n            //  - Cast to some other type\r\n            //  - Unsafe.As\u003CT\u003E()\r\n            //  - Table look up\r\n            //  - etc.\r\n            ...\r\n        }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe following is an example of usage.\r\n\r\n\u0060\u0060\u0060CSharp\r\nBaz z = ...;\r\n\r\n// Will result in InvalidCastException being thrown.\r\nIFoo zf = (IFoo)z;\r\n\r\nBar b = ...;\r\n\r\n// However, since Bar implements ICastableObject, GetInterfaceImplementation will be called.\r\nIFoo bf = (IFoo)b;\r\n// bf is a Bar.IFooImpl with a Bar \u0027this\u0027\r\n\r\n// Will call Bar.IFooImpl.CallMe()\r\nbf.CallMe(27);\r\n\u0060\u0060\u0060\r\n\r\n## Community impact\r\n\r\n- Expose \u0060ICastable\u0060 request: https://github.com/dotnet/runtime/issues/23727\r\n- How MCG supported COM: https://github.com/dotnet/runtime/issues/10572#issuecomment-400129044\r\n- Discussion for \u0060ICastable\u0060: https://github.com/dotnet/corert/issues/4219#issuecomment-623671255\r\n- Support in \u0060ComWrappers\u0060 API: https://github.com/dotnet/runtime/issues/35929\r\n- Mono request: https://github.com/mono/mono/issues/9423\r\n\r\n\u003C!-- Links --\u003E\r\n[icastable_link]: https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Runtime/CompilerServices/ICastable.cs\r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Runtime.CompilerServices",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#32462",
            "CreatedAt": "2020-02-18T01:41:51+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "NativeCallableAttribute should be a public API",
            "DescriptionMarkdown": "**Update** This API\u0027s name has changed. See https://github.com/dotnet/runtime/issues/35433.\r\n\r\nThe [\u0060NativeCallableAttribute\u0060](https://github.com/dotnet/runtime/blob/master/src/libraries/System.Private.CoreLib/src/System/Runtime/InteropServices/NativeCallableAttribute.cs) should be made public since it will provide a symmetrical solution with the [C# Function pointer proposal](https://github.com/dotnet/csharplang/blob/master/proposals/function-pointers.md).\r\n\r\n## Proposed API\r\n\r\n\u0060\u0060\u0060Csharp\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Any method marked with \u003Csee cref=\u0022System.Runtime.InteropServices.NativeCallableAttribute\u0022 /\u003E can be directly called from\r\n    /// native code. The function token can be loaded to a local variable using LDFTN\r\n    /// and passed as a callback to native method.\r\n    /// \u003C/summary\u003E\r\n    /// \u003Cremarks\u003E\r\n    /// Methods marked with this attribute have the following restrictions:\r\n    ///   * Method must be marked \u0022static\u0022.\r\n    ///   * Must not be called from managed code.\r\n    ///   * Must only have \u003Csee href=\u0022https://docs.microsoft.com/dotnet/framework/interop/blittable-and-non-blittable-types\u0022\u003Eblittable\u003C/see\u003E arguments.\r\n    /// \u003C/remarks\u003E\r\n    [AttributeUsage(AttributeTargets.Method)]\r\n    public sealed class NativeCallableAttribute : Attribute\r\n    {\r\n        public NativeCallableAttribute();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Optional. If omitted, compiler will choose one for you.\r\n        /// \u003C/summary\u003E\r\n        public CallingConvention CallingConvention;\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Optional. If omitted, then the method is native callable, but no export is emitted during AOT compilation.\r\n        /// \u003C/summary\u003E\r\n        public string? EntryPoint;\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nRelated:\r\n* [C# Function pointer concerns](https://github.com/dotnet/csharplang/blob/master/proposals/function-pointers.md#nativecallableattribute).\r\n* [COM Wrappers API](https://github.com/dotnet/runtime/pull/32091).\r\n* CoreCLR tests for usage [examples](https://github.com/dotnet/runtime/blob/master/src/coreclr/tests/src/Interop/NativeCallable/NativeCallableTest.cs).\r\n\r\n/cc @jkotas @jaredpar @davidwrighton ",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#1845",
            "CreatedAt": "2020-01-17T02:01:47+00:00",
            "CreatedBy": "AaronRobinsonMSFT",
            "IsClosed": true,
            "Title": "Low level API support for RCW and CCW management",
            "DescriptionMarkdown": "Work has begun to provide support for [WinUI 3.0](https://github.com/microsoft/microsoft-ui-xaml/blob/master/docs/roadmap.md#winui-3). This support is expected to manifest in a way similar to the [CppWinRT](https://github.com/microsoft/cppwinrt) tool by way of a new source generation tool (e.g. CsWinRT). In order to support this new tool, APIs for integrating and coordinating with the runtime object lifetime are necessary.\r\n\r\n# Rationale and Usage\r\n\r\nThe below API surface provides a way for a third party tool to generate what are colloquially known as [Runtime Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/runtime-callable-wrapper) (RCW) and [COM Callable Wrappers](https://docs.microsoft.com/dotnet/standard/native-interop/com-callable-wrapper) (CCW) in a way that allows safe interaction with managed object lifetime and identity.\r\n\r\nA specific example of the need for lifetime coordination is in WinRT scenarios involving UI (e.g.  WinUI 3.0) via the [\u0060IReferenceTrackerManager\u0060](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackermanager) interface.\r\n\r\n## Goals:\r\n* Enable source generation of interop code in WinRT/WinUI scenarios.\r\n* An API that generally aligns with how existing 3rd party source generators work (e.g. [SharpGenTools](https://github.com/SharpGenTools/SharpGenTools)).\r\n* Limit exposing APIs that manage lifetime in a micro way (e.g. avoid GC hooks at dangerous times).\r\n* Semantics in .NET Framework/.NET Core for WinRT scenarios should be able to be replicated.\r\n* Provide a mechanism for 3rd parties to be able to support [Reference Tracker scenarios](https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/).\r\n* Ensure AOT scenarios are considered.\r\n\r\n## Non-Goals:\r\n* Replace the existing built-in RCW/CCW infrastructure.\r\n* Change anything related to P/Invoke Interop.\r\n* Hide WinRT and/or COM concepts.\r\n\r\n## Outstanding questions:\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385491739\r\n * https://github.com/dotnet/runtime/pull/32091#discussion_r385498872\r\n\r\n# Proposed API\r\n\r\n\u0060\u0060\u0060 CSharp\r\nnamespace System.Runtime\r\n{\r\n    public static partial class RuntimeHelpers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Allocate memory that is associated with the \u003Cparamref name=\u0022type\u0022/\u003E and\r\n        /// will be freed if and when the \u003Csee cref=\u0022System.Type\u0022/\u003E is unloaded.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022type\u0022\u003EType associated with the allocated memory.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022size\u0022\u003EAmount of memory in bytes to allocate.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe allocated memory\u003C/returns\u003E\r\n        public static IntPtr AllocateTypeAssociatedMemory(Type type, int size);\r\n    }\r\n}\r\n\r\nnamespace System.Runtime.InteropServices\r\n{\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateComInterfaceFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// The caller will provide an IUnknown Vtable.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This is useful in scenarios when the caller has no need to rely on an IUnknown instance\r\n        /// that is used when running managed code is not possible (i.e. during a GC). In traditional\r\n        /// COM scenarios this is common, but scenarios involving \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EReference Tracker hosting\u003C/see\u003E\r\n        /// calling of the IUnknown API during a GC is possible.\r\n        /// \u003C/remarks\u003E\r\n        CallerDefinedIUnknown = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Flag used to indicate the COM interface should implement \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetrackertarget\u0022\u003EIReferenceTrackerTarget\u003C/see\u003E.\r\n        /// When this flag is passed, the resulting COM interface will have an internal implementation of IUnknown\r\n        /// and as such none should be supplied by the caller.\r\n        /// \u003C/summary\u003E\r\n        TrackerSupport = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Enumeration of flags for \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E.\r\n    /// \u003C/summary\u003E\r\n    [Flags]\r\n    public enum CreateObjectFlags\r\n    {\r\n        None = 0,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Indicate if the supplied external COM object implements the \u003Csee href=\u0022https://docs.microsoft.com/windows/win32/api/windows.ui.xaml.hosting.referencetracker/nn-windows-ui-xaml-hosting-referencetracker-ireferencetracker\u0022\u003EIReferenceTracker\u003C/see\u003E.\r\n        /// \u003C/summary\u003E\r\n        TrackerObject = 1,\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Ignore any internal caching and always create a unique instance.\r\n        /// \u003C/summary\u003E\r\n        UniqueInstance = 2,\r\n    }\r\n\r\n    /// \u003Csummary\u003E\r\n    /// Class for managing wrappers of COM IUnknown types.\r\n    /// \u003C/summary\u003E\r\n    [CLSCompliant(false)]\r\n    public abstract partial class ComWrappers\r\n    {\r\n        /// \u003Csummary\u003E\r\n        /// Interface type and pointer to targeted VTable.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceEntry\r\n        {\r\n            /// \u003Csummary\u003E\r\n            /// Interface IID.\r\n            /// \u003C/summary\u003E\r\n            public Guid IID;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Memory must have the same lifetime as the memory returned from the call to \u003Csee cref=\u0022ComputeVtables(object, CreateComInterfaceFlags, out int)\u0022/\u003E.\r\n            /// \u003C/summary\u003E\r\n            public IntPtr Vtable;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// ABI for function dispatch of a COM interface.\r\n        /// \u003C/summary\u003E\r\n        public struct ComInterfaceDispatch\r\n        {\r\n            public IntPtr vftbl;\r\n\r\n            /// \u003Csummary\u003E\r\n            /// Given a \u003Csee cref=\u0022System.IntPtr\u0022/\u003E from a generated VTable, convert to the target type.\r\n            /// \u003C/summary\u003E\r\n            /// \u003Ctypeparam name=\u0022T\u0022\u003EDesired type.\u003C/typeparam\u003E\r\n            /// \u003Cparam name=\u0022dispatchPtr\u0022\u003EPointer supplied to VTable function entry.\u003C/param\u003E\r\n            /// \u003Creturns\u003EInstance of type associated with dispatched function call.\u003C/returns\u003E\r\n            public static unsafe T GetInstance\u003CT\u003E(ComInterfaceDispatch* dispatchPtr) where T : class;\r\n        }\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create an COM representation of the supplied object that can be passed to an non-managed environment.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022instance\u0022\u003EA GC Handle to the managed object to expose outside the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to configure the generated interface.\u003C/param\u003E\r\n        /// \u003Creturns\u003EThe generated COM interface that can be passed outside the .NET runtime.\u003C/returns\u003E\r\n        public IntPtr GetOrCreateComInterfaceForObject(object instance, CreateComInterfaceFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Compute the desired VTables for \u003Cparamref name=\u0022obj\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022obj\u0022\u003ETarget of the returned VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to compute VTables.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022count\u0022\u003EThe number of elements contained in the returned memory.\u003C/param\u003E\r\n        /// \u003Creturns\u003E\u003Csee cref=\u0022ComInterfaceEntry\u0022 /\u003E pointer containing memory for all COM interface entries.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// All memory returned from this function must either be unmanaged memory, pinned managed memory, or have been\r\n        /// allocated with the \u003Csee cref=\u0022System.Runtime.CompilerServices.RuntimeHelpers.AllocateTypeAssociatedMemory(Type, int)\u0022/\u003E API.\r\n        ///\r\n        /// If the interface entries cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateComInterfaceForObject(object, CreateComInterfaceFlags)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected unsafe abstract ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the currently registered managed object or creates a new managed object and registers it.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022wrapper\u0022\u003EAn optional \u003Csee cref=\u0022object\u0022/\u003E to be used as the wrapper for the external object\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// Providing a \u003Cparamref name=\u0022wrapper\u0022/\u003E instance means \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E\r\n        /// will not be called.\r\n        ///\r\n        /// If the \u003Cparamref name=\u0022wrapper\u0022/\u003E instance already has an associated external object a \u003Csee cref=\u0022System.NotSupportedException\u0022/\u003E will be thrown.\r\n        /// \u003C/remarks\u003E\r\n        public object GetOrCreateObjectForComInstance(IntPtr externalComObject, CreateObjectFlags flags, object? wrapper = null);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Create a managed object for the object pointed at by \u003Cparamref name=\u0022externalComObject\u0022/\u003E respecting the values of \u003Cparamref name=\u0022flags\u0022/\u003E.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022externalComObject\u0022\u003EObject to import for usage into the .NET runtime.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022flags\u0022\u003EFlags used to describe the external object.\u003C/param\u003E\r\n        /// \u003Creturns\u003EReturns a managed object associated with the supplied external COM object.\u003C/returns\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// If the object cannot be created and \u003Ccode\u003Enull\u003C/code\u003E is returned, the call to \u003Csee cref=\u0022ComWrappers.GetOrCreateObjectForComInstance(IntPtr, CreateObjectFlags, object?)\u0022/\u003E will throw a \u003Csee cref=\u0022System.ArgumentNullException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected abstract object? CreateObject(IntPtr externalComObject, CreateObjectFlags flags);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Called when a request is made for a collection of objects to be released.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022objects\u0022\u003ECollection of objects to release.\u003C/param\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// The default implementation of this function throws \u003Csee cref=\u0022System.NotImplementedException\u0022/\u003E.\r\n        /// \u003C/remarks\u003E\r\n        protected virtual void ReleaseObjects(IEnumerable objects);\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Register this class\u0027s implementation to be used as the single global instance.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cremarks\u003E\r\n        /// This function can only be called a single time. Subsequent calls to this function will result\r\n        /// in a \u003Csee cref=\u0022System.InvalidOperationException\u0022/\u003E being thrown.\r\n        ///\r\n        /// Scenarios where the global instance may be used are:\r\n        ///  * Object tracking via the \u003Csee cref=\u0022CreateComInterfaceFlags.TrackerSupport\u0022 /\u003E and \u003Csee cref=\u0022CreateObjectFlags.TrackerObject\u0022 /\u003E flags.\r\n        ///  * Usage of COM related Marshal APIs.\r\n        /// \u003C/remarks\u003E\r\n        public void RegisterAsGlobalInstance();\r\n\r\n        /// \u003Csummary\u003E\r\n        /// Get the runtime provided IUnknown implementation.\r\n        /// \u003C/summary\u003E\r\n        /// \u003Cparam name=\u0022fpQueryInterface\u0022\u003EFunction pointer to QueryInterface.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpAddRef\u0022\u003EFunction pointer to AddRef.\u003C/param\u003E\r\n        /// \u003Cparam name=\u0022fpRelease\u0022\u003EFunction pointer to Release.\u003C/param\u003E\r\n        protected static void GetIUnknownImpl(out IntPtr fpQueryInterface, out IntPtr fpAddRef, out IntPtr fpRelease);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n# Example usage\r\n\r\nThe below example is merely for illustrative purposes. In a production ready consumption of the API many of the \u0060Marshal\u0060 APIs would not be used and the VTable layouts should be done in a static manner for optimal efficiency.\r\n\r\n\u0060\u0060\u0060CSharp\r\n[Guid(\u0022197BC142-7A71-4637-B504-894DE79C4A22\u0022)]\r\ninterface IPrint\r\n{\r\n    public void PrintInt(int i);\r\n}\r\n\r\nclass Print : IPrint\r\n{\r\n    public void PrintInt(int i)\r\n    {\r\n        Console.WriteLine($\u0022{nameof(IPrint.PrintInt)} - 0x{i:x}\u0022);\r\n    }\r\n}\r\n\r\nstruct IUnknownVftbl\r\n{\r\n    public IntPtr QueryInterface;\r\n    public IntPtr AddRef;\r\n    public IntPtr Release;\r\n}\r\n\r\nstruct IPrintVftbl\r\n{\r\n    public IUnknownVftbl IUnknownImpl;\r\n    public IntPtr PrintInt;\r\n\r\n    public delegate int _PrintInt(IntPtr thisPtr, int i);\r\n    public static _PrintInt pPrintInt = new _PrintInt(PrintIntInternal);\r\n\r\n    public static int PrintIntInternal(IntPtr dispatchPtr, int i)\r\n    {\r\n        unsafe\r\n        {\r\n            try\r\n            {\r\n                ComWrappers.ComInterfaceDispatch.GetInstance\u003CIPrint\u003E((ComWrappers.ComInterfaceDispatch*)dispatchPtr).PrintInt(i);\r\n            }\r\n            catch (Exception e)\r\n            {\r\n            return e.HResult;\r\n            }\r\n        }\r\n\r\n        return 0; // S_OK;\r\n    }\r\n}\r\n\r\nstruct VtblPtr\r\n{\r\n    public IntPtr Vtbl;\r\n}\r\n\r\nclass IExternalObject\r\n{\r\n    private struct IExternalObjectVftbl\r\n    {\r\n        public IntPtr QueryInterface;\r\n        public _AddRef AddRef;\r\n        public _Release Release;\r\n        public _AddObjectRef AddObjectRef;\r\n        public _RemoveObjectRef DropObjectRef;\r\n    }\r\n\r\n    private delegate int _AddRef(IntPtr This);\r\n    private delegate int _Release(IntPtr This);\r\n    private delegate int _AddObjectRef(IntPtr This, IntPtr o);\r\n    private delegate int _RemoveObjectRef(IntPtr This, IntPtr o);\r\n\r\n    private readonly IntPtr instance;\r\n    private readonly IExternalObjectVftbl vtable;\r\n\r\n    public IExternalObject(IntPtr instance)\r\n    {\r\n        var inst = Marshal.PtrToStructure\u003CVtblPtr\u003E(instance);\r\n        this.vtable = Marshal.PtrToStructure\u003CIExternalObjectVftbl\u003E(inst.Vtbl);\r\n        this.instance = instance;\r\n    }\r\n\r\n    ~IExternalObject()\r\n    {\r\n        if (this.instance != IntPtr.Zero)\r\n        {\r\n            this.vtable.Release(this.instance);\r\n        }\r\n    }\r\n\r\n    public void AddObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n\r\n    public void DropObjectRef(object inst)\r\n    {\r\n        ...\r\n    }\r\n}\r\n\r\nclass MyComWrappers : ComWrappers\r\n{\r\n    protected unsafe override ComInterfaceEntry* ComputeVtables(object obj, CreateComInterfaceFlags flags, out int count)\r\n    {\r\n        IntPtr fpQueryInteface = default;\r\n        IntPtr fpAddRef = default;\r\n        IntPtr fpRelease = default;\r\n        ComWrappers.GetIUnknownImpl(out fpQueryInteface, out fpAddRef, out fpRelease);\r\n\r\n        var tables = new List\u003CComInterfaceEntry\u003E();\r\n\r\n        var vtbl1 = new IPrintVftbl()\r\n        {\r\n            IUnknownImpl = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            },\r\n            PrintInt = Marshal.GetFunctionPointerForDelegate(IPrintVftbl.pPrintInt)\r\n        };\r\n        var vtblRaw1 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IPrintVftbl), sizeof(IPrintVftbl));\r\n        Marshal.StructureToPtr(vtbl1, vtblRaw1, false);\r\n        tables.Add(new ComInterfaceEntry { IID = IID_IPrint, Vtable = vtblRaw1 });\r\n\r\n        if (flags.HasFlag(CreateComInterfaceFlags.CallerDefinedIUnknown))\r\n        {\r\n            var vtbl2 = new IUnknownVftbl()\r\n            {\r\n                QueryInterface = fpQueryInteface,\r\n                AddRef = fpAddRef,\r\n                Release = fpRelease\r\n            };\r\n            var vtblRaw2 = RuntimeHelpers.AllocateTypeAssociatedMemory(typeof(IUnknownVftbl), sizeof(IUnknownVftbl));\r\n            Marshal.StructureToPtr(vtbl2, vtblRaw2, false);\r\n            tables.Add(new ComInterfaceEntry { IID = IID_IUnknown, Vtable = vtblRaw2 });\r\n        }\r\n\r\n        // Return pointer to memory containing ComInterfaceEntry collection\r\n    }\r\n\r\n    protected override object CreateObject(IntPtr externalComObject, CreateObjectFlags flags)\r\n    {\r\n        return new IExternalObject(externalComObject);\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n/cc @jkotas @Scottj1s @dunhor @jkoritzinsky @davidwrighton @terrajobst @tannergooding @jeffschwMSFT ",
            "Milestone": "5.0.0",
            "Assignees": [
              "AaronRobinsonMSFT"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Interop-coreclr",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-windows",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#37",
            "CreatedAt": "2019-12-19T19:31:34+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "ObjectReference\u003CT\u003E needs to support the Dispose pattern for correct CCW lifetime",
            "DescriptionMarkdown": "To help maintain CCW lifetime across native calls, we should change \u0060WinRT.ObjectReference\u003CT\u003E\u0060 to implement the [Dispose pattern](https://docs.microsoft.com/en-us/dotnet/standard/garbage-collection/implementing-dispose) (and possibly move the release logic up to the base \u0060IObjectReference\u0060 class). This will allow us to use \u0060using()\u0060 blocks around the native calls to keep the \u0060ObjectReference\u003CT\u003E\u0060 to a CCW alive across the native call.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#49",
            "CreatedAt": "2020-01-13T21:20:11+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Provide method for projections to add \u0022default-implemented\u0022 interfaces for CCWs",
            "DescriptionMarkdown": "To match parity with the .NET projections system, CsWinRT needs to provide a way for libraries to provide implementations of native interfaces for the native wrappers of managed objects. For example, CsWinRT needs to supply 2 implementations of \u0060Windows/Microsoft.UI.Xaml.Data.ICustomPropertyProvider\u0060 (one for .NET objects, one for CCWs that wrap RCWs); however, these types don\u0027t exist without running cswinrt to generate a projection.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#61",
            "CreatedAt": "2020-02-06T23:58:44+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Marshalling Arrays of Interfaces to ABI selects the incorrect marshaler",
            "DescriptionMarkdown": "The \u0060set_abi_marshaler\u0060 method incorrectly selects the \u0060MarshalNonBlittable\u003CT\u003E\u0060 marshaler for arrays of interfaces instead of the \u0060MarshalInterface\u003CT\u003E\u0060 marshaler.\r\n\r\nThe native-\u003Emanaged direction selects the correct marshaler.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#76",
            "CreatedAt": "2020-02-14T22:09:21+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Add support for IRestrictedErrorInfo",
            "DescriptionMarkdown": "Our current usage of \u0060Marshal.ThrowExceptionForHR\u0060 doesn\u0027t support \u0060IRestrictedErrorInfo\u0060 correctly. To fully support the WinRT platform, we need to add support for \u0060IRestrictedErrorInfo\u0060, at least to a matching level as CoreCLR.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/CsWinRT#102",
            "CreatedAt": "2020-03-27T18:18:36+00:00",
            "CreatedBy": "jkoritzinsky",
            "IsClosed": true,
            "Title": "Provide ICustomPropertyProvider interface by default.",
            "DescriptionMarkdown": "The .NET runtime projection provides the ICustomPropertyProvider interface on all WinRT CCWs. CsWinRT should also provide this interface for compatibility.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#34173",
        "CreatedAt": "2020-03-26T23:55:44+00:00",
        "CreatedBy": "terrajobst",
        "IsClosed": true,
        "Title": "Work that needs to happen for .NET 5 TFMs",
        "DescriptionMarkdown": "The spec for .NET 5 TFMs can be found [here](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md).\r\n\r\n### Runtime/SDK\r\n\r\n* [x] [Ensure SDK explodes .NET 5 \u0060TargetFramework\u0060 into \u0060TargetFramework*\u0060 and \u0060TargetPlatform*\u0060 properties](https://github.com/dotnet/sdk/issues/11231)\r\n* [x] [Make the build fail when a TFM with an unsupported OS or OS version is being used](https://github.com/dotnet/sdk/issues/11232)\r\n* [x] Update RIDs for Xamarin platforms\r\n* [x] [Add preprocessor symbols for OS](https://github.com/dotnet/sdk/issues/11236)\r\n* [x] [Handle new TFMs in runtimeconfig and host](https://github.com/dotnet/runtime/issues/34033)\r\n* [x] [Produce a warning when a \u0060net5.0\u0060 project references \u0060netcoreapp3.1\u0060 (or earlier) with WPF/WinForms](https://github.com/dotnet/sdk/issues/11241)\r\n* Cut\r\n   - ~~Add shared framework for Xamarin platforms~~\r\n   - ~~Add SDK-style build support for Xamarin~~\r\n\r\n### NuGet\r\n\r\n* [x] [net5 tfm: framework precedence rules](https://github.com/nuget/Home/issues/9436)\r\n* [x] [net5 tfm: produce error when missing TPV](https://github.com/nuget/Home/issues/9441)\r\n* [x] [net5 tfm: \u0022hydrating\u0022 empty TargetPlatformVersions](https://github.com/nuget/Home/issues/9444)\r\n* [x] [net5.0 VS APIs](https://github.com/nuget/Home/issues/9650)\r\n* [x] [With multi targeted projects, NuGet should read the target framework related information from the inner build.](https://github.com/nuget/Home/issues/9756)\r\n* [ ] [NuGet pack should catch incorrect omitting of the dot in version numbers](https://github.com/nuget/Home/issues/9215)\r\n* Cut\r\n    - ~~Make NuGet understand that the existing Xamarin TFMs can be installed into the new \u0060net5.0-xxx\u0060 TFMs~~ (Xamarin is pushed to .NET 6)\r\n    - ~~Fail pack when packing equivalent TFMs like \u0060net5.0-ios\u0060 and \u0060net5.0-ios13.0\u0060~~ (this state is impossible now)\r\n    - ~~Produce a warning when a project consumes a library with a higher \u0060TargetPlatformMinVersion\u0060~~ (handled by analyzer)\r\n    - ~~[net5 tfm: TargetPlatformMinVersion in packed nuspec](https://github.com/nuget/Home/issues/9439)~~ (handled by analyzer)\r\n* Future\r\n    - [ ] [Add a TFM for Unity\u0027s DOTS profile](https://github.com/nuget/Home/issues/9347)\r\n\r\n### MSBuild\r\n\r\n* [x] [Allow TFM/TPM checks in a concise, understandable way](https://github.com/microsoft/msbuild/issues/5171)\r\n\r\n### Project System\r\n\r\n* [x] Pass the correct information to NuGet restore, specifically TFI, TFV, TPI, TPV\r\n\r\n@rainersigwald @dsplaisted @rrelyea @ericstj @ViktorHofer Please help me complete the list of items. Also, we would make sure that each item is linked to a corresponding GitHub issue.",
        "Milestone": "5.0.0",
        "Assignees": [
          "terrajobst"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "blocking-release",
            "BackgroundColor": "b60205"
          },
          {
            "Name": "tracking",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/sdk#11231",
            "CreatedAt": "2020-04-10T20:28:37+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Update Microsoft.NET.Sdk TargetFramework parsing to understand OS name and versions",
            "DescriptionMarkdown": "The parsing in Microsoft.NET.TargetFrameworkInference.targets needs to be updated to parse the \u0060TargetPlatformIdentifier\u0060 and \u0060TargetPlatformVersion\u0060 from the \u0060TargetFramework\u0060.\r\n\r\nThe existing parsing implementation (which uses string manipulation) should be replaced with calls to [new MSBuild Intrinsic functions](https://github.com/microsoft/msbuild/issues/5171) which will call the NuGet parsing APIs.\r\n\r\n[.NET 5 TargetFramework spec](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md)",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11232",
            "CreatedAt": "2020-04-10T20:33:14+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Fail build if an unsupported or unknown operating system is specified in TargetFramework",
            "DescriptionMarkdown": "If the \u0060TargetFramework\u0060 is something like \u0060net5.0-mycustomos\u0060, we should fail the build with an error that we don\u0027t know what \u0060mycustomos\u0060 is.\r\n\r\nSuggested logic:\r\n\r\n- Platform-specific targets (usually in workloads) will set \u0060TargetPlatformSupported\u0060 to true if the \u0060TargetPlatformIdentifier\u0060 is set to something they recognize and support\r\n- Base SDK will generate an error message if \u0060TargetPlatformIdentifier\u0060 is non-empty and \u0060TargetPlatformSupported\u0060 is not true\r\n\r\nIf a workload supports a given target platform, it should be responsible for generating error messages if the target platform version specified is one it doesn\u0027t support (or doesn\u0027t support in combination with the target framework version).",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11236",
            "CreatedAt": "2020-04-10T20:48:25+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Automatically define preprocessor symbols for target platforms",
            "DescriptionMarkdown": "Spec is here: https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md#preprocessor-symbols\r\n\r\nNote that this includes defining preprocessor symbols for the target platform, as well as defining preprocessor symbols for previous versions of .NET and the OS",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#34033",
            "CreatedAt": "2020-03-24T19:10:03+00:00",
            "CreatedBy": "vitek-karas",
            "IsClosed": true,
            "Title": "Usage of new TFMs in runtimeconfig and host",
            "DescriptionMarkdown": "The new set of TFMs as per the [design](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md) is relatively large as the TFM now contains not just the version of .NET but also the target OS and possibly even OS version.\r\n\r\nCurrently the SDK writes the TFM into \u0060.runtimeconfig.json\u0060 into a \u0060tfm\u0060 property. Typical \u0060.runtimeconfig.json\u0060: \r\n\u0060\u0060\u0060JSON\r\n{\r\n  \u0022runtimeOptions\u0022: {\r\n    \u0022tfm\u0022: \u0022netcoreapp3.1\u0022,\r\n    \u0022framework\u0022: {\r\n      \u0022name\u0022: \u0022Microsoft.NETCore.App\u0022,\r\n      \u0022version\u0022: \u00223.1.0\u0022\r\n    }\r\n  }\r\n}\r\n\u0060\u0060\u0060\r\n\r\nThe value comes directly from the \u0060\u003CTargetFramework\u003E\u0060 property in the project file.\r\n\r\nThe value in \u0060.runtimeconfig.json\u0060 is used only in two relatively fringe scenarios in the host:\r\n* When the host probes for shared store paths, the path is in the form of \u0060$DOTNET_SHARED_STORE/|arch|/|tfm|\u0060 where the \u0060|tfm|\u0060 is replaced by the value from the \u0060tfm\u0060 property.\r\n* When the host probes for additional paths (specified as either command line or config options) the path can contain the string \u0060|arch|/|tfm|\u0060 where it\u0027s again replaced with the value of the \u0060tfm\u0060 property.\r\n\r\nThe most common usage of these is the \u0060.runtimeconfig.dev.json\u0060 (auto-generated by SDK during \u0060dotnet build\u0060) which contains path to the user-local shared store:\r\n\u0060\u0060\u0060JSON\r\n{\r\n  \u0022runtimeOptions\u0022: {\r\n    \u0022additionalProbingPaths\u0022: [\r\n      \u0022C:\\\\Users\\\\username\\\\.dotnet\\\\store\\\\|arch|\\\\|tfm|\u0022,\r\n\u0060\u0060\u0060\r\n\r\nand then any usage of the shared store, where the folder structure on disk must match the TFM used in the configuration file.\r\n\r\nIf we keep the behavior as is, it would mean that these shared store paths would now include the full TFMs - like \u0060net5.0-windows10.0\u0060 or similar.\r\n\r\nWithout any changes the shared store may need to have multiple copies of the same file for all of the hierarchical TFMs: \u0060net5\u0060, \u0060net5.0\u0060, \u0060net5.0-windows\u0060 and \u0060net5.0-windows10\u0060 if it would server multiple apps each using slightly different but still fully compatible TFM.\r\n\r\nThe question is if the SDK should write the \u0022Simple\u0022 TFM into the \u0060.runtimeconfig.json\u0060 - in this case probably \u0060net5.0\u0060 or if the host will have to start understanding the hierarchical nature of TFMs and be able to parse them.",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-Host",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/sdk#11241",
            "CreatedAt": "2020-04-10T22:49:58+00:00",
            "CreatedBy": "dsplaisted",
            "IsClosed": true,
            "Title": "Add warnings for WindowsDesktop targeting",
            "DescriptionMarkdown": "In .NET 5.0, you will need to specify the TargetPlatform of Windows in order to use Windows Forms or WPF.  You also won\u0027t need to use Microsoft.NET.Sdk.WindowsDesktop, you can just use Microsoft.NET.Sdk.  We should add appropriate warnings in the following situations:\r\n\r\n- If the WindowsDesktop SDK is used, we may want to let you know that you can use Microsoft.NET.Sdk instead.\r\n- If \u0060UseWindowsForms\u0060 or \u0060UseWPF\u0060 is true and the TargetFramework is \u0060net5.0\u0060 or higher (with no \u0060-windows\u0060), warn or error that the TargetFramework should be \u0060net5.0-windows\u0060 to use Windows Forms or WPF\r\n- If the TargetFramework is \u0060net5.0\u0060 or higher (with no \u0060-windows\u0060), and a transitive dependency brings in one of the Microsoft.NETCore.App.WindowsDesktop shared frameworks, we should do one or more of the following:\r\n  - Warn or error that \u0060-windows\u0060 should be added to the TargetFramework\r\n  - Make things work: make sure the right framework is referenced in the runtimeconfig, and adjust the TargetPlatformIdentifier if necessary.\r\n",
            "Milestone": "5.0.1xx",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9436",
            "CreatedAt": "2020-04-14T21:31:04+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "Net5 TFM: Framework Precedence Rules",
            "DescriptionMarkdown": "net5 has [specific precedence rules](https://github.com/dotnet/designs/blob/master/accepted/2020/net5/net5.md#precedences) that need to be followed. We need to implement them.",
            "Milestone": "Sprint 174 - 2020.07.27",
            "Assignees": [
              "nkolev92"
            ],
            "Labels": [
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:Backlog",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9441",
            "CreatedAt": "2020-04-14T21:50:48+00:00",
            "CreatedBy": "zkat",
            "IsClosed": false,
            "Title": "net5 tfm: produce error when missing TPV",
            "DescriptionMarkdown": "Produce an error when a OS flavored .NET 5 TFM is consumed but the package has no TPV in either folder name of the manifest. Is this supposed to be during restore??",
            "Milestone": "Sprint 178 - 2020.10.19",
            "Assignees": [
              "zkat"
            ],
            "Labels": [
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:Backlog",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9444",
            "CreatedAt": "2020-04-15T00:47:14+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "net5 tfm: \u0022hydrating\u0022 empty TargetPlatformVersions",
            "DescriptionMarkdown": "NuGet itself doesn\u0027t have the information it needs in order to understand what version \u0060net5.0-ios\u0060 and such might mean, but omitting versions is an important part of this feature.\r\n\r\nAfter discussions with the dotnet and msbuild teams, my understanding is that they will \u0022fill in\u0022 the \u0060NuGetFramework\u0060 instances with the actual version using some API call that\u0027s yet to be determined (or, preferably, hand us a new one, so we can keep \u0060NuGetFramework\u0060 immutable).",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Functionality:Restore",
                "BackgroundColor": "4be6f4"
              },
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Partner:MSBuild",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:Backlog",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9650",
            "CreatedAt": "2020-06-05T19:45:21+00:00",
            "CreatedBy": "zkat",
            "IsClosed": true,
            "Title": "net5.0 VS APIs",
            "DescriptionMarkdown": "Because of the addition of a platform component to .NET tfms since 5.0 (https://github.com/NuGet/NuGet.Client/pull/3339), any APIs relying on \u0060FrameworkName\u0060 have become mostly incompatible with net5.0.\r\n\r\nIn particular, the VsFrameworkCompatibility APIs rely on these objects. We need to come up with guidance for customers who can\u0027t use the extensibility framework APIs to work around this.\r\n\r\nWe also need to figure out the impact of this change on folks who might be using this.",
            "Milestone": "Sprint 175 - 2020.08.17",
            "Assignees": [
              "zivkan"
            ],
            "Labels": [
              {
                "Name": "Area:Versioning",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "Functionality:SDK",
                "BackgroundColor": "4be6f4"
              },
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Product:VS.Client",
                "BackgroundColor": "e2a25d"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9756",
            "CreatedAt": "2020-07-06T22:54:17+00:00",
            "CreatedBy": "nkolev92",
            "IsClosed": true,
            "Title": "With multi targeted projects, NuGet should read the target framework related information from the inner build. ",
            "DescriptionMarkdown": "Currently in command line scenarios NuGet reads the target framework information in the outer build. \r\nThat is incorrect because the the contract is that we should depend on on TargetFrameworkIdentifier and the like properties. \r\nWe do that here: https://github.com/NuGet/NuGet.Client/blob/bd482514a87a0085f8eb8603842ee1cb3ca5f277/src/NuGet.Core/NuGet.Build.Tasks/NuGet.targets#L500-L526\r\n\r\nThis task is a blocker for https://github.com/NuGet/Home/issues/5154. \r\n\r\nAn incomplete list of things that need done are:\r\n\r\n* In command line scenarios, read the framework in the inner build (this should allow us to read OS Version for example). \r\n* In VS scenarios, modify the VSSOlutionREstoreService to read the information from the properties back instead of the TargetFrameworks value. \r\n* Reflect all of the changes in the assets file (not sure if we\u0027ll need any). \r\n\r\n- [ ] Commandline restore (nuget.exe, msbuild.exe dotnet.exe).\r\n- [ ] Commandline Static Graph restore.\r\n- [ ] VS restore",
            "Milestone": "Sprint 174 - 2020.07.27",
            "Assignees": [
              "nkolev92",
              "zivkan"
            ],
            "Labels": [
              {
                "Name": "Epic",
                "BackgroundColor": "3E4B9E"
              },
              {
                "Name": "Functionality:Restore",
                "BackgroundColor": "4be6f4"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Type:Bug",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 0,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9215",
            "CreatedAt": "2020-02-24T21:12:37+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": true,
            "Title": "NuGet pack should catch incorrect omitting of the dot in version numbers",
            "DescriptionMarkdown": "For .NET 5, [we\u0027re going](https://github.com/dotnet/designs/pull/92) to reuse the existing \u0060net\u0060 moniker. Due to our new versioning scheme (fixed schedule, major bump every year) we\u0027re only five years away from .NET 10. Developers might accidentally say \u0060net10\u0060 when they really meant \u0060net10.0\u0060. We\u0027re planning to follow in the footsteps of .NET Core where project files will generally use a dot, even when it\u0027s not necessary (e.g. \u0060net5.0\u0060) but of course this won\u0027t prevent humans from dropping the \u0060.0\u0060 either inadvertently or for aesthetics.\r\n\r\nIt was [suggested](https://github.com/dotnet/designs/pull/92#discussion_r383463597) to handle this as part of NuGet pack.\r\n\r\nThere are several ways to deal with that:\r\n\r\n1. Generally warn when a dot is missing\r\n2. Only warn on when the TFM is \u003E= \u0060net5.0\u0060 (regardless of whether there is an OS flavor or not)\r\n\r\nThe (1) is more correct but will cause a lot of noise, especially in .NET Framework projects where the ambiguity is irrelevant as the platform will remain at 4.x forever. So my preference would be something more targeted. Not sure (2) is the best way to address that but it seems to hit the sweet spot.",
            "Milestone": "Sprint 177 - 2020.09.28",
            "Assignees": [
              "zkat"
            ],
            "Labels": [
              {
                "Name": "Area:NewFrameworks",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "Pipeline:In Progress",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "nuget/Home#9347",
            "CreatedAt": "2020-03-26T12:07:11+00:00",
            "CreatedBy": "joshpeterson",
            "IsClosed": false,
            "Title": "Add a TFM for Unity\u0027s DOTS profile",
            "DescriptionMarkdown": "At Unity, we would like to explore the possibility of having a new target framework moniker for a very small base class library profile that Unity will use for some of its products.\r\n\r\nThis profile will focus on a few principles:\r\n* Small code size\r\n* No support for reflection\r\n* Focus on value types\r\n* Limited GC allocations\r\n* Limited use of exceptions\r\n* Limited use of virtual methods\r\n\r\nWe would like to make this profile available on NuGet so that it can be used in .csproj files to allow good IDE integration and to allow developers to write libraries using it.\r\n\r\nThis profile will be a proper subset for .NET Standard 2.0, and later a proper subset of .NET 5.\r\n\r\nInitially, I\u0027ll propose the name \u0022unity2.0-dots\u0022, to indicate that it is a proper subset of .NET Standard 2.0.\r\n\r\nLet\u0027s discuss whether or not this is a good idea, and if it something that can be implemented.\r\n\r\n",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "Area:NewFrameworks",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "Partner:DotNet",
                "BackgroundColor": "0e8a16"
              },
              {
                "Name": "Pipeline:In Progress",
                "BackgroundColor": "8a42c9"
              },
              {
                "Name": "Priority:2",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "Resolution:BlockedByExternal",
                "BackgroundColor": "006b75"
              },
              {
                "Name": "Type:DCR",
                "BackgroundColor": "1f6be5"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "microsoft/msbuild#5171",
            "CreatedAt": "2020-03-10T19:31:12+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": true,
            "Title": "Allow TFM/TPM checks in a concise, understandable way",
            "DescriptionMarkdown": "As part of the spec for the [.NET 5 TFM work](https://github.com/dotnet/designs/pull/92) we identified an issue with TFM checks in conditions.\r\n\r\n\u003Cdetails\u003E\r\n\u003Csummary\u003E\r\nBackground on MSBuild evaluation\r\n\u003C/summary\u003E\r\n\r\nIn SDK-style projects there are two kinds of MSBuild files that are automatically included into each project:\r\n\r\n* \u0060*.props\u0060: These files are included at the top of the user\u0027s project file and are used to define a set of default properties that the user\u0027s project file can use.\r\n\r\n* \u0060*.targets\u0060. These files are included at the bottom of the user\u0027s project file, usually meant to define build targets and additional properties/items that need to depend on properties defined by the user.\r\n\r\nFurthermore, MSBuild has a multi-pass evaluation model where properties are evaluated before items.\r\n\r\nWhy is all of this important? Because it controls which properties the user can rely on in their project file.\r\n\r\nOften, a user wants to express a condition like \u0022include this file if you\u0027re compiling for .NET 5 or higher\u0022. Logically one would like to express it like this:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CItemGroup Condition=\u0022\u0027$(TargetFramework)\u0027 \u003E= \u0027net5.0\u0027\u0060\u0022\u003E\r\n\u0060\u0060\u0060\r\n\r\nbut this doesn\u0027t work because that would be a string comparison, not a version comparison. Instead, the user has to write it like this:\r\n\r\n\u0060\u0060\u0060xml\r\n\u003CItemGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027 AND \u0027$(TargetFrameworkVersion)\u0027 \u003E= \u00273.0\u0027\u0022\u003E\r\n\u0060\u0060\u0060\r\n\r\nThis works for conditions on item groups because they are evaluated after properties. Since the user\u0027s project file defines the \u0060TargetFramework\u0060 property, the SDK logic that expands it into the other properties such as \u0060TargetFrameworkIdentifier\u0060 and \u0060TargetFrameworkVersion\u0060 has to live in \u0060*.targets\u0060, i.e. at the bottom of the project file. That means these automatically expanded properties aren\u0027t available for the user when defining other properties. This happens to work for items because items are evaluated after all properties are evaluated.\r\n\u003C/details\u003E\r\n\r\nDue to MSBuild evaluation order the user cannot define properties like this:\r\n\r\n\u0060\u0060\u0060XML\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFrameworks\u003Enetstandard2.0;netcoreapp3.1\u003C/TargetFramework\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETStandard\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome .NET Standard specific value\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0027$(TargetFrameworkIdentifier)\u0027 == \u0027.NETCoreApp\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome .NET Core specific value\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\nIn the past, we\u0027ve seen people working this around by using string processing functions against the \u0060TargetFramework\u0060 property, which is less than ideal.\r\n\r\n### Option using attributes\r\n\r\nIdeally, we\u0027d expose functionality such that the user can do version checks:\r\n\r\n\u0060\u0060\u0060XML\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFrameworks\u003Enetstandard2.0;netcoreapp3.1\u003C/TargetFramework\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetFramework=\u0022netstandard\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all versions of .NET Standard\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetFramework=\u0022\u003E=netcoreapp2.0\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to .NET Core 2.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetFramework=\u0022==net5.0-ios13.0\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that only applies to .NET 5 \u002B iOS 13.0\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetPlatform=\u0022windows\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all version of Windows\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup TargetPlatform=\u0022\u003E=ios-12.0\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to iOS 12.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\nThe idea is:\r\n\r\n* Property groups, properties, and item groups get new attributes \u0060TargetFramework\u0060 and \u0060TargetPlatform\u0060.\r\n* The value can be prefixed with an optional conditional operator \u0060==\u0060, \u0060!=\u0060, \u0060\u003C\u0060, \u0060\u003C=\u0060, \u0060\u003E\u0060, and \u0060\u003E=\u0060. If the operator is omitted, \u0060==\u0060 is assumed.\r\n* \u0060TargetFramework\u0060 supports comparisons with a friendly TFM name. This can include an OS flavor for symmetry. If the \u0060TargetFramework\u0060 property includes an OS flavor but the attribute doesn\u0027t, the comparison only applies to the TFM without the OS flavor. In other words a condition of \u0060TargetFramework=\u0022\u003E=net5.0\u0022\u0060 will result in \u0060true\u0060 if the project targets \u0060net5.0\u0060, \u0060net6.0\u0060, as well as \u0060net6.0-android12.0\u0060.\r\n\r\n### Option via new syntax\r\n\r\nWe could also invent new syntax that allows parsing of constitutes like this:\r\n\r\n\u0060\u0060\u0060XML\r\n\u003CProject Sdk=\u0022Microsoft.NET.Sdk\u0022\u003E\r\n\r\n  \u003CPropertyGroup\u003E\r\n    \u003CTargetFrameworks\u003Enetstandard2.0;netcoreapp3.1\u003C/TargetFramework\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Identifier)==\u0027netstandard\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all versions of .NET Standard\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Name)\u003E=\u0027netcoreapp2.0\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to .NET Core 2.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Name)==\u0027net5.0-ios13.0\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that only applies to .NET 5 \u002B iOS 13.0\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Platform)==\u0027windows\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all version of Windows\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022$(TargetFramework::Platform)\u003E=\u0027ios-12.0\u0027\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to iOS 12.0 and later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n\u003C/Project\u003E\r\n\u0060\u0060\u0060\r\n\r\n### Option via functions\r\n\r\nWe could also just define new intrinsic functions on some type, but this will make using them a mouthful:\r\n\r\n\u0060\u0060\u0060XML\r\n  \u003CPropertyGroup Condition=\u0022\u0060\u0027$([MSBuild]::TargetFrameworkIdentifier($(TargetFramework)))\u0027 == \u0027.NETStandard\u0027\u0060\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to all versions of .NET Standard\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0060\u0027$([MSBuild]::IsTargetFrameworkOrLater($(TargetFramework)))\u0027, \u0027net5.0\u0027))\u0060\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to .NET 5 or later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\r\n  \u003CPropertyGroup Condition=\u0022\u0060\u0027$([MSBuild]::IsTargetPlatformOrLater($(TargetFramework)))\u0027, \u0027ios12.0\u0027))\u0060\u0022\u003E\r\n    \u003CSomeProperty\u003ESome value that applies to iOS 12 or later\u003CSomeProperty\u003E\r\n  \u003C/PropertyGroup\u003E\r\n\u0060\u0060\u0060\r\n\r\nI am not married to any of these ideas; I\u0027m just spitballing here. Thoughts?",
            "Milestone": ".NET 5",
            "Assignees": [
              "sfoslund"
            ],
            "Labels": [
              {
                "Name": ".NET Core",
                "BackgroundColor": "512BD4"
              },
              {
                "Name": "Area: Language",
                "BackgroundColor": "5319e7"
              },
              {
                "Name": "Needs Design",
                "BackgroundColor": "006b75"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#33557",
        "CreatedAt": "2020-03-13T15:31:16+00:00",
        "CreatedBy": "lambdageek",
        "IsClosed": false,
        "Title": "[mono] Audit embedding API for .NET 5 correctness",
        "DescriptionMarkdown": "This is a tracking issue to audit the public embedding API for correctness with respect to assembly load context support.\r\n\r\nThe goal is to consider how each function in the headers below will behave when there are multiple ALCs in the managed code, and to decide whether the function behavior needs to be corrected, or if it is not feasible to correct, whether the function\u0027s documentation should be updated with a deprecation note and a new ALC-aware replacement added.\r\n\r\nThe top priority are functions that are mentioned in [xamarin-macios exports.t4](https://github.com/xamarin/xamarin-macios/blob/master/runtime/exports.t4) or headers that are used in the source code in the [xamarin android monodroid/jni directory](https://github.com/xamarin/xamarin-android/tree/master/src/monodroid/jni), and [Java.Interop](https://github.com/xamarin/java.interop/blob/master/src/java-interop/)\r\n\r\n- \u0060mono/utils\u0060\r\n   - [ ] mono-logger.h\r\n   - [ ] mono-error.h\r\n   - [ ] mono-forward.h\r\n   - [ ] mono-publib.h\r\n   - [ ] mono-jemalloc.h\r\n   - [ ] mono-dl-fallback.h\r\n   - [ ] mono-counters.h\r\n- \u0060mono/metadata\u0060\r\n   - [ ] appdomain.h\r\n   - [ ] assembly.h\r\n   - [ ] attrdefs.h\r\n   - [ ] blob.h\r\n   - [ ] class.h\r\n   - [ ] debug-helpers.h\r\n   - [ ] debug-mono-symfile.h\r\n   - [ ] environment.h\r\n   - [ ] exception.h\r\n   - [ ] image.h\r\n   - [ ] loader.h\r\n   - [ ] metadata.h\r\n   - [ ] mono-config.h\r\n   - [ ] mono-debug.h\r\n   - [ ] mono-gc.h\r\n   - [ ] object.h\r\n   - [ ] object-forward.h\r\n   - [ ] opcodes.h\r\n   - [ ] profiler.h\r\n   - [ ] profiler-events.h\r\n   - [ ] reflection.h\r\n   - [ ] row-indexes.h\r\n   - [ ] sgen-bridge.h\r\n   - [ ] threads.h\r\n   - [ ] tokentype.h\r\n   - [ ] verify.h\r\n- \u0060mono/mini\u0060\r\n   - [ ] jit.h\r\n\r\nThe following headers aren\u0027t installed, but they have \u0060MONO_API\u0060 functions, and should be audited too:\r\n\r\nMini\r\n- [ ] \u0060mono/utils/mini-runtime.h\u0060\r\n- [ ] \u0060mono/utils/monovm.h\u0060\r\n- [ ] \u0060mono/utils/mini.h\u0060\r\n- [ ] \u0060mono/utils/mini-llvm.h\u0060\r\n- [ ] \u0060mono/utils/aot-runtime.h\u0060\r\n- [ ] \u0060mono/utils/debugger-agent.h\u0060\r\n\r\nMetadata:\r\n- [ ] \u0060mono/metadata/cil-coff.h\u0060\r\n- [ ] \u0060mono/metadata/marshal-ilgen.h\u0060\r\n- [ ] \u0060mono/metadata/marshal.h\u0060\r\n- [ ] \u0060mono/metadata/coree.h\u0060\r\n- [ ] \u0060mono/metadata/assembly-internals.h\u0060\r\n- [ ] \u0060mono/metadata/sgen-toggleref.h\u0060\r\n- [ ] \u0060mono/metadata/class-internals.h\u0060\r\n- [ ] \u0060mono/metadata/w32file.h\u0060\r\n- [ ] \u0060mono/metadata/security-core-clr.h\u0060\r\n- [ ] \u0060mono/metadata/metadata-internals.h\u0060\r\n- [ ] \u0060mono/metadata/monitor.h\u0060\r\n- [ ] \u0060mono/metadata/object-internals.h\u0060\r\n- [ ] \u0060mono/metadata/mono-mlist.h\u0060\r\n- [ ] \u0060mono/metadata/method-builder-ilgen.h\u0060\r\n- [ ] \u0060mono/metadata/filewatcher.h\u0060\r\n- [ ] \u0060mono/metadata/threads-types.h\u0060\r\n- [ ] \u0060mono/metadata/cominterop.h\u0060\r\n- [ ] \u0060mono/metadata/mempool.h\u0060\r\n- [ ] \u0060mono/metadata/mono-perfcounters.h\u0060\r\n- [ ] \u0060mono/metadata/icall-table.h\u0060\r\n- [ ] \u0060mono/metadata/mono-hash.h\u0060\r\n- [ ] \u0060mono/metadata/gc-internals.h\u0060\r\n\r\nUtils\r\n- [ ] \u0060mono/utils/mono-path.h\u0060\r\n- [ ] \u0060mono/utils/mono-linked-list-set.h\u0060\r\n- [ ] \u0060mono/utils/mono-proclib.h\u0060\r\n- [ ] \u0060mono/utils/mono-logger-internals.h\u0060\r\n- [ ] \u0060mono/utils/strenc.h\u0060\r\n- [ ] \u0060mono/utils/hazard-pointer.h\u0060\r\n- [ ] \u0060mono/utils/mono-threads-api.h\u0060\r\n- [ ] \u0060mono/utils/mono-dl-fallback.h\u0060\r\n- [ ] \u0060mono/utils/mono-embed.h\u0060\r\n- [ ] \u0060mono/utils/mono-error-internals.h\u0060\r\n- [ ] \u0060mono/utils/mono-digest.h\u0060\r\n- [ ] \u0060mono/utils/os-event.h\u0060\r\n- [ ] \u0060mono/utils/mono-threads.h\u0060\r\n- [ ] \u0060mono/utils/monobitset.h\u0060\r\n- [ ] \u0060mono/utils/mono-uri.h\u0060\r\n- [ ] \u0060mono/utils/mono-mmap.h\u0060\r\n- [ ] \u0060mono/utils/lock-free-alloc.h\u0060\r\n- [ ] \u0060mono/utils/mono-conc-hashtable.h\u0060\r\n- [ ] \u0060mono/utils/lock-free-queue.h\u0060\r\n- [ ] \u0060mono/utils/mono-logger.h\u0060\r\n- [ ] \u0060mono/utils/mono-poll.h\u0060\r\n\r\n\r\n",
        "Milestone": "6.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-VM-meta-mono",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "runtime-mono",
            "BackgroundColor": "005e5e"
          },
          {
            "Name": "tracking",
            "BackgroundColor": "b60205"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#33308",
        "CreatedAt": "2020-03-06T22:28:08+00:00",
        "CreatedBy": "BruceForstall",
        "IsClosed": true,
        "Title": "Optimize library code using arm64 intrinsics",
        "DescriptionMarkdown": "The following classes/functions in the libraries have Intel x86/x64 intrinsics usage. These are where \u0060_ISA_.IsSupported()\u0060 is called. This information was collected manually and might not be complete. Some of these function names represent many overloads. There are some vectorized helper methods not shown here -- where a function calls \u0060IsSupported\u0060 and then calls a specific helper function to do the actual work, such as for SSE2 or AVX2 specifically. There are other cases where \u0060Vector\u003CT\u003E\u0060 is used, but arm64 already supports that (it should be verified that the arm64 \u0060Vector\u003CT\u003E\u0060 code is complete and performant).\r\n\r\nWhen each of these has added an arm64-specific intrinsics optimization, it should be \u0022checked off\u0022.\r\n\r\nThe sections below are ordered in the presumed priority order that they should be implemented in. (There is no assumed priority order for the individual functions in each section.)\r\n\r\nIt is expected that \u0060System.Collections.BitArray\u0060, \u0060System.Numerics\u0060, and \u0060System.SpanHelpers\u0060 will be \u0022arm64 intrinsi-fied\u0022 for .NET 5. If possible, \u0060System.Buffers\u0060 and \u0060System.Text\u0060 will as well, but that is not considered required.\r\n\r\n# System.Collections.BitArray https://github.com/dotnet/runtime/issues/33309\r\n\r\n- [x] System.Collections.BitArray - constructor\r\n- [x] System.Collections.BitArray.And()\r\n- [x] System.Collections.BitArray.Or()\r\n- [x] System.Collections.BitArray.Xor()\r\n- [x] System.Collections.BitArray.Not()\r\n- [x] System.Collections.BitArray.CopyTo()\r\n\r\n# System.Runtime.Intrinsics https://github.com/dotnet/runtime/issues/33496\r\n\r\n## Vector64\r\n- [x] As\u003CT, U\u003E()\r\n- [x] AsInt64\u003CT\u003E()\r\n- [x] AsUInt64\u003CT\u003E()\r\n- [x] AsDouble\u003CT\u003E()\r\n- [x] CreateScalarUnsafe(int value);\r\n- [x] CreateScalarUnsafe(uint value);\r\n- [x] CreateScalarUnsafe(float value);\r\n- [x] CreateScalarUnsafe(byte value);\r\n- [x] CreateScalarUnsafe(sbyte value);\r\n- [x] CreateScalarUnsafe(short value);\r\n- [x] CreateScalarUnsafe(ushort value);\r\n- [x] CreateScalar(uint)\r\n- [x] CreateScalar(float)\r\n- [x] CreateScalar(sbyte)\r\n- [x] CreateScalar(ushort)\r\n- [x] CreateScalar(short)\r\n- [x] CreateScalar(byte)\r\n- [x] CreateScalar(int)\r\n- [x] Create(sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte)\r\n- [x] Create(byte, byte, byte, byte, byte, byte, byte, byte)\r\n- [x] Create(ushort, ushort, ushort, ushort)\r\n- [x] Create(short, short, short, short)\r\n- [x] Create(float, float)\r\n- [x] Create(int, int)\r\n- [x] Create(ulong)\r\n- [x] Create(uint)\r\n- [x] Create(uint, uint)\r\n- [x] Create(float)\r\n- [x] Create(sbyte)\r\n- [x] Create(long)\r\n- [x] Create(int)\r\n- [x] Create(short)\r\n- [x] Create(double)\r\n- [x] Create(byte)\r\n- [x] Create(ushort)\r\n- [x] GetElement(int index)\r\n- [x] ToScalar()\r\n- [x] ToVector128\u003CT\u003E()\r\n- [x] ToVector128Unsafe\u003CT\u003E()\r\n- [x] WithElement\u003CT\u003E(Vector64\u003CT\u003E, int, T)\r\n\r\n## Vector128\r\n- [x] As\u003CT, U\u003E()\r\n- [x] AsVector\u003CT\u003E()\r\n- [x] AsVector4(Vector128\u003Cfloat\u003E)\r\n- [x] AsVector128(Vector\u003CT\u003E)\r\n- [x] AsVector128(Vector4)\r\n- [x] CreateScalarUnsafe(int value);\r\n- [x] CreateScalarUnsafe(uint value);\r\n- [x] CreateScalarUnsafe(float value);\r\n- [x] CreateScalarUnsafe(long value);\r\n- [x] CreateScalarUnsafe(ulong value);\r\n- [x] CreateScalarUnsafe(double value);\r\n- [x] CreateScalarUnsafe(byte value);\r\n- [x] CreateScalarUnsafe(sbyte value);\r\n- [x] CreateScalarUnsafe(short value);\r\n- [x] CreateScalarUnsafe(ushort value);\r\n- [x] CreateScalar(ulong)\r\n- [x] CreateScalar(uint)\r\n- [x] CreateScalar(ushort)\r\n- [x] CreateScalar(sbyte)\r\n- [x] CreateScalar(float)\r\n- [x] CreateScalar(int)\r\n- [x] CreateScalar(short)\r\n- [x] CreateScalar(double)\r\n- [x] CreateScalar(byte)\r\n- [x] CreateScalar(long)\r\n- [x] Create(sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte, sbyte)\r\n- [x] Create(byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte, byte)\r\n- [x] Create(ushort, ushort, ushort, ushort, ushort, ushort, ushort, ushort)\r\n- [x] Create(short, short, short, short, short, short, short, short)\r\n- [x] Create(uint, uint, uint, uint)\r\n- [x] Create(float, float, float, float)\r\n- [x] Create(int, int, int, int)\r\n- [x] Create(ulong, ulong)\r\n- [x] Create(Vector64\u003Culong\u003E, Vector64\u003Culong\u003E)\r\n- [x] Create(Vector64\u003Cuint\u003E, Vector64\u003Cuint\u003E)\r\n- [x] Create(Vector64\u003Cfloat\u003E, Vector64\u003Cfloat\u003E)\r\n- [x] Create(Vector64\u003Csbyte\u003E, Vector64\u003Csbyte\u003E)\r\n- [x] Create(Vector64\u003Clong\u003E, Vector64\u003Clong\u003E)\r\n- [x] Create(Vector64\u003Cint\u003E, Vector64\u003Cint\u003E)\r\n- [x] Create(Vector64\u003Cushort\u003E, Vector64\u003Cushort\u003E)\r\n- [x] Create(Vector64\u003Cdouble\u003E, Vector64\u003Cdouble\u003E)\r\n- [x] Create(byte)\r\n- [x] Create(double)\r\n- [x] Create(short)\r\n- [x] Create(int)\r\n- [x] Create(long)\r\n- [x] Create(Vector64\u003Cshort\u003E, Vector64\u003Cshort\u003E)\r\n- [x] Create(float)\r\n- [x] Create(sbyte)\r\n- [x] Create(uint)\r\n- [x] Create(ulong)\r\n- [x] Create(double, double)\r\n- [x] Create(long, long)\r\n- [x] Create(Vector64\u003Cbyte\u003E, Vector64\u003Cbyte\u003E)\r\n- [x] Create(ushort)\r\n- [x] GetElement(int index)\r\n- [x] GetLower\u003CT\u003E()\r\n- [x] GetUpper\u003CT\u003E()\r\n- [x] WithElement\u003CT\u003E(Vector128\u003CT\u003E, int, T)\r\n- [x] WithLower\u003CT\u003E(Vector64\u003CT\u003E)\r\n- [x] WithUpper\u003CT\u003E(Vector64\u003CT\u003E)\r\n- [x] ToScalar()\r\n\r\n## Vector256\r\n- [x] Software fallback\r\n\r\n# System.Numerics\r\n\r\n## System.Numerics.BitOperations https://github.com/dotnet/runtime/issues/33495\r\n\r\n- [x] System.Numerics.BitOperations.LeadingZeroCount()\r\n- [x] System.Numerics.BitOperations.Log2()\r\n- [x] System.Numerics.BitOperations.PopCount()\r\n- [x] System.Numerics.BitOperations.TrailingZeroCount()\r\n\r\n## System.Numerics.Matrix4x4 #33565\r\n\r\n- [x] System.Numerics.Matrix4x4.Transpose()\r\n- [x] System.Numerics.Matrix4x4.Lerp()\r\n- [x] System.Numerics.Matrix4x4.operator-()\r\n- [x] System.Numerics.Matrix4x4.operator\u002B()\r\n- [x] System.Numerics.Matrix4x4.operator*()\r\n- [x] System.Numerics.Matrix4x4.operator==()\r\n- [x] System.Numerics.Matrix4x4.operator!=()\r\n\r\n# System.SpanHelpers #33707\r\n \r\n- [x] System.SpanHelpers.IndexOf(byte)\r\n- [x] System.SpanHelpers.IndexOf(char)\r\n- [x] System.SpanHelpers.IndexOfAny(byte)\r\n~[ ] System.SpanHelpers.SequenceCompareTo(byte)~  (SIMD vector implementation is fast enough)\r\n~[ ] System.SpanHelpers.SequenceEqual(byte)~ (SIMD vector implementation is fast enough)\r\n~[ ] System.SpanHelpers.LocateFirstFoundByte()~ (Only used by SIMD version of \u0060IndexOf\u0060 and \u0060IndexOfAny\u0060 which are already optimized by ARM64 intrinsics)\r\n\r\n# System.Buffers #35033\r\n*(Not completed in 5.0.0; moved to 6.0.0)*\r\n\r\n- [ ] System.Buffers.Text.Base64.DecodeFromUtf8()\r\n- [ ] System.Buffers.Text.Base64.EncodeToUtf8()\r\n\r\n# System.Text\r\n\r\n## System.Text.ASCIIUtility #35034\r\n \r\n- [x] System.Text.ASCIIUtility.GetIndexOfFirstNonAsciiByte()\r\n- [ ] System.Text.ASCIIUtility.GetIndexOfFirstNonAsciiChar() - *(Not completed in 5.0.0; moved to 6.0.0)* - PR #39507 \r\n- [x] System.Text.ASCIIUtility.NarrowFourUtf16CharsToAsciiAndWriteToBuffer()\r\n- [ ] System.Text.ASCIIUtility.NarrowUtf16ToAscii() - *(Not completed in 5.0.0; moved to 6.0.0)* - PR #39509\r\n- [x] System.Text.ASCIIUtility.WidenAsciiToUtf16()\r\n- [x] System.Text.ASCIIUtility.WidenFourAsciiBytesToUtf16AndWriteToBuffer()\r\n- [x] System.Text.ASCIIUtility.CountNumberOfLeadingAsciiBytesFromUInt32WithSomeNonAsciiData()\r\n\r\n## System.Text.Unicode #35035\r\n\r\n- [x] System.Text.Unicode.Utf16Utility.GetPointerToFirstInvalidChar()\r\n- [x] System.Text.Unicode.Utf8Utility.TranscodeToUtf8()\r\n- [x] System.Text.Unicode.Utf8Utility.GetPointerToFirstInvalidByte()\r\n\r\n## System.Text.Encodings.Web #35036\r\n\r\n- [x] System.Text.Encodings.Web.DefaultJavaScriptEncoder.FindFirstCharacterToEncodeUtf8()\r\n- [x] System.Text.Encodings.Web.DefaultJavaScriptEncoderBasicLatin.FindFirstCharacterToEncode()\r\n- [x] System.Text.Encodings.Web.DefaultJavaScriptEncoderBasicLatin.FindFirstCharacterToEncodeUtf8()\r\n- [x] System.Text.Encodings.Web.TextEncoder.FindFirstCharacterToEncodeUtf8()\r\n- [x] System.Text.Encodings.Web.UnsafeRelaxedJavaScriptEncoder.WillEncode()\r\n- [x] System.Text.Encodings.Web.UnsafeRelaxedJavaScriptEncoder.FindFirstCharacterToEncodeUtf8()\r\n",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "arch-arm64",
            "BackgroundColor": "eb6420"
          },
          {
            "Name": "area-Meta",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "up-for-grabs",
            "BackgroundColor": "23ef90"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#39507",
            "CreatedAt": "2020-07-17T08:15:30+00:00",
            "CreatedBy": "pgovind",
            "IsClosed": false,
            "Title": "Get index of first non ascii char",
            "DescriptionMarkdown": "I think this is ready and can be reviewed now. \r\n\r\nImplements GetIndexOfFirstNonAsciiChar from #35034\r\n\r\nUpdated Perf:\r\n\u0060\u0060\u0060\r\n| Faster                                                                 | base/diff | Base Median (ns) | Diff Median (ns) | Modality|\r\n| ---------------------------------------------------------------------- | ---------:| ----------------:| ----------------:| -------- |\r\n| System.Text.Experimental.Perf.IsNormalized_GetIndexOfFirstNonAsciiChar |      1.40 |        111784.29 |         79682.34 |         |\r\n\u0060\u0060\u0060",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Runtime.Intrinsics",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#39509",
            "CreatedAt": "2020-07-17T08:22:31+00:00",
            "CreatedBy": "pgovind",
            "IsClosed": false,
            "Title": "Narrow utf16 to ascii",
            "DescriptionMarkdown": "This is ready for review now. \r\n\r\nNOTE: There is a bug here somewhere, but I can\u0027t seem to find it, so I\u0027d appreciate another pair of eyes in this code. When I try to test this on WSL2, I get an error saying \u0022Can\u0027t find file xunit.console.deps.json\u0022 when that file does in fact exist. The real error is that the xunit infra itself calls into the method being modified here and **something** goes wrong (maybe marshalling the path from \u0060string\u0060 to native also uses this code? I\u0027m not sure). AFAICT the changes are right.",
            "Milestone": null,
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Runtime.Intrinsics",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#32969",
        "CreatedAt": "2020-02-28T19:13:16+00:00",
        "CreatedBy": "AndyAyersMS",
        "IsClosed": true,
        "Title": "Implement simple version of On Stack Replacement (OSR)",
        "DescriptionMarkdown": "Add support to runtime and jit to allow switching from unoptimized to\r\noptimized code for a method while the method has active stack frames.\r\n\r\nDetails in the included document.",
        "Milestone": null,
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-CodeGen-coreclr",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#31895",
        "CreatedAt": "2020-02-06T23:56:21+00:00",
        "CreatedBy": "steveharter",
        "IsClosed": true,
        "Title": "System.Reflection and S.R.Emit roadmap for 5.0 [WIP]",
        "DescriptionMarkdown": "_[Work in Progress]_\r\n\r\nTo help with priority discussions, this issue is tracking design and functional issues.\r\n\r\nIn general, the issues fall into the following buckets:\r\n- Design \\ roadmap\r\n- Features (large API additions to smaller functional features)\r\n- Performance improvements\r\n- Bugs (crashes, inconsistencies, ...)\r\n\r\n# Areas of focus\r\n1) Determine Reflection.Emit roadmap and usage scenarios.\r\n2) Unblock .NET Framework migration scenarios.\r\n3) Support other higher-level 5.0 initiatives (impact here TBD).\r\n4) Improve quality by fixing bugs and increasing performance as necessary.\r\n\r\n# Current Issues\r\n### 5.0 Open Issues\r\nCurrently there are ~43 open issues for 5.0\r\n[System.Reflection 5.0](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection\u002Bmilestone%3A5.0)\r\n[System.Reflection.Emit 5.0](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection.Emit\u002Bmilestone%3A5.0)\r\n\r\n### Future Open Issues \r\nCurrently there are ~36 issues (a first pass was made for 5.0 inclusion; a second pass is planned):\r\n[System.Reflection future](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection\u002Bmilestone%3AFuture)\r\n[System.Reflection.Emit future](https://github.com/dotnet/runtime/issues?q=is%3Aissue\u002Bis%3Aopen\u002Blabel%3Aarea-System.Reflection.Emit\u002Bmilestone%3AFuture)\r\n\r\n# Planned work\r\nFor workload reasons, the following are non-trivial issues that currently are being scheduled or discussed for 5.0:\r\n\r\n## P1 roadmap and usage scenarios.\r\n- [ ] Determine Reflection.Emit roadmap. Reflection.Emit is not supported on key platforms. How can we support common scenarios that will unblock key scenarios? For example, the JSON Serializer uses emit to generate code that quickly sets\\gets properties -- can we add a mechanism that doesn\u0027t require ref emit for this, which would allow the Serializer to be used on more platforms in a performant way?\r\n\r\nNote these are related and may or may not be addressed pending discussion:\r\n- [Proposal: Add new GetValue method to System.Reflection #19484](https://github.com/dotnet/runtime/issues/19484)\r\n- [Proposal for high-performance codegen-less Reflection factory APIs #23716](https://github.com/dotnet/runtime/issues/23716)\r\n- [Faster MethodInfo.Invoke #7560](https://github.com/dotnet/runtime/issues/7560)\r\n- todo: proposal for fast property\\field getter\\setter without using ref.emit?\r\n\r\n## P1 features\r\n- [ ] (medium) [MetadataLoadContext to support dynamic assemblies #27803](https://github.com/dotnet/runtime/issues/27803)\r\n- [x] (small) [Unable to read ReturnTypeCustomAttributes when using System.Reflection.MetadataLoadContext #30959](https://github.com/dotnet/runtime/issues/30959)\r\n\r\n## P1 performance\r\n- [x] (medium) [System.Reflection.MetadataLoadContext performance #30886](https://github.com/dotnet/runtime/issues/30886)\r\n\r\n## P1 bugs\r\n- [x] (medium) [Test Failed: System.AccessViolationException #13298](https://github.com/dotnet/runtime/issues/13298)\r\n- [x] (small) [Add .Net Framework TFM to System.Reflection.MetadataLoadContext #30810](https://github.com/dotnet/runtime/issues/30810)\r\n- [x] (?) [The dynamic type created is thrown Fileloadexception when using the GetCustomAttributes method #26912](https://github.com/dotnet/runtime/issues/26912)\r\n- [x] (small-medium) [System.Reflection.DispatchProxy inconsistently fails for internal interfaces #30917](https://github.com/dotnet/runtime/issues/30917)\r\n- [ ] (small) [Port CoreRT fix to System.Reflection.MetadataLoadContext #28046](https://github.com/dotnet/runtime/issues/28046)\r\n\r\n\r\n## P2 features\r\n- [ ] (very large; under discussion) [System.Reflection.Emit.AssemblyBuilder.Save #15704](https://github.com/dotnet/runtime/issues/15704)\r\n- [ ] (large?) [WIP API Proposal - AssemblyBuilder.DefineDynamicAssembly for AssemblyLoadContext #29842](https://github.com/dotnet/runtime/issues/29842)\r\n\r\n## P2 bugs\r\n- [ ] (small) [31195 - CustomAttribute with Array Properties sets nulls incorrectly #31195](https://github.com/dotnet/runtime/issues/31195)\r\n- [x] (small) [31127 - Mark Assembly.CodeBase as obsolete #31127](https://github.com/dotnet/runtime/issues/31127)\r\n- [ ] (small) [parameterBuilder.SetConstant NullReferenceException #5987](https://github.com/dotnet/runtime/issues/5987)\r\n- [x] (small) [ParameterInfo.HasDefaultValue throws System.FormatException on optional DateTime parameter #18844](https://github.com/dotnet/runtime/issues/18844)\r\n- [x] (investigate) [DispatchProxy doesn\u0027t handle Span #28468](https://github.com/dotnet/runtime/issues/28468)\r\n- [x] (investigate) [DispatchProxy doesn\u0027t handle ref returns #28467](https://github.com/dotnet/runtime/issues/28467)\r\n- [ ] (investigate) [Constructor_String_LoadVersionTest failing on Fedora runs #27817](https://github.com/dotnet/runtime/issues/27817)\r\n- [x] (investigate) [Reflection should check mscorlib for types #19689](https://github.com/dotnet/runtime/issues/19689)\r\n\r\n\r\n",
        "Milestone": "5.0.0",
        "Assignees": [
          "steveharter"
        ],
        "Labels": [
          {
            "Name": "Design Discussion",
            "BackgroundColor": "f7b7ee"
          },
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-System.Reflection.Emit",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#27803",
            "CreatedAt": "2018-11-02T23:18:46+00:00",
            "CreatedBy": "steveharter",
            "IsClosed": false,
            "Title": "MetadataLoadContext to support dynamic assemblies",
            "DescriptionMarkdown": "As part of the review for feature dotnet/runtime#15033 and PR dotnet/corefx#33201, there was concern about the lack of support for assemblies not backed by a physical file.\r\n\r\nFrom the comments @jkotas:\r\n\u003E There is no way to load runtime loaded assembly into MetadataLoadContext that it not backed by a physical file. The runtime has AssemblyExtensions.TryGetRawMetadata API to handle this case, but there is no way to give the blob returned by TryGetRawMetadata to MetadataLoadContext. The assemblies not backed by physical file are rare today, but they are very likely going to become more common as part of the single-file project.\r\nI am wondering whether there should be a LoadFrom method that takes MetadataReaderProvider to address both these problems and/or whether we should expose a resolver that can resolve the runtime loaded assemblies for you.\r\n\r\nImplementation\\design TBD. One approach is to use runtime reflection over the dynamic assembly, and convert those from \u0060System.RuntimeType\u0060 to the MetadataLoadContext types (\u0060System.RoType\u0060).\r\n\r\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30959",
            "CreatedAt": "2019-09-25T22:14:34+00:00",
            "CreatedBy": "barryhagan",
            "IsClosed": true,
            "Title": "Unable to read ReturnTypeCustomAttributes when using System.Reflection.MetadataLoadContext",
            "DescriptionMarkdown": "I was trying to use SR.MetadataLoadContext 4.6.0  in order to reflect an assembly and inspect for nullable reference types.    In order to do that I must get the custom attributes for a method\u0027s \u0060ReturnType\u0060 using \u0060ReturnTypeCustomAttributes\u0060.\r\n\r\nIf you attempt to call \u0060ICustomAttributeProvider.GetCustomAttributes(bool)\u0060 on \u0060ReturnTypeCustomAttributes\u0060, you get the following exception:\r\n\r\n\u0060\u0060\u0060console\r\nUnhandled exception: System.InvalidOperationException: The requested operation cannot be used on objects loaded by a MetadataLoadContext.\r\n   at System.Reflection.TypeLoading.RoParameter.GetCustomAttributes(Boolean inherit)\r\n\u0060\u0060\u0060\r\n\r\nIs there another way to get the custom attributes for a return type to inspect \u0060NullableAttribute\u0060 and \u0060NullableContextAttribute\u0060 with MetadataLoadContext?\r\n\r\nCurrent unwanted workaround is to reflect the property from the interface implementation, which lets me see the attributes:\r\n\u0060\u0060\u0060csharp\r\nMethodInfo mi;\r\nvar attributes = mi.ReturnTypeCustomAttributes.GetType().GetProperty(\u0022CustomAttributes\u0022).GetValue(mi) as IEnumerable\u003CCustomAttributeData\u003E;\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "question",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30886",
            "CreatedAt": "2019-09-18T14:33:14+00:00",
            "CreatedBy": "jonathanpeppers",
            "IsClosed": false,
            "Title": "System.Reflection.MetadataLoadContext performance",
            "DescriptionMarkdown": "I have a benchmark here: https://github.com/jonathanpeppers/Benchmarks/blob/7db49fb3d272c5b07deda166dd4f5a5112258bbe/Benchmarks/Cecil.cs#L90-L111\r\n\r\nAnd I am getting \u0022not so great\u0022 results for \u0060SR.MetadataLoadContext\u0060:\r\n\r\n\u0060\u0060\u0060\r\n// * Summary *\r\n\r\nBenchmarkDotNet=v0.11.3, OS=Windows 10.0.18362\r\nIntel Core i9-9900K CPU 3.60GHz, 1 CPU, 16 logical and 8 physical cores\r\n  [Host]     : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.4010.0\r\n  DefaultJob : .NET Framework 4.7.2 (CLR 4.0.30319.42000), 32bit LegacyJIT-v4.8.4010.0\r\n\r\n\r\n                                Method |        Mean |      Error |     StdDev |      Median | Gen 0/1k Op | Gen 1/1k Op | Gen 2/1k Op | Allocated Memory/Op |\r\n-------------------------------------- |------------:|-----------:|-----------:|------------:|------------:|------------:|------------:|--------------------:|\r\n            System.Reflection.Metadata |    32.84 ms |  0.1200 ms |  0.1123 ms |    32.85 ms |   3000.0000 |     62.5000 |           - |            15.12 MB |\r\n                            Mono.Cecil |   351.81 ms |  7.1738 ms | 21.1522 ms |   339.38 ms |  16000.0000 |  12000.0000 |   4000.0000 |           103.57 MB |\r\n System.Reflection.MetadataLoadContext | 2,058.91 ms | 19.9863 ms | 18.6952 ms | 2,051.50 ms |  97000.0000 |  90000.0000 |   6000.0000 |           544.84 MB |\r\n\u0060\u0060\u0060\r\n\r\nThe performance compared to using raw SRM or Mono.Cecil is drastically worse.\r\n\r\nI expected it to be somewhere in the middle of using SRM and Mono.Cecil. Is there something I\u0027m doing here that would explain the poor performance?\r\n\r\nThanks!",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "tenet-performance",
                "BackgroundColor": "c2e0c6"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#13298",
            "CreatedAt": "2019-08-22T02:07:15+00:00",
            "CreatedBy": "VincentBu",
            "IsClosed": true,
            "Title": "Test Failed: System.AccessViolationException: Attempted to read or write protected memory.",
            "DescriptionMarkdown": "**Detail:**\r\nhttps://helix.dot.net/api/2019-06-17/jobs/061738ef-c89d-4da3-9a70-ad8ea1c6968d/workitems/System.Reflection.MetadataLoadContext.Tests/console\r\n\r\n**Mod:**\r\nCOMPlus_JitStress=2\r\nCOMPlus_JitStressRegs=4\r\nCOMPlus_TieredCompilation=0\r\n\r\n**Log:**\r\n\u0060\u0060\u0060\r\nC:\\dotnetbuild\\work\\061738ef-c89d-4da3-9a70-ad8ea1c6968d\\Work\\009dec37-7ea7-403e-97d2-0ba158ec2160\\Exec\u003E\u0022C:\\dotnetbuild\\work\\061738ef-c89d-4da3-9a70-ad8ea1c6968d\\Payload\\dotnet.exe\u0022 exec --runtimeconfig System.Reflection.MetadataLoadContext.Tests.runtimeconfig.json xunit.console.dll System.Reflection.MetadataLoadContext.Tests.dll -xml testResults.xml -nologo -nocolor -notrait category=nonnetcoreapptests -notrait category=nonwindowstests -notrait category=IgnoreForCI -notrait category=OuterLoop -notrait category=failing @C:\\dotnetbuild\\work\\061738ef-c89d-4da3-9a70-ad8ea1c6968d\\Payload\\CoreFX.issues.rsp \r\n  Discovering: System.Reflection.MetadataLoadContext.Tests (method display = ClassAndMethod, method display options = None)\r\n  Discovered:  System.Reflection.MetadataLoadContext.Tests (found 484 test cases)\r\n  Starting:    System.Reflection.MetadataLoadContext.Tests (parallel test collections = on, max threads = 2)\r\nFatal error. System.AccessViolationException: Attempted to read or write protected memory. This is often an indication that other memory is corrupt.\r\n   at System.Reflection.TypeLoading.Ecma.EcmaModule.GetGenericTypeParameter(System.Reflection.TypeLoading.TypeContext, Int32)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeType(System.Reflection.Metadata.BlobReader ByRef, Boolean)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeTypeSequence(System.Reflection.Metadata.BlobReader ByRef)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeGenericTypeInstance(System.Reflection.Metadata.BlobReader ByRef)\r\n   at System.Reflection.Metadata.Ecma335.SignatureDecoder\u00602[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e],[System.Reflection.TypeLoading.TypeContext, System.Reflection.MetadataLoadContext, Version=4.0.0.0, Culture=neutral, PublicKeyToken=cc7b13ffcd2ddd51]].DecodeType(System.Reflection.Metadata.BlobReader ByRef, Boolean, Int32)\r\n   at System.Reflection.TypeLoading.Ecma.EcmaResolver.ResolveTypeSpec(System.Reflection.Metadata.TypeSpecificationHandle, System.Reflection.TypeLoading.Ecma.EcmaModule, System.Reflection.TypeLoading.TypeContext ByRef)\r\n   at System.Reflection.TypeLoading.Ecma.EcmaResolver.ResolveTypeDefRefOrSpec(System.Reflection.Metadata.EntityHandle, System.Reflection.TypeLoading.Ecma.EcmaModule, System.Reflection.TypeLoading.TypeContext ByRef)\r\n   at System.Reflection.TypeLoading.Ecma.EcmaDefinitionType.SpecializeBaseType(System.Reflection.TypeLoading.RoType[])\r\n   at System.Reflection.TypeLoading.RoType.ComputeBaseType()\r\n   at System.Reflection.TypeLoading.RoType.GetRoBaseType()\r\n   at System.Reflection.TypeLoading.Assignability.CanCastTo(System.Type, System.Type, System.Reflection.TypeLoading.CoreTypes)\r\n   at System.Reflection.TypeLoading.Assignability.IsAssignableFrom(System.Type, System.Type, System.Reflection.TypeLoading.CoreTypes)\r\n   at System.Reflection.TypeLoading.RoType.IsAssignableFrom(System.Type)\r\n   at System.Reflection.TypeLoading.RoType.IsAssignableFrom(System.Reflection.TypeInfo)\r\n   at System.Reflection.Tests.TypeInfoIsAssignableFromTests.VerifyIsAssignableFrom(System.String, System.Reflection.TypeInfo, System.Reflection.TypeInfo, Boolean)\r\n   at System.Reflection.Tests.TypeInfoIsAssignableFromTests.TestIsAssignable3()\r\n   at System.RuntimeMethodHandle.InvokeMethod(System.Object, System.Object[], System.Signature, Boolean, Boolean)\r\n   at System.Reflection.RuntimeMethodInfo.Invoke(System.Object, System.Reflection.BindingFlags, System.Reflection.Binder, System.Object[], System.Globalization.CultureInfo)\r\n   at Xunit.Sdk.TestInvoker\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].CallTestMethod(System.Object)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003Ec__DisplayClass48_1\u002B\u003C\u003CInvokeTestMethodAsync\u003Eb__1\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003Ec__DisplayClass48_1\u002B\u003C\u003CInvokeTestMethodAsync\u003Eb__1\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003C\u003CInvokeTestMethodAsync\u003Eb__1\u003Ed\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003Ec__DisplayClass48_1[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].\u003CInvokeTestMethodAsync\u003Eb__1()\r\n   at Xunit.Sdk.ExecutionTimer\u002B\u003CAggregateAsync\u003Ed__4.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExecutionTimer\u002B\u003CAggregateAsync\u003Ed__4, xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CAggregateAsync\u003Ed__4 ByRef)\r\n   at Xunit.Sdk.ExecutionTimer.AggregateAsync(System.Func\u00601\u003CSystem.Threading.Tasks.Task\u003E)\r\n   at Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__9.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__9, xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__9 ByRef)\r\n   at Xunit.Sdk.ExceptionAggregator.RunAsync(System.Func\u00601\u003CSystem.Threading.Tasks.Task\u003E)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003CInvokeTestMethodAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker\u00601\u002B\u003CInvokeTestMethodAsync\u003Ed__48[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CInvokeTestMethodAsync\u003Ed__48\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestInvoker\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].InvokeTestMethodAsync(System.Object)\r\n   at Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003CRunAsync\u003Eb__47_0\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestInvoker\u00601\u002B\u003C\u003CRunAsync\u003Eb__47_0\u003Ed[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003C\u003CRunAsync\u003Eb__47_0\u003Ed\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestInvoker\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].\u003CRunAsync\u003Eb__47_0()\r\n   at Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.Decimal, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.Decimal, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__10\u00601\u003CSystem.Decimal\u003E ByRef)\r\n   at Xunit.Sdk.XunitTestRunner.InvokeTestMethodAsync(Xunit.Sdk.ExceptionAggregator)\r\n   at Xunit.Sdk.XunitTestRunner\u002B\u003CInvokeTestAsync\u003Ed__4.MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.XunitTestRunner\u002B\u003CInvokeTestAsync\u003Ed__4, xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CInvokeTestAsync\u003Ed__4 ByRef)\r\n   at Xunit.Sdk.XunitTestRunner.InvokeTestAsync(Xunit.Sdk.ExceptionAggregator)\r\n   at Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.ExceptionAggregator\u002B\u003CRunAsync\u003Ed__10\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.core, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__10\u00601\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.ExceptionAggregator.RunAsync[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]](System.Func\u00601\u003CSystem.Threading.Tasks.Task\u00601\u003CSystem.__Canon\u003E\u003E)\r\n   at Xunit.Sdk.TestRunner\u00601\u002B\u003CRunAsync\u003Ed__43[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestRunner\u00601\u002B\u003CRunAsync\u003Ed__43[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__43\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.XunitTestCaseRunner.RunTestAsync()\r\n   at Xunit.Sdk.TestCaseRunner\u00601\u002B\u003CRunAsync\u003Ed__19[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCaseRunner\u00601\u002B\u003CRunAsync\u003Ed__19[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__19\u003CSystem.__Canon\u003E ByRef)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Xunit.Sdk.TestCaseRunner\u00601\u002B\u003CRunAsync\u003Ed__19[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__19\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestCaseRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.XunitTestMethodRunner.RunTestCaseAsync(Xunit.Sdk.IXunitTestCase)\r\n   at Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunTestCasesAsync\u003Ed__32[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunTestCasesAsync\u003Ed__32[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestCasesAsync\u003Ed__32\u003CSystem.__Canon\u003E ByRef)\r\n   at System.Runtime.CompilerServices.AsyncTaskMethodBuilder\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].Start[[Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunTestCasesAsync\u003Ed__32[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestCasesAsync\u003Ed__32\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestMethodRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestCasesAsync()\r\n   at Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunAsync\u003Ed__31[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestMethodRunner\u00601\u002B\u003CRunAsync\u003Ed__31[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__31\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.XunitTestClassRunner.RunTestMethodAsync(Xunit.Abstractions.ITestMethod, Xunit.Abstractions.IReflectionMethodInfo, System.Collections.Generic.IEnumerable\u00601\u003CXunit.Sdk.IXunitTestCase\u003E, System.Object[])\r\n   at Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunTestMethodsAsync\u003Ed__38[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunTestMethodsAsync\u003Ed__38[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestMethodsAsync\u003Ed__38\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestClassRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestMethodsAsync()\r\n   at Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunAsync\u003Ed__37[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestClassRunner\u00601\u002B\u003CRunAsync\u003Ed__37[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__37\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestClassRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunTestClassesAsync\u003Ed__28[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunTestClassesAsync\u003Ed__28[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunTestClassesAsync\u003Ed__28\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestCollectionRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunTestClassesAsync()\r\n   at Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunAsync\u003Ed__27[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].MoveNext()\r\n   at System.Runtime.CompilerServices.AsyncMethodBuilderCore.Start[[Xunit.Sdk.TestCollectionRunner\u00601\u002B\u003CRunAsync\u003Ed__27[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]], xunit.execution.dotnet, Version=2.4.1.0, Culture=neutral, PublicKeyToken=8d05b1bb7a6fdb6c]](\u003CRunAsync\u003Ed__27\u003CSystem.__Canon\u003E ByRef)\r\n   at Xunit.Sdk.TestCollectionRunner\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].RunAsync()\r\n   at Xunit.Sdk.XunitTestAssemblyRunner\u002B\u003C\u003Ec__DisplayClass14_2.\u003CRunTestCollectionsAsync\u003Eb__2()\r\n   at System.Threading.Tasks.Task\u00601[[System.__Canon, System.Private.CoreLib, Version=5.0.0.0, Culture=neutral, PublicKeyToken=7cec85d7bea7798e]].InnerInvoke()\r\n   at System.Threading.Tasks.Task\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__274_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntry()\r\n   at System.Threading.Tasks.SynchronizationContextTaskScheduler\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__8_0(System.Object)\r\n   at Xunit.Sdk.MaxConcurrencySyncContext.RunOnSyncContext(System.Threading.SendOrPostCallback, System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at Xunit.Sdk.MaxConcurrencySyncContext.WorkerThreadProc()\r\n   at Xunit.Sdk.XunitWorkerThread\u002B\u003C\u003Ec.\u003CQueueUserWorkItem\u003Eb__5_0(System.Object)\r\n   at System.Threading.Tasks.Task.InnerInvoke()\r\n   at System.Threading.Tasks.Task\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__274_0(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.Tasks.Task.ExecuteWithThreadLocal(System.Threading.Tasks.Task ByRef, System.Threading.Thread)\r\n   at System.Threading.Tasks.Task.ExecuteEntryUnsafe(System.Threading.Thread)\r\n   at System.Threading.Tasks.ThreadPoolTaskScheduler\u002B\u003C\u003Ec.\u003C.cctor\u003Eb__10_0(System.Object)\r\n   at System.Threading.ThreadHelper.ThreadStart_Context(System.Object)\r\n   at System.Threading.ExecutionContext.RunInternal(System.Threading.ExecutionContext, System.Threading.ContextCallback, System.Object)\r\n   at System.Threading.ThreadHelper.ThreadStart(System.Object)\r\nexit code -1073741819\r\n\u0060\u0060\u0060",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "arch-x64",
                "BackgroundColor": "eb6420"
              },
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "os-windows",
                "BackgroundColor": "fef2c0"
              },
              {
                "Name": "test-corefx",
                "BackgroundColor": "81af24"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30810",
            "CreatedAt": "2019-09-10T11:02:14+00:00",
            "CreatedBy": "Daniel-Svensson",
            "IsClosed": true,
            "Title": "Add .Net Framework TFM to System.Reflection.MetadataLoadContext",
            "DescriptionMarkdown": "Please add a net4* target such as (net46 or net461 ?) to System.Reflection.MetadataLoadContext as recommended by your own [Open-source library guidance\r\n](https://docs.microsoft.com/en-us/dotnet/standard/library-guidance/cross-platform-targeting).\r\n\r\nI want to consume it in a msbuild (distributed via nuget) task which should run on VS2015\u002B and I really do not want to have to ship the extra netstandard support assemblies.\r\nThey have given me problem before and I really cannot change target framework or which version of netstandard assemblies msbuild is bundled with.",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#26912",
            "CreatedAt": "2018-07-23T18:45:44+00:00",
            "CreatedBy": "joshfree",
            "IsClosed": true,
            "Title": " The dynamic type created is thrown Fileloadexception when using the GetCustomAttributes method",
            "DescriptionMarkdown": "Original issue https://github.com/dotnet/core/issues/1481\r\n\r\n**_@faib920 commented on Apr 26_**\r\nI Use TypeBuilder create a testclass, and use SetCustomAttributes to add custom attribute, then I use the method of GetCustomAttributes, throw FileLoadFileException.\r\n\r\nFileLoadException:\r\nCould not load file or assembly \u0027_testclass, Version=0.0.0.0, Culture=neutral, PublicKeyToken=null\u0027. Operation is not supported. (Exception from HRESULT: 0x80131515)\r\n\r\ninner Exception\r\nSystem.NotSupportedException\r\nResolving to a collectible assembly is not supported.\r\n\r\nStackTrace:\r\n\u0060\u0060\u0060\r\nat System.Reflection.CustomAttribute._CreateCaObject(RuntimeModule pModule, IRuntimeMethodInfo pCtor, Byte** ppBlob, Byte* pEndBlob, Int32* pcNamedArgs)\r\nat System.Reflection.CustomAttribute.CreateCaObject(RuntimeModule module, IRuntimeMethodInfo ctor, IntPtr\u0026 blob, IntPtr blobEnd, Int32\u0026 namedArgs)\r\nat System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeModule decoratedModule, Int32 decoratedMetadataToken, Int32 pcaCount, RuntimeType attributeFilterType, Boolean mustBeInheritable, IList derivedAttributes, Boolean isDecoratedTargetSecurityTransparent)\r\nat System.Reflection.CustomAttribute.GetCustomAttributes(RuntimeType type, RuntimeType caType, Boolean inherit)\r\nat System.Attribute.GetCustomAttributes(MemberInfo element, Type type, Boolean inherit)\r\nat System.Reflection.CustomAttributeExtensions.GetCustomAttributes[T](MemberInfo element, Boolean inherit)\r\n\u0060\u0060\u0060\r\n\r\n\r\n**_@evo01 commented 14 days ago_**\r\nI did some more testing around this issue and the temporary work around seems to be to not use named arguments.  If you leave the named arguments off, and use the following property instead, you can custom attributes in a dynamic type.\r\n\r\n\u0060\u0060\u0060\r\n[Custom1(\u0022Howdy\u0022, new []{ EnumTesting_BasicEnum_Int16 .One})] \r\npublic class ClassTesting_ClassWithBlankAttribute\r\n{\r\n}\r\n\u0060\u0060\u0060\r\n\r\n\u0060var attributes = dynamicType.CustomAttributes.ToList(); // WORKS\u0060\r\n\t\t\t\r\n\u0060Assert.AreEqual(1, attributes.Count); // WORKS\u0060\r\n\r\n\r\n\r\nThis does not work:\r\n\r\n\u0060\u0060\u0060\r\n[Custom1(\u0022Howdy\u0022, new []{ EnumTesting_BasicEnum_Int16 .One}, MyField1 = new[] { EnumTesting_BasicEnum_Int16.One }, MyField2 = typeof(Custom1Attribute), MyProperty1 =1)]\r\npublic class ClassTesting_ClassWithBlankAttribute\r\n{\r\n}\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "needs more info",
                "BackgroundColor": "eb6420"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#30917",
            "CreatedAt": "2019-09-20T21:12:53+00:00",
            "CreatedBy": "AArnott",
            "IsClosed": false,
            "Title": "System.Reflection.DispatchProxy inconsistently fails for internal interfaces",
            "DescriptionMarkdown": "An undocumented limitation in \u0060DispatchProxy.Create\u0060 is that it *sometimes* throws for various configurations of visibility. This seems to be a broader issue than the more specific dotnet/runtime#25595.\r\n\r\nThese configurations work:\r\n\r\n1. public interface, public base class.\r\n1. internal interface, internal base class, within the same assembly. But only when this is the *first* proxy ever generated.\r\n\r\nThese configurations *don\u0027t* work:\r\n\r\n1. public interface, internal base class.\r\n1. internal interface, internal base class, if another assembly has already provided an internal interface to generate a proxy for.\r\n\r\nThere were other odd configurations that similarly failed.\r\n\r\nSince I\u0027ve done this kind of feature before, I have a suspicion that the generated \u0060ProxyBuilder\u0060 assembly includes an [\u0060System.Runtime.CompilerServices.IgnoresAccessChecksToAttribute\u0060](https://github.com/microsoft/vs-mef/blob/21ca4f58145ae9e0e1560de287e112a608ed796f/src/Microsoft.VisualStudio.Composition/Reflection/SkipClrVisibilityChecks.cs#L159) for the assembly that defines the interface. \r\nThe way I solved this is that each time I need to generate a proxy, [I evaluate all the assemblies that visibility checks must be skipped for](https://github.com/microsoft/vs-mef/blob/21ca4f58145ae9e0e1560de287e112a608ed796f/src/Microsoft.VisualStudio.Composition/Configuration/MetadataViewGenerator.cs#L114) and create a new dynamic assembly for each unique set that I get. So multiple proxies are supported, and we reuse dynamic assemblies where possible but when the set of dynamic assemblies exceed any previously discovered set we have to start a new assembly.\r\n\r\nAdding more attributes to an existing dynamic assembly is ineffective because once you\u0027ve loaded the first type from the assembly, the CLR caches these attributes and doesn\u0027t notice when new ones are added.",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#28046",
            "CreatedAt": "2018-12-03T19:53:09+00:00",
            "CreatedBy": "MichalStrehovsky",
            "IsClosed": true,
            "Title": "Port CoreRT fix to System.Reflection.MetadataLoadContext",
            "DescriptionMarkdown": "Port this to MetadataLoadContext and add test coverage:\r\n\r\nhttps://github.com/dotnet/corert/pull/6638/commits/93364da1a71588650e1e4013bb481d4745dc5d9d",
            "Milestone": "Future",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "needs more info",
                "BackgroundColor": "eb6420"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#15704",
            "CreatedAt": "2015-11-13T06:21:41+00:00",
            "CreatedBy": "jonorossi",
            "IsClosed": false,
            "Title": "System.Reflection.Emit.AssemblyBuilder.Save",
            "DescriptionMarkdown": "\u0060AssemblyBuilder.Save\u0060 and \u0060AssemblyBuilderAccess.RunAndSave\u0060 isn\u0027t available in .NET Core, however coreclr seems to have the code to implement it but I looks conditionally compiled out.\n\nhttps://github.com/dotnet/coreclr/blob/bc146608854d1db9cdbcc0b08029a87754e12b49/src/mscorlib/src/System/Reflection/Emit/AssemblyBuilder.cs#L1690-L1711\n\nOur use case in Castle DynamicProxy is to write out dynamically created assemblies to disk so we can run peverify over the assembly in unit tests. It also greatly helps writing out the assembly and opening it in ildasm to manually verify IL.\n\nIs there any chance we can get this functionality that .NET Framework has introduced into .NET Core, or an alternative way of doing the same thing. This might not sound like a big deal if you aren\u0027t familiar with Castle DynamicProxy\u0027s internals, but it really is as it heavily reduces our confidence in both our code and the .NET runtime as well as reducing our ability to track down defects.\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-needs-work",
                "BackgroundColor": "207de5"
              },
              {
                "Name": "area-System.Reflection.Emit",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#29842",
            "CreatedAt": "2019-06-10T22:30:00+00:00",
            "CreatedBy": "sdmaclea",
            "IsClosed": false,
            "Title": "WIP API Proposal - AssemblyBuilder.DefineDynamicAssembly for AssemblyLoadContext",
            "DescriptionMarkdown": "https://docs.microsoft.com/en-us/dotnet/api/system.reflection.emit.assemblybuilder.definedynamicassembly?view=netcore-3.0\r\n\r\n\u0060AssemblyBuilder\u0060 is implemented as a type of \u0060RuntimeAssembly\u0060, but there seems to be no mechanism to create it directly in a specific \u0060AssemblyLoadContext\u0060.\r\n\r\nI assume we need at least one mechanism.\r\n\r\nThis issue is highly similar to that described in dotnet/runtime#29042\r\n\r\nIf we chose a similar solution, we would need 2 changes.\r\n1. Make existing APIs sensitive to AssemblyLoadContext.CurrentContextualReflectionContext \r\n2. Add new explicit APIs\r\n\r\nWe may be able to support 1 above in 3.0 as this may be a simple PR.\r\nIt would be nice to add the new APIs for 3.1, but this may not meet the shiproom approval process\r\n\r\n/cc @vitek-karas @jkotas @cablooshe @elinor-fung @jeffschwMSFT @sbomer \r\n\r\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection.Emit",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#31195",
            "CreatedAt": "2019-10-17T07:45:12+00:00",
            "CreatedBy": "JamesAshworth",
            "IsClosed": false,
            "Title": "CustomAttribute with Array Properties sets nulls incorrectly",
            "DescriptionMarkdown": "An attribute with two array properties does not behave as expected if the first array property is set to a value and the second array property is set to null. If the two arrays are of the same type, the second property is set to the same value as the first property. If the two types are incompatible, an exception is thrown when the attribute is constructed, stating that the second property cannot be found.\r\n\r\nAttached are two variations on a simple program that replicates each issue.\r\n\r\n[Same Type](https://github.com/dotnet/corefx/files/3737962/Program.txt)\r\n[Incompatible Types](https://github.com/dotnet/corefx/files/3737971/Program.2.txt)\r\n\r\n",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#31127",
            "CreatedAt": "2019-10-09T23:56:18+00:00",
            "CreatedBy": "terrajobst",
            "IsClosed": true,
            "Title": "Mark Assembly.CodeBase as obsolete",
            "DescriptionMarkdown": "\u0060Assembly.Location\u0060 and \u0060Assembly.CodeBase\u0060 are very similar, but not the same thing. To reduce confusion, we should mark it as obsolete.\r\n\r\n### Reason\r\n\r\nHaving two things that are similar, but not identical always causes confusion. Here is [an example](https://github.com/aspnet/AspNetCore/issues/14501#issuecomment-537286033).\r\n\r\nAs @jkotas [said](https://github.com/aspnet/AspNetCore/issues/14501#issuecomment-538606720):\r\n\r\n\u003E \u0060Assembly.Location\u0060 is strictly better than \u0060Assembly.CodeBase\u0060.\r\n\u003E \r\n\u003E \u0060Assembly.CodeBase\u0060 is an obsolete property. The only reason why it was included in .NET Core was .NET Framework compatibility. The original purpose of \u0060Assembly.CodeBase\u0060 was CAS (Code Access Security). It was meant to describe where the assembly was downloaded from for the Internet Zone security checks. It also explains some of its weird behaviors. For example, if the assembly is loaded as byte array, it returns the location of the caller of the \u0060Assembly.Load\u0060 method.\r\n\r\n### Proposed API\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace System.Reflection\r\n{\r\n    public partial class Assembly\r\n    {\r\n        [Obsolete(\u0022Use Location instead.\u0022)]\r\n        public virtual string CodeBase { get; }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "easy",
                "BackgroundColor": "90eeff"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#5987",
            "CreatedAt": "2016-06-01T14:21:48+00:00",
            "CreatedBy": "GSPP",
            "IsClosed": true,
            "Title": "parameterBuilder.SetConstant NullReferenceException",
            "DescriptionMarkdown": "\u0060\u0060\u0060\n        var assemblyBuilder = AssemblyBuilder.DefineDynamicAssembly(new AssemblyName(\u0022x\u0022), AssemblyBuilderAccess.RunAndSave);\n        var moduleBuilder = assemblyBuilder.DefineDynamicModule(\u0022x\u0022);\n        var typeBuilder = moduleBuilder.DefineType(\u0022C\u0022, TypeAttributes.Class);\n        var methodBuilder = typeBuilder.DefineMethod(\u0022M\u0022, MethodAttributes.Static);\n        methodBuilder.SetParameters(typeof(void), typeof(TimeSpan));\n\n        var parameterBuilder = methodBuilder.DefineParameter(0, ParameterAttributes.HasDefault, \u0022p\u0022);\n        parameterBuilder.SetConstant(null); //NullReferenceException\n\u0060\u0060\u0060\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#18844",
            "CreatedAt": "2016-10-04T04:58:00+00:00",
            "CreatedBy": "epsitec",
            "IsClosed": true,
            "Title": "ParameterInfo.HasDefaultValue throws System.FormatException on optional DateTime parameter",
            "DescriptionMarkdown": "When accessing \u0060ParameterInfo.HasDefaultValue\u0060 for a parameter of type \u0060System.DateTime\u0060, I\nget an unexpected \u0060System.FormatException\u0060.\n\n\u0060ParameterInfo.Attributes\u0060 is correctly set to \u0060Optional | HasDefault\u0060.\n\nIf the parameter is of any other value type (e.g. \u0060decimal\u0060 or some custom _struct_) the\nproperty works as expected. There is something specific to \u0060DateTime\u0060 in the implementation\nof \u0060RuntimeParameterInfo.GetDefaultValueInternal()\u0060 which is broken.\n\nCode snippet to test:\n\n\u0060\u0060\u0060 c#\npublic void Usage()\n{\n    var type = typeof (Foo);\n    var ctor = type.GetConstructors ()[0];\n    var para = ctor.GetParameters ()[0];\n    // This throws an exception...\n    Assert.True (para.HasDefaultValue);\n}\n\nstatic class Foo\n{\n    public Foo(System.DateTime value = default (System.DateTime)) { }\n}\n\u0060\u0060\u0060\n\nException:\n\n![default-value](https://cloud.githubusercontent.com/assets/3872435/19062968/c8793004-89fe-11e6-9db3-b203f4c900d3.png)\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "bug",
                "BackgroundColor": "f49cb1"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#28468",
            "CreatedAt": "2019-01-21T12:42:57+00:00",
            "CreatedBy": "MichalStrehovsky",
            "IsClosed": true,
            "Title": "DispatchProxy doesn\u0027t handle Span",
            "DescriptionMarkdown": "This fails with:\r\n\r\nSystem.InvalidProgramException: \u0027Cannot create boxed ByRef-like values.\u0027\r\n\r\nNot sure we can do anything with the existing structure, but this doesn\u0027t point to where the problem is.\r\n\r\n\u0060\u0060\u0060csharp\r\nusing System;\r\nusing System.Reflection;\r\n\r\nunsafe interface IFoo\r\n{\r\n    int Frob(Span\u003Cint\u003E x);\r\n}\r\n\r\nunsafe class Program : DispatchProxy\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        IFoo myProxy = DispatchProxy.Create\u003CIFoo, Program\u003E();\r\n        int result = myProxy.Frob(default);\r\n        Console.WriteLine($\u0022myProxy.Frob returned {(IntPtr)result}\u0022);\r\n    }\r\n\r\n    protected override object Invoke(MethodInfo targetMethod, object[] args)\r\n    {\r\n        Console.WriteLine($\u0022Invoked method {targetMethod.Name} with {args.Length} arguments\u0022);\r\n        return 42;\r\n    }\r\n}\r\n\r\n\u0060\u0060\u0060",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#28467",
            "CreatedAt": "2019-01-21T12:41:10+00:00",
            "CreatedBy": "MichalStrehovsky",
            "IsClosed": true,
            "Title": "DispatchProxy doesn\u0027t handle ref returns",
            "DescriptionMarkdown": "Not sure if anything can be done with the existing structure to make this work, but this fails with:\r\n\r\nSystem.ArgumentException: \u0027Cannot get TypeToken for a ByRef type.\u0027\r\n\r\nThis doesn\u0027t really point to where the problem is.\r\n\r\n\u0060\u0060\u0060csharp\r\nusing System;\r\nusing System.Reflection;\r\n\r\nunsafe interface IFoo\r\n{\r\n    ref int Frob();\r\n}\r\n\r\nunsafe class Program : DispatchProxy\r\n{\r\n    static void Main(string[] args)\r\n    {\r\n        IFoo myProxy = DispatchProxy.Create\u003CIFoo, Program\u003E();\r\n        int result = myProxy.Frob();\r\n        Console.WriteLine($\u0022myProxy.Frob returned {(IntPtr)result}\u0022);\r\n    }\r\n\r\n    protected override object Invoke(MethodInfo targetMethod, object[] args)\r\n    {\r\n        Console.WriteLine($\u0022Invoked method {targetMethod.Name} with {args.Length} arguments\u0022);\r\n        return 42;\r\n    }\r\n}\r\n\u0060\u0060\u0060",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#27817",
            "CreatedAt": "2018-11-05T17:27:15+00:00",
            "CreatedBy": "weshaggard",
            "IsClosed": false,
            "Title": "Constructor_String_LoadVersionTest failing on Fedora runs",
            "DescriptionMarkdown": "\u0060\u0060\u0060\r\nAssert.Throws() Failure\r\nExpected: typeof(System.IO.FileNotFoundException)\r\nActual:   (No exception was thrown)\r\nStack Trace :\r\n   at System.Reflection.Tests.AssemblyNameTests.Constructor_String_LoadVersionTest() in /mnt/j/workspace/dotnet_corefx/master/linux-TGroup_netcoreapp\u002BCGroup_Release\u002BAGroup_x64\u002BTestOuter_false_prtest/src/System.Reflection/tests/AssemblyNameTests.cs:line 559\r\n\u0060\u0060\u0060\r\n\r\nA couple examples:\r\nhttps://mc.dot.net/#/user/weshaggard/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/84cf25a2c8d2bd2819584e57de87a5c1c0fa6efa/workItem/System.Reflection.Tests/analysis/xunit/System.Reflection.Tests.AssemblyNameTests~2FConstructor_String_LoadVersionTest\r\nhttps://mc.dot.net/#/user/stephentoub/pr~2Fjenkins~2Fdotnet~2Fcorefx~2Fmaster~2F/test~2Ffunctional~2Fcli~2F/b4be508ae9f11a42286a828728d537eca987d0bb/workItem/System.Reflection.Tests/analysis/xunit/System.Reflection.Tests.AssemblyNameTests~2FConstructor_String_LoadVersionTest",
            "Milestone": "Future",
            "Assignees": [
              "steveharter"
            ],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "disabled-test",
                "BackgroundColor": "654321"
              },
              {
                "Name": "os-linux",
                "BackgroundColor": "fef2c0"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#19689",
            "CreatedAt": "2016-12-14T22:27:46+00:00",
            "CreatedBy": "JeremyKuhne",
            "IsClosed": true,
            "Title": "Reflection should check mscorlib for types",
            "DescriptionMarkdown": "In NetFX \u0060Type.GetType()\u0060 would find types that weren\u0027t fully qualified in mscorlib. Now that we\u0027re going to ship the mscorlib facade we should probably mimic that behavior.\r\n\r\nSee the following discussion: https://github.com/dotnet/corefx/pull/14498#discussion_r92474847\r\n\r\n@weshaggard, @ericstj \r\n",
            "Milestone": "5.0.0",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Reflection",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              },
              {
                "Name": "tenet-compatibility",
                "BackgroundColor": "c2e0c6"
              },
              {
                "Name": "untriaged",
                "BackgroundColor": "fbca04"
              },
              {
                "Name": "up-for-grabs",
                "BackgroundColor": "23ef90"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#31372",
        "CreatedAt": "2019-11-01T23:57:24+00:00",
        "CreatedBy": "tarekgh",
        "IsClosed": true,
        "Title": "Distributed Context in ASP.NET and Open Telemetry",
        "DescriptionMarkdown": "This issue is tracking the work that needs to be done for supporting the distributed context scenarios for ASP.NET and [OpenTelemetry](https://github.com/open-telemetry/opentelemetry-specification).\r\n\r\nHere are the scenarios we need to support: \r\n\r\n## Distributed Context scenarios\r\nThese scenarios talking about ILogger and OpenTelemetry scenarios. OpenTelemetry has a goal to implement all these scenarios if you replace \u201CILogger\u201D with \u201COpenTelemetry Logging API\u201D. The goal of this document is to come up with scenarios that will not require OpenTelemetry to introduce new concepts and libraries. And out-of-the-box ASP.NET apps be more distributed apps friendly.\r\n\r\n### Out of the box ASP.NET application\r\n- Distributed trace identifiers are automatically propagated through the app. This enables the correlation of telemetry across multiple components even when only a subset of these components has monitoring enabled.\r\nNote: This is already implemented via DiagnosticsSource.Activity. \r\n\r\n- Log messages and exceptions are automatically associated with the distributed trace identifiers. This allows pinpointing the root cause of the problem faster by associating logs and exceptions with the downstream components that might have caused the problem or upstream - components providing incorrect data.\r\nNote: This is partially implemented - trace-id and span-id of a topmost request are added to the ILogger scope.\r\n\r\n- Users may output distributed trace identifiers as part of an error page for the app user reference. This allows improving application supportability by providing a fast lookup reference that will simplify customer communication with support personnel.\r\n\r\n### Scoping of distributed logs\r\n- The developer may add a name/value pairs to the scope of execution. This name/value pair will be associated with all logs captured in this scope\r\n\tNote: this is an existing ILogger feature\r\n\r\n- The developer may configure some of the name/value pairs in scope to be distributed. These scope values will be transmitted over the wire and associated with the logs reported by downstream services. This feature enables scenarios like clients sending client app versions as a context property and all logs across many layers of a distributed trace will be attributed to it.\r\n\r\n### ASP.NET app with OpenTelemetry enabled\r\n- When OpenTelemetry is enabled - all logs reported by ILogger must bye be attributed with the OpenTelemetry span identity. So telemetry reported by OpenTelemetry and ILogger can be cross-referenced.\r\n\r\n- Spans reported by OpenTelemetry can use the scope\u2019s name/value pairs configured by the customer for ILogger as dimensions for telemetry. This will ensure that OpenTelemetry benefits from app attribution made by the developer for better diagnostics experience. This includes both - local and distributed contexts.\r\n\r\n### Metrics and scopes\r\n- Metrics aggregation in OpenTelemetry may use the scope\u2019s name/value pairs as a dimension for aggregation based on configuration. This includes both - local and distributed contexts.\r\n\r\n- EventCounters may use the scope\u2019s name/value pairs as a dimension for aggregation. This includes both - local and distributed contexts.\r\n\r\n### Distributed \u201CHTTP context\u201D\r\n- The developer must be able to set up business-critical properties that can be used across the entire distributed trace.\r\n\r\n## Tracked work items:\r\n\r\n- [x] [Make Activity and Span the same.](https://github.com/dotnet/runtime/issues/31373) @tarekgh\r\n- [x] [Add Ids and Context to all logs.](https://github.com/dotnet/runtime/issues/34305) @tarekgh\r\n- [ ] [Distributed Context API (distributed http context)](https://github.com/dotnet/runtime/issues/31393). Should be in a separate library. @tarekgh\r\n    * string/string\r\n    * Scope-able\r\n    * Not attached to Activity\r\n\r\nRef: \r\n[OpenTelemetry .NET  implementation](https://github.com/open-telemetry/opentelemetry-dotnet)\r\n[Improvements in .NET Core 3.0 for troubleshooting and monitoring distributed apps blog](https://devblogs.microsoft.com/aspnet/improvements-in-net-core-3-0-for-troubleshooting-and-monitoring-distributed-apps/)\r\n\r\nCC @SergeyKanzhelev @pakrym",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-System.Diagnostics",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": [
        {
          "Issue": {
            "Id": "dotnet/runtime#31373",
            "CreatedAt": "2019-11-02T00:07:01+00:00",
            "CreatedBy": "tarekgh",
            "IsClosed": true,
            "Title": "Support OpenTelemetry concepts on Activity",
            "DescriptionMarkdown": "This issue tracking the work as the part of the issue https://github.com/dotnet/corefx/issues/42305\r\n\r\nPlease look at https://github.com/dotnet/designs/pull/98 for the detailed design.",
            "Milestone": "5.0.0",
            "Assignees": [
              "tarekgh"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-System.Diagnostics",
                "BackgroundColor": "d4c5f9"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#34305",
            "CreatedAt": "2019-11-02T00:13:58+00:00",
            "CreatedBy": "tarekgh",
            "IsClosed": true,
            "Title": "Add activity Ids and Context to all logs ",
            "DescriptionMarkdown": "This issue tracking the work as the part of the issue https://github.com/dotnet/runtime/issues/31372\r\n\r\n## Rationale and Use Cases\r\n\r\nCurrently, there is no automatic way to log the tracing context info with the logging scopes. Tracing context info is the trace Id, Span Id, Parent Id, Trace State, and Trace flags which included inside the Activity object stored in the current execution context. This issue is to support adding the tracing context info with the logging scopes.\r\n\r\nAdding Tracing context info to the logging scope will require some memory allocations and also will increase the produced text inside the logs, we are going to provide an opt-in option to enable the new behavior. Although the whole feature is about internal implementation details, we still need to expose some API for the opt-in option. ***All Proposed APIs here are only to provide the opt-in option for enabling the trace context info in logging and choose which parts of the trace context should be included***.\r\n\r\nHere is a code sample showing how to opt-in to include the trace context info in the logs.\r\n\r\n\u0060\u0060\u0060C#\r\nvar loggerFactory = LoggerFactory.Create(builder =\u003E\r\n{\r\n    // Enable logging trace context info in the logging scopes.\r\n    builder.Configure(factoryOptions =\u003E factoryOptions.ActivityTrackingOptions = ActivityTrackingOptions.Default);\r\n});\r\n\u0060\u0060\u0060\r\n\r\nWhen enable trace context info logging, will get in the logging results like the following:\r\n\r\n\u0060\u0060\u0060\r\ninfo: Microsoft.Extensions.Logging.Test.ConsoleLoggerTest[0]\r\n      =\u003E SpanId:|30de9810-4985f5593b3c7f14.1., TraceId:30de9810-4985f5593b3c7f14, ParentId:|30de9810-4985f5593b3c7f14. =\u003E { Scope1 = 1 } =\u003E { Scope2 = 2 }\r\n\u0060\u0060\u0060\r\n\r\n## Proposed API\r\n\r\n- ActiviyTrackingOptions is a flags enum has the values of which parts of the trace context can be included in the logs.\r\n- LoggerFactoryOptions is the new options type for the logger factory. Although it contains the only property ActivityTrackingOptions used to enable the trace context logging, this type can be extended in the future to include more options as needed. \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    [Flags]\r\n    public enum ActivityTrackingOptions\r\n    {\r\n        None        = 0x0000,\r\n        SpanId      = 0x0001,\r\n        TraceId     = 0x0002,\r\n        ParentId    = 0x0004,\r\n        Default     = SpanId | TraceId | ParentId,\r\n        TraceState  = 0x0008,\r\n        TraceFlags  = 0x0010\r\n    }\r\n\r\n    public class LoggerFactoryOptions\r\n    {\r\n        public LoggerFactoryOptions() { }\r\n        public ActivityTrackingOptions ActivityTrackingOptions  { get {throw null; } set { throw null; } }\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n- Adding more constructors to the existing LoggerFactory class. This addition mainly to have the Dependency Injection (DI) work nicely with the introduced LoggerFactoryOptions. \r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    // LoggerFactory is existing type\r\n    public partial class LoggerFactory : ILoggerFactory, System.IDisposable\r\n    {\r\n        public LoggerFactory(IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers, IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers, LoggerFilterOptions filterOptions, IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n        public LoggerFactory(IEnumerable\u003CILoggerProvider\u003E providers, IOptionsMonitor\u003CLoggerFilterOptions\u003E filterOption, IOptions\u003CLoggerFactoryOptions\u003E options) { }\r\n     }\r\n}\r\n\u0060\u0060\u0060\r\n\r\n- Adding the extension method Configure to the logger builder\r\n\r\n\u0060\u0060\u0060C#\r\nnamespace Microsoft.Extensions.Logging\r\n{\r\n    // LoggingBuilderExtensions is existing type\r\n    public static partial class LoggingBuilderExtensions\r\n    {\r\n        public static ILoggingBuilder Configure(this ILoggingBuilder builder, Action\u003CLoggerFactoryOptions\u003E action) {...}\r\n    }\r\n}\r\n\u0060\u0060\u0060\r\n",
            "Milestone": "5.0.0",
            "Assignees": [
              "tarekgh"
            ],
            "Labels": [
              {
                "Name": "api-approved",
                "BackgroundColor": "159818"
              },
              {
                "Name": "area-Extensions-Logging",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        },
        {
          "Issue": {
            "Id": "dotnet/runtime#31393",
            "CreatedAt": "2019-11-04T20:27:21+00:00",
            "CreatedBy": "tarekgh",
            "IsClosed": false,
            "Title": "Introduce Distributed Context API (distributed http context)",
            "DescriptionMarkdown": "This issue tracking the work as the part of the issue dotnet/runtime#31372\r\n\r\nDistributed context should support \r\n- string/string (key-value pairs)\r\n- Support scoping \r\n- Not attached to Activity",
            "Milestone": "Future",
            "Assignees": [],
            "Labels": [
              {
                "Name": "area-System.Diagnostics",
                "BackgroundColor": "d4c5f9"
              },
              {
                "Name": "enhancement",
                "BackgroundColor": "200dff"
              }
            ],
            "Kind": 3,
            "ProjectStatus": null
          },
          "Children": []
        }
      ]
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#1568",
        "CreatedAt": "2019-09-27T16:27:42+00:00",
        "CreatedBy": "jkotas",
        "IsClosed": false,
        "Title": "Generate Json serializers at build time",
        "DescriptionMarkdown": "\u003Cdetails\u003E\r\n\u003Csummary\u003EOriginal proposal by @jkotas (click to view)\u003C/summary\u003E\r\n\u003C/br\u003E\r\nThe generation of Json serializers via reflection at runtime has non-trivial startup costs. This has been identified as a bottleneck during prototyping of fast small cloud-first micro-services: \r\n\r\nRepro: https://gist.github.com/jkotas/b0671e154791e287c38a627ca81d7197\r\n\r\nThe Json serializer generated using reflection at runtime has startup cost ~30ms. The manually written Json serializer has startup cost ~1ms.\r\n\u003C/details\u003E\r\n\r\n---\r\n\r\n_Edited by @kevinwkt:_\r\n\r\n## Background \r\n\r\nThere are comprehensive [documents](https://github.com/dotnet/designs/pull/113) detailing the [needs](https://github.com/dotnet/runtime/issues/1568) and benefits of generating JSON serializers at compile time. Some of these benefits are improved startup time, and reduction in private memory usage and faster throughput for serialization and deserialization. After discussing some approaches and pros/cons of some of them we decided to implement this feature using [Roslyn source generators](https://devblogs.microsoft.com/dotnet/introducing-c-source-generators/). Implementation details and code/usage examples can be seen in the [design document](https://github.com/dotnet/runtimelab/pull/16/files). This document will outline the roadmap for the initial experiment and highlight actionable items.  \r\n\r\nThis is an intern project and experimental which is why we will be using the [dotnet/runtimelab](https://github.com/dotnet/runtimelab/tree/JsonCodeGen) repository instead of [dotnet/runtime](https://github.com/dotnet/runtime). The main goal of this project is to get something up and running while changing implementation and iterating on public API without committing to dotnet/runtime master. We hope to share the project and get feedback for potential release on .NET 6.0. The project will be consumable through a prerelease package until then. Progress can be tracked through the [JSON Code Gen project board](https://github.com/dotnet/runtimelab/projects/1) in dotnet/runtimelab. \r\n\r\n## Approach \r\n\r\nThere are 3 main points in this project: type discovery, source code generation, generated source code integration (with user applications). \r\n\r\n### Type discovery \r\n\r\nType discovery can be thought of in two ways, an implicit model (where the user does not have to specify which types to generate code for) and an explicit model (user specifies through code  or configuration which types to generate code for). \r\n\r\nVarious implicit approaches have been discussed such as source generating for all partial classes or scanning for calls into the serializer using Roslyn tree syntax. These models can be revisited in the future as the value/feasibility of the approach becomes clearer based on user feedback. It is important to note that some downsides to such a model include missing types to generate source for or generating source for types when not needed due to a bug or edge cases we didn\u2019t consider. \r\n\r\nThe proposed approach for type discovery requires an explicit indication of serializable types by the user. This model supports indicating both owned and non-owned types. A new [\u0060JsonSerializableAttribute\u0060](https://github.com/dotnet/runtimelab/blob/JsonCodeGen/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Attributes/JsonSerializableAttribute.cs) will be used to detect these types. There are two patterns for \u0060JsonSerializiableAttribute\u0060. The first consists of applying the attribute on a type that the user owns, and the second consists of the user passing into the constructor of the attribute a non-owned serializable type. \r\n\r\nWe believe that an explicit model using attributes would be a simple first-approach to the problem. Within the Roslyn source generator, we parse the syntax tree to find usages of the \u0060JsonSerializableAttribute\u0060. The output of this phase would be a list of input types for the generator in order to code-gen recursively for each type in all the object graphs. \r\n\r\n### Source code generation \r\n\r\nThe design for the generated source focuses mainly on performance gains and extensibility to existing \u0060JsonSerializer\u0060 functionality. Performance is improved in two ways. The first is during the first-time/warm-up performance for both CPU and memory by avoiding costly reflection to build up a Type metadata cache during runtime and moving it to compile time. These type metadata are then represented as [\u0060JsonTypeInfo\u0060](https://github.com/steveharter/runtimelab/blob/ApiAdds/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/Metadata/JsonTypeInfoOfT.cs#L15) classes that can be used for (de)serialization at runtime. The second is throughput improvement by avoiding the initial metadata-dictionary lookup on calls to the serializer by generating an instance of the type\u2019s \u0060JsonTypeInfo\u0060 (metadata). These instances will be passed to [new (de)serialize overloads](https://github.com/dotnet/runtimelab/compare/JsonCodeGen...steveharter:ApiAdds#diff-e6bf8cabf53ffaaaaf77cf53a9db85fcR59). \r\n\r\nWe will use the types discovered in the type discovery phase and recurse through the type graph in order to source generate the functions mentioned above within each \u0060JsonTypeInfo\u0060 and register them inside the user-facing wrapper \u0060JsonSerializerContext\u0060. \r\n\r\n### Generated source code integration \r\n\r\nThere are [discussions](https://gist.github.com/steveharter/d71cdfc25df53a8f60f1a3563d13cf0f) regarding integration of generated metadata source code with user apps.  The proposed approach consists of the generator creating a context class ([\u0060JsonSerializerContext\u0060](https://github.com/steveharter/runtimelab/blob/ApiAdds/src/libraries/System.Text.Json/src/System/Text/Json/Serialization/JsonSerializerContext.cs#L10)) which takes an options instance and contains references to the generated \u0060JsonTypeInfos\u0060 for each type seen above. This relies on the creation of new overloads to the current serializer mentioned before that can be retrieved from the context. An example of the overload and usage can be seen [here](https://github.com/dotnet/runtimelab/compare/master...steveharter:ApiAdds), while examples and details of the end to end approach can be seen in the [design document](https://github.com/dotnet/runtimelab/pull/16/files). \r\n\r\n \r\n\r\n## Action items: \r\n\r\n- [x] Implement and expose public API needed by the source generator ([in progress](https://github.com/steveharter/runtimelab/tree/ApiAdds) by @steveharter) \r\n\r\n- [x] Create source generator project in \u0060System.Text.Json\u0060 dotnet/runtimelab directory\r\n\r\n- [x] Create source generator unit test project\r\n\r\n- [x] Create source generator end-to-end test project\r\n\r\n  - [ ] Create infrastructure for performance benchmarking within the project \r\n\r\n- [x] Implement initial mechanism for type discovery \r\n\r\n  - [x] Implement and expose new \u0060JsonSerializableAttribute\u0060 from \u0060System.Text.Json\u0060. This will allow callers to indicate which types to generate serializers for (both user owned and non-user owned)  \r\n\r\n  - [x] Implement Roslyn syntax receiver to receive list of types to generate serializers for. \r\n\r\n- [ ] Implement, test, and benchmark source generator for POCOS (classes and structs) \r\n\r\n  - [ ] Share progress with partner teams and community \r\n\r\n- [ ] Implement, test, and benchmark source generator for collections \r\n\r\n  - [ ] Share progress with partner teams and community \r\n\r\n- [ ] Receive and react to user feedback \r\n\r\n  - [ ] Revisit and reconsider approaches taken in the initial experiment \r\n\r\n- [ ] Review and document unsupported JsonSerializer features within source generation feature \r\n\r\n- [ ] Polish end to end experience \r\n \r\n\r\nIt is important to note that the approaches mentioned above are for the base prototype and that we will iterate with the community in order to receive feedback and change the approaches as needed. We believe that with the base prototype, most changes won\u2019t be difficult to implement at a later phase and won\u2019t regress too much in terms of work. Progress of this effort can be seen through the [JSON Code Gen project board](https://github.com/dotnet/runtimelab/projects/1) in dotnet/runtimelab.\r\n\r\ncc @jkotas @davidfowl @stephentoub @mjsabby @terrajobst @pranavkm @ericstj @layomia @steveharter @chsienki",
        "Milestone": "6.0.0",
        "Assignees": [
          "steveharter",
          "kevinwkt"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-System.Text.Json",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "tenet-performance",
            "BackgroundColor": "c2e0c6"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3610",
        "CreatedAt": "2019-05-30T19:55:19+00:00",
        "CreatedBy": "dagood",
        "IsClosed": true,
        "Title": "VS insertion federation: insert Runtime into VS separately for SDK simplification",
        "DescriptionMarkdown": "To simplify SDK delivery, the Runtime needs to be able to service and insert into VS independently.\r\n\r\nAs of writing, the plan for 3.0 is for VS insertion tooling to be developed in Arcade with Core-SDK using it first, and then used in Core-Setup.\r\n\r\nMore info at https://github.com/dotnet/core-sdk/issues/2166.",
        "Milestone": "5.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3419",
        "CreatedAt": "2019-01-22T18:28:16+00:00",
        "CreatedBy": "dagood",
        "IsClosed": true,
        "Title": "AppHost Pack: netcoreapp packaging",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3399",
        "CreatedAt": "2019-01-08T23:37:50+00:00",
        "CreatedBy": "dsplaisted",
        "IsClosed": true,
        "Title": "Create targeting pack for Microsoft.WindowsDesktop.App",
        "DescriptionMarkdown": "For .NET Core 3.0, we expect to separate targeting packs, which contain the assets needed at build time when targeting .NET Core 3.0 (for example, reference assemblies and intellisense documentation) from \u0022runtime packs\u0022, which will include the platform-specific runtime components for .NET Core 3.  See dotnet/cli#10006, and [dotnet/designs#50](https://github.com/dotnet/designs/pull/50/files?short_path=ebf265d#diff-ebf265d0476041dd8cab82fa24ab5b0e)\r\n\r\nWe will have targeting pack for each shared framework (.NET Core, ASP.NET Core, and WindowsDesktop), as well as for .NET Standard.  This issue tracks the work required for the WindowsDesktop shared framework.\r\n\r\nThe work required includes:\r\n\r\n- A new NuGet package including the targeting pack assets.  This should include the reference assemblies, intellisense documentation, and platform manifest file.  The current straw man proposal for the package ID is \u0060Microsoft.NETCore.App.Ref\u0060\r\n- Installers for each supported installer format (msi, deb, pkg, and rpm), which lay out the targeting pack files under \u0060\u003CDOTNET_ROOT\u003E/packs/\u003CPackageId\u003E/version\u0060.  These installers will be bundled or depended on by the corresponding .NET Core SDK installers.\r\n\r\nSome of the details (such as package layout, names, etc) are still [under design](https://github.com/dotnet/designs/pull/50/files?short_path=ebf265d#diff-ebf265d0476041dd8cab82fa24ab5b0e) and may change slightly.  ",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3362",
        "CreatedAt": "2018-11-19T21:06:42+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": false,
        "Title": "Implement a build system for Snaps",
        "DescriptionMarkdown": ".NET Core Snaps are currently shipping but the process is manual. We need to implement a build system (based on Arcade)",
        "Milestone": "6.0.0",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Snap",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3361",
        "CreatedAt": "2018-11-19T21:00:16+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Core-setup builds using Arcade",
        "DescriptionMarkdown": "",
        "Milestone": "3.1",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Infrastructure-installer",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3356",
        "CreatedAt": "2018-11-19T20:55:25+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Loc Support",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          },
          {
            "Name": "donotuse_Triaged",
            "BackgroundColor": "c2ff72"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3353",
        "CreatedAt": "2018-11-19T20:52:27+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "ARM Runtime and Host packages and installers",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dleeapho"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3352",
        "CreatedAt": "2018-11-19T20:50:28+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Build installers, packages from upstream repos for host, hostfxr ",
        "DescriptionMarkdown": "With host and host fxr source moving to upstream repos (planned early 12/2018) we need to be able to continue to produce the installers and packages.",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3351",
        "CreatedAt": "2018-11-19T20:47:25+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": false,
        "Title": "Deployment and Servicing guidance for customers",
        "DescriptionMarkdown": "- Particularly for Windows desktop UI scenarios\n- How can enterprise customers deploy their apps to Windows clients?\n- How can enterprise customers service .NET Core to Windows clients?\n- How can customers author MSIX deployments via VS?",
        "Milestone": "5.0.0",
        "Assignees": [
          "dleeapho"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3350",
        "CreatedAt": "2018-11-19T20:40:01+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Runtime Pack netcoreapp packaging",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3347",
        "CreatedAt": "2018-11-19T20:36:57+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Targeting Pack: netcoreapp packaging",
        "DescriptionMarkdown": "",
        "Milestone": "3.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3343",
        "CreatedAt": "2018-11-19T20:31:55+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Shared Framework installer and common infrastructure",
        "DescriptionMarkdown": "1. Identify, and report redundancy of  common assemblies carried in multiple Shared Frameworks.\n2. Drive discussions among Technology owners, team doesn\u0027t own the decision or its delivery.\n3. Define requirement and provide common tooling to produce Shared Framework and installers.",
        "Milestone": "5.0.0",
        "Assignees": [
          "dagood"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#3342",
        "CreatedAt": "2018-11-19T20:24:39+00:00",
        "CreatedBy": "dleeapho",
        "IsClosed": true,
        "Title": "Customer-facing packages and installers have correct branding and naming",
        "DescriptionMarkdown": "- particularly new Windows desktop UI\n- also localized branding",
        "Milestone": "3.1",
        "Assignees": [
          "dleeapho"
        ],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Setup",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    },
    {
      "Issue": {
        "Id": "dotnet/runtime#9385",
        "CreatedAt": "2017-12-05T18:45:43+00:00",
        "CreatedBy": "brianrob",
        "IsClosed": true,
        "Title": "Tracing Epic",
        "DescriptionMarkdown": "",
        "Milestone": "Future",
        "Assignees": [],
        "Labels": [
          {
            "Name": "Epic",
            "BackgroundColor": "800080"
          },
          {
            "Name": "area-Tracing-coreclr",
            "BackgroundColor": "d4c5f9"
          }
        ],
        "Kind": 0,
        "ProjectStatus": null
      },
      "Children": []
    }
  ],
  "Assignees": [
    "AaronRobinsonMSFT",
    "agocke",
    "akoeplinger",
    "bradygaster",
    "cathysull",
    "dagood",
    "dleeapho",
    "EgorBo",
    "elinor-fung",
    "geoffkizer",
    "glennc",
    "jamshedd",
    "jeffschwMSFT",
    "jkoritzinsky",
    "jkotas",
    "kevinwkt",
    "mdh1418",
    "nkolev92",
    "richlander",
    "samsp-msft",
    "sfoslund",
    "steveharter",
    "swaroop-sridhar",
    "tarekgh",
    "terrajobst",
    "thaystg",
    "tommcdon",
    "vitek-karas",
    "VSadov",
    "zivkan",
    "zkat"
  ],
  "Milestones": [
    null,
    ".NET 5",
    "3.0",
    "3.1",
    "5.0.0",
    "5.0.1xx",
    "6.0.0",
    "Future",
    "Sprint 174 - 2020.07.27",
    "Sprint 175 - 2020.08.17",
    "Sprint 177 - 2020.09.28",
    "Sprint 178 - 2020.10.19"
  ],
  "Releases": [
    null,
    ".NET 6.0"
  ],
  "States": [
    null,
    "In progress",
    "Proposed"
  ]
}